"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/partner/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/auth/session.ts":
/*!*********************************!*\
  !*** ./src/lib/auth/session.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildLogoutUrl: function() { return /* binding */ buildLogoutUrl; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   getAccessToken: function() { return /* binding */ getAccessToken; },\n/* harmony export */   getAuthUser: function() { return /* binding */ getAuthUser; },\n/* harmony export */   getInitials: function() { return /* binding */ getInitials; },\n/* harmony export */   isAuthenticated: function() { return /* binding */ isAuthenticated; },\n/* harmony export */   isTokenExpired: function() { return /* binding */ isTokenExpired; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   refreshToken: function() { return /* binding */ refreshToken; }\n/* harmony export */ });\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// SECURITY: Tokens are now stored server-side in Redis via NextAuth\n// This file provides compatibility functions that use NextAuth session instead of localStorage\n// All token access is handled server-side by the API proxy\n\n/**\n * Check if user is authenticated using NextAuth session\n * Note: This is a synchronous check that may not be accurate during initial load\n * For accurate checks, use useSession() hook in React components\n */ function isAuthenticated() {\n    if (false) {}\n    // Check if session cookie exists (basic check)\n    // For accurate authentication status, use useSession() hook\n    const cookies = document.cookie.split(\";\");\n    const hasSessionCookie = cookies.some((cookie)=>cookie.trim().startsWith(\"next-auth.session-token=\") || cookie.trim().startsWith(\"__Secure-next-auth.session-token=\"));\n    return hasSessionCookie;\n}\n/**\n * SECURITY: Tokens are stored server-side in Redis\n * This function returns null - tokens should never be accessed from the frontend\n * The API proxy automatically injects tokens from Redis based on the session cookie\n */ async function getAccessToken() {\n    // SECURITY: Do not return tokens from frontend\n    // Tokens are stored server-side in Redis and injected by the proxy\n    console.warn(\"[SECURITY] getAccessToken() called - tokens are server-side only. Use API proxy instead.\");\n    return null;\n}\n/**\n * SECURITY: Token refresh is handled server-side by NextAuth\n * This function is deprecated - NextAuth handles token refresh automatically\n */ async function refreshToken() {\n    // Token refresh is handled server-side by NextAuth\n    // No action needed from frontend\n    console.warn(\"[SECURITY] refreshToken() called - token refresh is handled server-side by NextAuth\");\n    return false;\n}\n/**\n * Get authenticated user from NextAuth session\n * Note: This is a synchronous function that may not have accurate data during initial load\n * For accurate user data in React components, use useSession() hook from next-auth/react\n * or useAuth() hook from AuthContext\n */ function getAuthUser() {\n    if (false) {}\n    // Try to get user from NextAuth session via fetch (async but we return sync fallback)\n    // For accurate data, components should use useSession() hook\n    try {\n        // Check if session cookie exists\n        const cookies = document.cookie.split(\";\");\n        const hasSessionCookie = cookies.some((cookie)=>cookie.trim().startsWith(\"next-auth.session-token=\") || cookie.trim().startsWith(\"__Secure-next-auth.session-token=\"));\n        if (!hasSessionCookie) {\n            return {\n                name: \"User\"\n            };\n        }\n        // Try to get cached session data from sessionStorage (if available)\n        // This is a fallback - components should use useSession() hook\n        const sessionData = sessionStorage.getItem(\"nextauth.session.user\");\n        if (sessionData) {\n            try {\n                const user = JSON.parse(sessionData);\n                return {\n                    sub: user.id || user.email,\n                    name: user.name || user.email || \"User\",\n                    email: user.email\n                };\n            } catch (e) {\n            // Invalid session data\n            }\n        }\n    } catch (e) {\n    // Session storage not available or error\n    }\n    // Fallback: return default user\n    // Components should use useSession() hook or useAuth() for accurate data\n    return {\n        name: \"User\"\n    };\n}\n/**\n * Clear session and sign out using NextAuth\n */ function clearSession() {\n    if (false) {}\n    // SECURITY: Clear any legacy localStorage tokens (shouldn't exist, but clean up just in case)\n    // Tokens are now stored server-side in Redis, but we clean up localStorage for safety\n    try {\n        localStorage.removeItem(\"access_token\");\n        localStorage.removeItem(\"refresh_token\");\n        localStorage.removeItem(\"id_token\");\n        localStorage.removeItem(\"token_expires_at\");\n    } catch (e) {\n    // Ignore errors if localStorage is not available\n    }\n    // Clear session storage\n    sessionStorage.removeItem(\"nextauth.session.user\");\n    // Sign out using NextAuth (this will clear the session cookie)\n    (0,next_auth_react__WEBPACK_IMPORTED_MODULE_0__.signOut)({\n        callbackUrl: \"/auth/login\"\n    });\n}\n/**\n * Redirect to login page\n */ function redirectToLogin() {\n    if (false) {}\n    // Don't redirect if already on auth pages\n    if (window.location.pathname.startsWith(\"/auth/\")) return;\n    // Use replace to avoid adding to history\n    try {\n        window.location.replace(\"/auth/login\");\n    } catch (e) {\n        window.location.href = \"/auth/login\";\n    }\n}\n/**\n * Build logout URL for Keycloak\n * Note: NextAuth handles logout, but this is kept for compatibility\n */ function buildLogoutUrl(postLogoutRedirectUri) {\n    // NextAuth handles logout, but if needed for Keycloak direct logout:\n    const keycloakIssuer = process.env.NEXT_PUBLIC_KEYCLOAK_ISSUER || \"https://keycloak-staging.app-stg.mukuru.io/realms/mukuru\";\n    const base = \"\".concat(keycloakIssuer, \"/protocol/openid-connect/logout\");\n    const url = new URL(base);\n    url.searchParams.set(\"post_logout_redirect_uri\", postLogoutRedirectUri);\n    return url.toString();\n}\n/**\n * Logout user using NextAuth\n */ function logout() {\n    let postLogoutRedirectUri = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"/auth/login\";\n    // Use NextAuth signOut which handles session cleanup\n    (0,next_auth_react__WEBPACK_IMPORTED_MODULE_0__.signOut)({\n        callbackUrl: postLogoutRedirectUri\n    });\n}\n/**\n * Get user initials from name\n */ function getInitials(name) {\n    const parts = name.trim().split(/\\s+/).filter(Boolean);\n    if (parts.length === 0) return \"\";\n    if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();\n    return (parts[0][0] + parts[1][0]).toUpperCase();\n}\n/**\n * DEPRECATED: Token expiration check is handled server-side\n * This function is kept for compatibility but always returns false\n */ function isTokenExpired() {\n    let bufferSeconds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 120;\n    // Token expiration is handled server-side by NextAuth\n    // This function is deprecated\n    console.warn(\"[DEPRECATED] isTokenExpired() - token expiration is handled server-side\");\n    return false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXV0aC9zZXNzaW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRTtBQUNwRSwrRkFBK0Y7QUFDL0YsMkRBQTJEO0FBRWpCO0FBVTFDOzs7O0NBSUMsR0FDTSxTQUFTQztJQUNkLElBQUksS0FBa0IsRUFBYSxFQUFhO0lBRWhELCtDQUErQztJQUMvQyw0REFBNEQ7SUFDNUQsTUFBTUMsVUFBVUMsU0FBU0MsTUFBTSxDQUFDQyxLQUFLLENBQUM7SUFDdEMsTUFBTUMsbUJBQW1CSixRQUFRSyxJQUFJLENBQUNILENBQUFBLFNBQ3BDQSxPQUFPSSxJQUFJLEdBQUdDLFVBQVUsQ0FBQywrQkFDekJMLE9BQU9JLElBQUksR0FBR0MsVUFBVSxDQUFDO0lBRzNCLE9BQU9IO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ00sZUFBZUk7SUFDcEIsK0NBQStDO0lBQy9DLG1FQUFtRTtJQUNuRUMsUUFBUUMsSUFBSSxDQUFDO0lBQ2IsT0FBTztBQUNUO0FBRUE7OztDQUdDLEdBQ00sZUFBZUM7SUFDcEIsbURBQW1EO0lBQ25ELGlDQUFpQztJQUNqQ0YsUUFBUUMsSUFBSSxDQUFDO0lBQ2IsT0FBTztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTRTtJQUNkLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUVELHNGQUFzRjtJQUN0Riw2REFBNkQ7SUFDN0QsSUFBSTtRQUNGLGlDQUFpQztRQUNqQyxNQUFNWixVQUFVQyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQztRQUN0QyxNQUFNQyxtQkFBbUJKLFFBQVFLLElBQUksQ0FBQ0gsQ0FBQUEsU0FDcENBLE9BQU9JLElBQUksR0FBR0MsVUFBVSxDQUFDLCtCQUN6QkwsT0FBT0ksSUFBSSxHQUFHQyxVQUFVLENBQUM7UUFHM0IsSUFBSSxDQUFDSCxrQkFBa0I7WUFDckIsT0FBTztnQkFBRVMsTUFBTTtZQUFPO1FBQ3hCO1FBRUEsb0VBQW9FO1FBQ3BFLCtEQUErRDtRQUMvRCxNQUFNQyxjQUFjQyxlQUFlQyxPQUFPLENBQUM7UUFDM0MsSUFBSUYsYUFBYTtZQUNmLElBQUk7Z0JBQ0YsTUFBTUcsT0FBT0MsS0FBS0MsS0FBSyxDQUFDTDtnQkFDeEIsT0FBTztvQkFDTE0sS0FBS0gsS0FBS0ksRUFBRSxJQUFJSixLQUFLSyxLQUFLO29CQUMxQlQsTUFBTUksS0FBS0osSUFBSSxJQUFJSSxLQUFLSyxLQUFLLElBQUk7b0JBQ2pDQSxPQUFPTCxLQUFLSyxLQUFLO2dCQUNuQjtZQUNGLEVBQUUsVUFBTTtZQUNOLHVCQUF1QjtZQUN6QjtRQUNGO0lBQ0YsRUFBRSxVQUFNO0lBQ04seUNBQXlDO0lBQzNDO0lBRUEsZ0NBQWdDO0lBQ2hDLHlFQUF5RTtJQUN6RSxPQUFPO1FBQ0xULE1BQU07SUFDUjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTVTtJQUNkLElBQUksS0FBa0IsRUFBYSxFQUFPO0lBRTFDLDhGQUE4RjtJQUM5RixzRkFBc0Y7SUFDdEYsSUFBSTtRQUNGQyxhQUFhQyxVQUFVLENBQUM7UUFDeEJELGFBQWFDLFVBQVUsQ0FBQztRQUN4QkQsYUFBYUMsVUFBVSxDQUFDO1FBQ3hCRCxhQUFhQyxVQUFVLENBQUM7SUFDMUIsRUFBRSxVQUFNO0lBQ04saURBQWlEO0lBQ25EO0lBRUEsd0JBQXdCO0lBQ3hCVixlQUFlVSxVQUFVLENBQUM7SUFFMUIsK0RBQStEO0lBQy9EM0Isd0RBQU9BLENBQUM7UUFBRTRCLGFBQWE7SUFBYztBQUN2QztBQUVBOztDQUVDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJLEtBQWtCLEVBQWEsRUFBTztJQUUxQywwQ0FBMEM7SUFDMUMsSUFBSUMsT0FBT0MsUUFBUSxDQUFDQyxRQUFRLENBQUN2QixVQUFVLENBQUMsV0FBVztJQUVuRCx5Q0FBeUM7SUFDekMsSUFBSTtRQUNGcUIsT0FBT0MsUUFBUSxDQUFDRSxPQUFPLENBQUM7SUFDMUIsRUFBRSxVQUFNO1FBQ05ILE9BQU9DLFFBQVEsQ0FBQ0csSUFBSSxHQUFHO0lBQ3pCO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTQyxlQUFlQyxxQkFBNkI7SUFDMUQscUVBQXFFO0lBQ3JFLE1BQU1DLGlCQUFpQkMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQywyQkFBMkIsSUFBSTtJQUNsRSxNQUFNQyxPQUFPLEdBQWtCLE9BQWZKLGdCQUFlO0lBQy9CLE1BQU1LLE1BQU0sSUFBSUMsSUFBSUY7SUFDcEJDLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLDRCQUE0QlQ7SUFDakQsT0FBT00sSUFBSUksUUFBUTtBQUNyQjtBQUVBOztDQUVDLEdBQ00sU0FBU0M7UUFBT1gsd0JBQUFBLGlFQUFnQztJQUNyRCxxREFBcUQ7SUFDckRwQyx3REFBT0EsQ0FBQztRQUFFNEIsYUFBYVE7SUFBc0I7QUFDL0M7QUFFQTs7Q0FFQyxHQUNNLFNBQVNZLFlBQVlqQyxJQUFZO0lBQ3RDLE1BQU1rQyxRQUFRbEMsS0FBS1AsSUFBSSxHQUFHSCxLQUFLLENBQUMsT0FBTzZDLE1BQU0sQ0FBQ0M7SUFDOUMsSUFBSUYsTUFBTUcsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUMvQixJQUFJSCxNQUFNRyxNQUFNLEtBQUssR0FBRyxPQUFPSCxLQUFLLENBQUMsRUFBRSxDQUFDSSxLQUFLLENBQUMsR0FBRyxHQUFHQyxXQUFXO0lBQy9ELE9BQU8sQ0FBQ0wsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFSyxXQUFXO0FBQ2hEO0FBRUE7OztDQUdDLEdBQ00sU0FBU0M7UUFBZUMsZ0JBQUFBLGlFQUF3QjtJQUNyRCxzREFBc0Q7SUFDdEQsOEJBQThCO0lBQzlCN0MsUUFBUUMsSUFBSSxDQUFDO0lBQ2IsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXV0aC9zZXNzaW9uLnRzPzU4ODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU0VDVVJJVFk6IFRva2VucyBhcmUgbm93IHN0b3JlZCBzZXJ2ZXItc2lkZSBpbiBSZWRpcyB2aWEgTmV4dEF1dGhcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBjb21wYXRpYmlsaXR5IGZ1bmN0aW9ucyB0aGF0IHVzZSBOZXh0QXV0aCBzZXNzaW9uIGluc3RlYWQgb2YgbG9jYWxTdG9yYWdlXG4vLyBBbGwgdG9rZW4gYWNjZXNzIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUgYnkgdGhlIEFQSSBwcm94eVxuXG5pbXBvcnQgeyBzaWduT3V0IH0gZnJvbSBcIm5leHQtYXV0aC9yZWFjdFwiO1xuXG5leHBvcnQgdHlwZSBBdXRoVXNlciA9IHtcbiAgc3ViPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBnaXZlbk5hbWU/OiBzdHJpbmc7XG4gIGZhbWlseU5hbWU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZCB1c2luZyBOZXh0QXV0aCBzZXNzaW9uXG4gKiBOb3RlOiBUaGlzIGlzIGEgc3luY2hyb25vdXMgY2hlY2sgdGhhdCBtYXkgbm90IGJlIGFjY3VyYXRlIGR1cmluZyBpbml0aWFsIGxvYWRcbiAqIEZvciBhY2N1cmF0ZSBjaGVja3MsIHVzZSB1c2VTZXNzaW9uKCkgaG9vayBpbiBSZWFjdCBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgaWYgc2Vzc2lvbiBjb29raWUgZXhpc3RzIChiYXNpYyBjaGVjaylcbiAgLy8gRm9yIGFjY3VyYXRlIGF1dGhlbnRpY2F0aW9uIHN0YXR1cywgdXNlIHVzZVNlc3Npb24oKSBob29rXG4gIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgY29uc3QgaGFzU2Vzc2lvbkNvb2tpZSA9IGNvb2tpZXMuc29tZShjb29raWUgPT4gXG4gICAgY29va2llLnRyaW0oKS5zdGFydHNXaXRoKCduZXh0LWF1dGguc2Vzc2lvbi10b2tlbj0nKSB8fCBcbiAgICBjb29raWUudHJpbSgpLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLW5leHQtYXV0aC5zZXNzaW9uLXRva2VuPScpXG4gICk7XG4gIFxuICByZXR1cm4gaGFzU2Vzc2lvbkNvb2tpZTtcbn1cblxuLyoqXG4gKiBTRUNVUklUWTogVG9rZW5zIGFyZSBzdG9yZWQgc2VydmVyLXNpZGUgaW4gUmVkaXNcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBudWxsIC0gdG9rZW5zIHNob3VsZCBuZXZlciBiZSBhY2Nlc3NlZCBmcm9tIHRoZSBmcm9udGVuZFxuICogVGhlIEFQSSBwcm94eSBhdXRvbWF0aWNhbGx5IGluamVjdHMgdG9rZW5zIGZyb20gUmVkaXMgYmFzZWQgb24gdGhlIHNlc3Npb24gY29va2llXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgLy8gU0VDVVJJVFk6IERvIG5vdCByZXR1cm4gdG9rZW5zIGZyb20gZnJvbnRlbmRcbiAgLy8gVG9rZW5zIGFyZSBzdG9yZWQgc2VydmVyLXNpZGUgaW4gUmVkaXMgYW5kIGluamVjdGVkIGJ5IHRoZSBwcm94eVxuICBjb25zb2xlLndhcm4oJ1tTRUNVUklUWV0gZ2V0QWNjZXNzVG9rZW4oKSBjYWxsZWQgLSB0b2tlbnMgYXJlIHNlcnZlci1zaWRlIG9ubHkuIFVzZSBBUEkgcHJveHkgaW5zdGVhZC4nKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogU0VDVVJJVFk6IFRva2VuIHJlZnJlc2ggaXMgaGFuZGxlZCBzZXJ2ZXItc2lkZSBieSBOZXh0QXV0aFxuICogVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIC0gTmV4dEF1dGggaGFuZGxlcyB0b2tlbiByZWZyZXNoIGF1dG9tYXRpY2FsbHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hUb2tlbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgLy8gVG9rZW4gcmVmcmVzaCBpcyBoYW5kbGVkIHNlcnZlci1zaWRlIGJ5IE5leHRBdXRoXG4gIC8vIE5vIGFjdGlvbiBuZWVkZWQgZnJvbSBmcm9udGVuZFxuICBjb25zb2xlLndhcm4oJ1tTRUNVUklUWV0gcmVmcmVzaFRva2VuKCkgY2FsbGVkIC0gdG9rZW4gcmVmcmVzaCBpcyBoYW5kbGVkIHNlcnZlci1zaWRlIGJ5IE5leHRBdXRoJyk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRlZCB1c2VyIGZyb20gTmV4dEF1dGggc2Vzc2lvblxuICogTm90ZTogVGhpcyBpcyBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgbWF5IG5vdCBoYXZlIGFjY3VyYXRlIGRhdGEgZHVyaW5nIGluaXRpYWwgbG9hZFxuICogRm9yIGFjY3VyYXRlIHVzZXIgZGF0YSBpbiBSZWFjdCBjb21wb25lbnRzLCB1c2UgdXNlU2Vzc2lvbigpIGhvb2sgZnJvbSBuZXh0LWF1dGgvcmVhY3RcbiAqIG9yIHVzZUF1dGgoKSBob29rIGZyb20gQXV0aENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhVc2VyKCk6IEF1dGhVc2VyIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHsgbmFtZTogJ1VzZXInIH07XG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHVzZXIgZnJvbSBOZXh0QXV0aCBzZXNzaW9uIHZpYSBmZXRjaCAoYXN5bmMgYnV0IHdlIHJldHVybiBzeW5jIGZhbGxiYWNrKVxuICAvLyBGb3IgYWNjdXJhdGUgZGF0YSwgY29tcG9uZW50cyBzaG91bGQgdXNlIHVzZVNlc3Npb24oKSBob29rXG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgc2Vzc2lvbiBjb29raWUgZXhpc3RzXG4gICAgY29uc3QgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgIGNvbnN0IGhhc1Nlc3Npb25Db29raWUgPSBjb29raWVzLnNvbWUoY29va2llID0+IFxuICAgICAgY29va2llLnRyaW0oKS5zdGFydHNXaXRoKCduZXh0LWF1dGguc2Vzc2lvbi10b2tlbj0nKSB8fCBcbiAgICAgIGNvb2tpZS50cmltKCkuc3RhcnRzV2l0aCgnX19TZWN1cmUtbmV4dC1hdXRoLnNlc3Npb24tdG9rZW49JylcbiAgICApO1xuICAgIFxuICAgIGlmICghaGFzU2Vzc2lvbkNvb2tpZSkge1xuICAgICAgcmV0dXJuIHsgbmFtZTogJ1VzZXInIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgY2FjaGVkIHNlc3Npb24gZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlIChpZiBhdmFpbGFibGUpXG4gICAgLy8gVGhpcyBpcyBhIGZhbGxiYWNrIC0gY29tcG9uZW50cyBzaG91bGQgdXNlIHVzZVNlc3Npb24oKSBob29rXG4gICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCduZXh0YXV0aC5zZXNzaW9uLnVzZXInKTtcbiAgICBpZiAoc2Vzc2lvbkRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHNlc3Npb25EYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWI6IHVzZXIuaWQgfHwgdXNlci5lbWFpbCxcbiAgICAgICAgICBuYW1lOiB1c2VyLm5hbWUgfHwgdXNlci5lbWFpbCB8fCAnVXNlcicsXG4gICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gSW52YWxpZCBzZXNzaW9uIGRhdGFcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIFNlc3Npb24gc3RvcmFnZSBub3QgYXZhaWxhYmxlIG9yIGVycm9yXG4gIH1cblxuICAvLyBGYWxsYmFjazogcmV0dXJuIGRlZmF1bHQgdXNlclxuICAvLyBDb21wb25lbnRzIHNob3VsZCB1c2UgdXNlU2Vzc2lvbigpIGhvb2sgb3IgdXNlQXV0aCgpIGZvciBhY2N1cmF0ZSBkYXRhXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1VzZXInLFxuICB9O1xufVxuXG4vKipcbiAqIENsZWFyIHNlc3Npb24gYW5kIHNpZ24gb3V0IHVzaW5nIE5leHRBdXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNlc3Npb24oKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgLy8gU0VDVVJJVFk6IENsZWFyIGFueSBsZWdhY3kgbG9jYWxTdG9yYWdlIHRva2VucyAoc2hvdWxkbid0IGV4aXN0LCBidXQgY2xlYW4gdXAganVzdCBpbiBjYXNlKVxuICAvLyBUb2tlbnMgYXJlIG5vdyBzdG9yZWQgc2VydmVyLXNpZGUgaW4gUmVkaXMsIGJ1dCB3ZSBjbGVhbiB1cCBsb2NhbFN0b3JhZ2UgZm9yIHNhZmV0eVxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NfdG9rZW4nKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaF90b2tlbicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdpZF90b2tlbicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd0b2tlbl9leHBpcmVzX2F0Jyk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIElnbm9yZSBlcnJvcnMgaWYgbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbiAgfVxuICBcbiAgLy8gQ2xlYXIgc2Vzc2lvbiBzdG9yYWdlXG4gIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ25leHRhdXRoLnNlc3Npb24udXNlcicpO1xuICBcbiAgLy8gU2lnbiBvdXQgdXNpbmcgTmV4dEF1dGggKHRoaXMgd2lsbCBjbGVhciB0aGUgc2Vzc2lvbiBjb29raWUpXG4gIHNpZ25PdXQoeyBjYWxsYmFja1VybDogJy9hdXRoL2xvZ2luJyB9KTtcbn1cblxuLyoqXG4gKiBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXG4gKi9cbmZ1bmN0aW9uIHJlZGlyZWN0VG9Mb2dpbigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICAvLyBEb24ndCByZWRpcmVjdCBpZiBhbHJlYWR5IG9uIGF1dGggcGFnZXNcbiAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zdGFydHNXaXRoKCcvYXV0aC8nKSkgcmV0dXJuO1xuICBcbiAgLy8gVXNlIHJlcGxhY2UgdG8gYXZvaWQgYWRkaW5nIHRvIGhpc3RvcnlcbiAgdHJ5IHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnL2F1dGgvbG9naW4nKTtcbiAgfSBjYXRjaCB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2F1dGgvbG9naW4nO1xuICB9XG59XG5cbi8qKlxuICogQnVpbGQgbG9nb3V0IFVSTCBmb3IgS2V5Y2xvYWtcbiAqIE5vdGU6IE5leHRBdXRoIGhhbmRsZXMgbG9nb3V0LCBidXQgdGhpcyBpcyBrZXB0IGZvciBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvZ291dFVybChwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIE5leHRBdXRoIGhhbmRsZXMgbG9nb3V0LCBidXQgaWYgbmVlZGVkIGZvciBLZXljbG9hayBkaXJlY3QgbG9nb3V0OlxuICBjb25zdCBrZXljbG9ha0lzc3VlciA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0tFWUNMT0FLX0lTU1VFUiB8fCAnaHR0cHM6Ly9rZXljbG9hay1zdGFnaW5nLmFwcC1zdGcubXVrdXJ1LmlvL3JlYWxtcy9tdWt1cnUnO1xuICBjb25zdCBiYXNlID0gYCR7a2V5Y2xvYWtJc3N1ZXJ9L3Byb3RvY29sL29wZW5pZC1jb25uZWN0L2xvZ291dGA7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZSk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwb3N0X2xvZ291dF9yZWRpcmVjdF91cmknLCBwb3N0TG9nb3V0UmVkaXJlY3RVcmkpO1xuICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogTG9nb3V0IHVzZXIgdXNpbmcgTmV4dEF1dGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ291dChwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IHN0cmluZyA9ICcvYXV0aC9sb2dpbicpIHtcbiAgLy8gVXNlIE5leHRBdXRoIHNpZ25PdXQgd2hpY2ggaGFuZGxlcyBzZXNzaW9uIGNsZWFudXBcbiAgc2lnbk91dCh7IGNhbGxiYWNrVXJsOiBwb3N0TG9nb3V0UmVkaXJlY3RVcmkgfSk7XG59XG5cbi8qKlxuICogR2V0IHVzZXIgaW5pdGlhbHMgZnJvbSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFscyhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdLnNsaWNlKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAocGFydHNbMF1bMF0gKyBwYXJ0c1sxXVswXSkudG9VcHBlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBERVBSRUNBVEVEOiBUb2tlbiBleHBpcmF0aW9uIGNoZWNrIGlzIGhhbmRsZWQgc2VydmVyLXNpZGVcbiAqIFRoaXMgZnVuY3Rpb24gaXMga2VwdCBmb3IgY29tcGF0aWJpbGl0eSBidXQgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5FeHBpcmVkKGJ1ZmZlclNlY29uZHM6IG51bWJlciA9IDEyMCk6IGJvb2xlYW4ge1xuICAvLyBUb2tlbiBleHBpcmF0aW9uIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUgYnkgTmV4dEF1dGhcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkXG4gIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGlzVG9rZW5FeHBpcmVkKCkgLSB0b2tlbiBleHBpcmF0aW9uIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUnKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbInNpZ25PdXQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjb29raWVzIiwiZG9jdW1lbnQiLCJjb29raWUiLCJzcGxpdCIsImhhc1Nlc3Npb25Db29raWUiLCJzb21lIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJnZXRBY2Nlc3NUb2tlbiIsImNvbnNvbGUiLCJ3YXJuIiwicmVmcmVzaFRva2VuIiwiZ2V0QXV0aFVzZXIiLCJuYW1lIiwic2Vzc2lvbkRhdGEiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJ1c2VyIiwiSlNPTiIsInBhcnNlIiwic3ViIiwiaWQiLCJlbWFpbCIsImNsZWFyU2Vzc2lvbiIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJjYWxsYmFja1VybCIsInJlZGlyZWN0VG9Mb2dpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiaHJlZiIsImJ1aWxkTG9nb3V0VXJsIiwicG9zdExvZ291dFJlZGlyZWN0VXJpIiwia2V5Y2xvYWtJc3N1ZXIiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfS0VZQ0xPQUtfSVNTVUVSIiwiYmFzZSIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwibG9nb3V0IiwiZ2V0SW5pdGlhbHMiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJzbGljZSIsInRvVXBwZXJDYXNlIiwiaXNUb2tlbkV4cGlyZWQiLCJidWZmZXJTZWNvbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/auth/session.ts\n"));

/***/ })

});