"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/partner/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/auth/session.ts":
/*!*********************************!*\
  !*** ./src/lib/auth/session.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildLogoutUrl: function() { return /* binding */ buildLogoutUrl; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   getAccessToken: function() { return /* binding */ getAccessToken; },\n/* harmony export */   getAuthUser: function() { return /* binding */ getAuthUser; },\n/* harmony export */   getInitials: function() { return /* binding */ getInitials; },\n/* harmony export */   isAuthenticated: function() { return /* binding */ isAuthenticated; },\n/* harmony export */   isTokenExpired: function() { return /* binding */ isTokenExpired; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   refreshToken: function() { return /* binding */ refreshToken; }\n/* harmony export */ });\n// SECURITY: Tokens are now stored server-side in Redis via NextAuth\n// This file provides compatibility functions that use NextAuth session instead of localStorage\nfunction decodeJwt(token) {\n    try {\n        const parts = token.split(\".\");\n        if (parts.length !== 3) {\n            return null;\n        }\n        const [, payload] = parts;\n        const json = atob(payload.replace(/-/g, \"+\").replace(/_/g, \"/\"));\n        return JSON.parse(json);\n    } catch (e) {\n        return null;\n    }\n}\n/**\n * Validate JWT token format and expiration\n */ function isValidJwt(token) {\n    if (!token || typeof token !== \"string\") {\n        return false;\n    }\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        return false;\n    }\n    const payload = decodeJwt(token);\n    if (!payload) {\n        return false;\n    }\n    // Check expiration time (exp is in seconds)\n    if (payload.exp) {\n        const expirationTime = payload.exp * 1000;\n        const now = Date.now();\n        // Add 60 second buffer\n        if (now >= expirationTime - 60000) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Check if the access token exists and is valid\n */ function isAuthenticated() {\n    if (false) {}\n    // In development, check cached auth status first to prevent flashing\n    const cached = getCachedAuthCheck();\n    if (cached !== null) {\n        return cached;\n    }\n    // Try to restore tokens if they were lost (development only)\n    restoreTokensIfNeeded();\n    const token = localStorage.getItem(\"access_token\");\n    if (!token) {\n        cacheAuthCheck(false);\n        return false;\n    }\n    // Check if token is ACTUALLY expired (no buffer)\n    // We only use buffer for proactive refresh, not for auth status\n    if (isTokenExpired(0)) {\n        cacheAuthCheck(false);\n        return false;\n    }\n    cacheAuthCheck(true);\n    return true;\n}\n/**\n * Check if the access token is expired or about to expire\n * Validates both stored timestamp and actual JWT expiration\n * Default buffer increased to 120 seconds to avoid aggressive refreshing\n */ function isTokenExpired() {\n    let bufferSeconds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 120;\n    if (false) {}\n    const token = localStorage.getItem(\"access_token\");\n    if (!token) return true;\n    // First check JWT expiration from the token itself (most reliable)\n    const payload = decodeJwt(token);\n    if (payload === null || payload === void 0 ? void 0 : payload.exp) {\n        const expirationTime = payload.exp * 1000; // JWT exp is in seconds\n        const now = Date.now();\n        const expirationTimeWithBuffer = expirationTime - bufferSeconds * 1000;\n        if (now >= expirationTimeWithBuffer) {\n            return true;\n        }\n    }\n    // Fallback to stored timestamp\n    const expiresAt = localStorage.getItem(\"token_expires_at\");\n    if (!expiresAt) {\n        // If we have a token but no stored timestamp, validate the JWT\n        return !isValidJwt(token);\n    }\n    const expiresTimestamp = parseInt(expiresAt, 10);\n    if (isNaN(expiresTimestamp)) {\n        return !isValidJwt(token);\n    }\n    const now = Date.now();\n    const expirationTime = expiresTimestamp - bufferSeconds * 1000;\n    return now >= expirationTime;\n}\n/**\n * Get the access token, refreshing if necessary\n */ async function getAccessToken() {\n    if (false) {}\n    const token = localStorage.getItem(\"access_token\");\n    if (!token) return null;\n    // Only refresh if token is actually expired or very close to expiry (30 seconds)\n    // This prevents aggressive refresh attempts\n    if (isTokenExpired(30)) {\n        console.log(\"Token expired or expiring soon, attempting refresh...\");\n        const refreshed = await refreshToken();\n        if (refreshed) {\n            return localStorage.getItem(\"access_token\");\n        }\n        // If refresh failed but token might still be valid, return it\n        // Let the API call fail if the token is truly invalid\n        if (!isTokenExpired(0)) {\n            return token;\n        }\n        return null;\n    }\n    return token;\n}\n/**\n * Refresh the access token using the refresh token\n */ let refreshingPromise = null;\nasync function refreshToken() {\n    if (false) {}\n    // If already refreshing, wait for that promise\n    if (refreshingPromise) {\n        return refreshingPromise;\n    }\n    // Double-check if we really need to refresh\n    const currentToken = localStorage.getItem(\"access_token\");\n    if (currentToken && !isTokenExpired(30)) {\n        // Token is still valid, no need to refresh\n        return Promise.resolve(true);\n    }\n    const refreshTokenValue = localStorage.getItem(\"refresh_token\");\n    if (!refreshTokenValue) {\n        // No refresh token, need to re-authenticate\n        clearSession();\n        redirectToLogin();\n        return false;\n    }\n    refreshingPromise = (async ()=>{\n        try {\n            var _decodeJwt;\n            const body = new URLSearchParams({\n                grant_type: \"refresh_token\",\n                client_id: authConfig.clientId,\n                refresh_token: refreshTokenValue\n            });\n            const response = await fetch(authConfig.tokenUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                },\n                body: body.toString()\n            });\n            if (!response.ok) {\n                // Log the error details for debugging\n                const errorText = await response.text();\n                console.error(\"Token refresh failed with status:\", response.status);\n                console.error(\"Error details:\", errorText);\n                // Only clear session and redirect if it's a 401 (unauthorized) or refresh token is truly invalid\n                if (response.status === 401 || response.status === 403) {\n                    clearSession();\n                    redirectToLogin();\n                }\n                return false;\n            }\n            const tokens = await response.json();\n            const access = tokens.access_token;\n            const refresh = tokens.refresh_token;\n            // Validate tokens before storing\n            if (!access || !isValidJwt(access)) {\n                console.error(\"Invalid access token received from refresh\");\n                clearSession();\n                redirectToLogin();\n                return false;\n            }\n            // Update tokens in localStorage\n            localStorage.setItem(\"access_token\", access);\n            if (refresh) {\n                localStorage.setItem(\"refresh_token\", refresh);\n            }\n            if (tokens.id_token) {\n                localStorage.setItem(\"id_token\", tokens.id_token);\n            }\n            // Backup tokens in development\n            backupTokens();\n            // Use expires_in from response, or calculate from JWT exp, or default to 3600\n            const expiresIn = tokens.expires_in || (((_decodeJwt = decodeJwt(access)) === null || _decodeJwt === void 0 ? void 0 : _decodeJwt.exp) ? undefined : 3600);\n            if (expiresIn) {\n                localStorage.setItem(\"token_expires_at\", String(Date.now() + expiresIn * 1000));\n            } else {\n                // Calculate from JWT exp\n                const payload = decodeJwt(access);\n                if (payload === null || payload === void 0 ? void 0 : payload.exp) {\n                    localStorage.setItem(\"token_expires_at\", String(payload.exp * 1000));\n                } else {\n                    localStorage.setItem(\"token_expires_at\", String(Date.now() + 3600 * 1000));\n                }\n            }\n            // Trigger storage event to notify other tabs\n            window.dispatchEvent(new StorageEvent(\"storage\", {\n                key: \"access_token\",\n                newValue: access\n            }));\n            return true;\n        } catch (error) {\n            console.error(\"Token refresh failed:\", error);\n            // Don't immediately clear session - network errors shouldn't log user out\n            // Only clear if we're certain the refresh token is invalid\n            return false;\n        } finally{\n            refreshingPromise = null;\n        }\n    })();\n    return refreshingPromise;\n}\n/**\n * Clear all session data\n */ function clearSession() {\n    if (false) {}\n    localStorage.removeItem(\"access_token\");\n    localStorage.removeItem(\"refresh_token\");\n    localStorage.removeItem(\"id_token\");\n    localStorage.removeItem(\"token_expires_at\");\n}\n/**\n * Redirect to login page\n */ function redirectToLogin() {\n    if (false) {}\n    // Don't redirect if already on auth pages\n    if (window.location.pathname.startsWith(\"/auth/\")) return;\n    // Don't redirect if we're in the middle of a refresh\n    if (refreshingPromise) return;\n    // Add a small delay to prevent race conditions during app initialization\n    setTimeout(()=>{\n        // Double-check that we really need to redirect\n        const token = localStorage.getItem(\"access_token\");\n        if (token && !isTokenExpired(0)) {\n            // Token is still valid, don't redirect\n            return;\n        }\n        // Use replace to avoid adding to history\n        try {\n            window.location.replace(\"/auth/login\");\n        } catch (e) {\n            window.location.href = \"/auth/login\";\n        }\n    }, 100);\n}\nfunction getAuthUser() {\n    const access =  true ? localStorage.getItem(\"access_token\") : 0;\n    const id =  true ? localStorage.getItem(\"id_token\") : 0;\n    const tokenPayload = access ? decodeJwt(access) : null;\n    const idPayload = id ? decodeJwt(id) : null;\n    const fullName = (idPayload === null || idPayload === void 0 ? void 0 : idPayload.name) || [\n        idPayload === null || idPayload === void 0 ? void 0 : idPayload.given_name,\n        idPayload === null || idPayload === void 0 ? void 0 : idPayload.family_name\n    ].filter(Boolean).join(\" \") || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.name) || [\n        tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.given_name,\n        tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.family_name\n    ].filter(Boolean).join(\" \") || (idPayload === null || idPayload === void 0 ? void 0 : idPayload.preferred_username) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.preferred_username) || (idPayload === null || idPayload === void 0 ? void 0 : idPayload.email) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.email) || \"User\";\n    const email = (idPayload === null || idPayload === void 0 ? void 0 : idPayload.email) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.email);\n    const sub = (idPayload === null || idPayload === void 0 ? void 0 : idPayload.sub) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.sub);\n    return {\n        sub,\n        name: fullName,\n        email,\n        givenName: (idPayload === null || idPayload === void 0 ? void 0 : idPayload.given_name) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.given_name),\n        familyName: (idPayload === null || idPayload === void 0 ? void 0 : idPayload.family_name) || (tokenPayload === null || tokenPayload === void 0 ? void 0 : tokenPayload.family_name)\n    };\n}\nfunction buildLogoutUrl(postLogoutRedirectUri) {\n    const base = authConfig.authUrl.replace(\"/auth\", \"/logout\");\n    const url = new URL(base);\n    url.searchParams.set(\"client_id\", authConfig.clientId);\n    url.searchParams.set(\"post_logout_redirect_uri\", postLogoutRedirectUri);\n    const id =  true ? localStorage.getItem(\"id_token\") : 0;\n    if (id) url.searchParams.set(\"id_token_hint\", id);\n    return url.toString();\n}\nfunction logout() {\n    let postLogoutRedirectUri = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"http://localhost:3000/\";\n    try {\n        clearSession();\n        const logoutUrl = buildLogoutUrl(postLogoutRedirectUri);\n        window.location.href = logoutUrl;\n    } catch (e) {\n        clearSession();\n        window.location.href = postLogoutRedirectUri;\n    }\n}\nfunction getInitials(name) {\n    const parts = name.trim().split(/\\s+/).filter(Boolean);\n    if (parts.length === 0) return \"\";\n    if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();\n    return (parts[0][0] + parts[1][0]).toUpperCase();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXV0aC9zZXNzaW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRTtBQUNwRSwrRkFBK0Y7QUFHL0YsU0FBU0EsVUFBVUMsS0FBYTtJQUM5QixJQUFJO1FBQ0YsTUFBTUMsUUFBUUQsTUFBTUUsS0FBSyxDQUFDO1FBQzFCLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHO1lBQ3RCLE9BQU87UUFDVDtRQUNBLE1BQU0sR0FBR0MsUUFBUSxHQUFHSDtRQUNwQixNQUFNSSxPQUFPQyxLQUFLRixRQUFRRyxPQUFPLENBQUMsTUFBTSxLQUFLQSxPQUFPLENBQUMsTUFBTTtRQUMzRCxPQUFPQyxLQUFLQyxLQUFLLENBQUNKO0lBQ3BCLEVBQUUsVUFBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxTQUFTSyxXQUFXVixLQUFhO0lBQy9CLElBQUksQ0FBQ0EsU0FBUyxPQUFPQSxVQUFVLFVBQVU7UUFDdkMsT0FBTztJQUNUO0lBRUEsTUFBTUMsUUFBUUQsTUFBTUUsS0FBSyxDQUFDO0lBQzFCLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE9BQU87SUFDVDtJQUVBLE1BQU1DLFVBQVVMLFVBQVVDO0lBQzFCLElBQUksQ0FBQ0ksU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLDRDQUE0QztJQUM1QyxJQUFJQSxRQUFRTyxHQUFHLEVBQUU7UUFDZixNQUFNQyxpQkFBaUJSLFFBQVFPLEdBQUcsR0FBRztRQUNyQyxNQUFNRSxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLHVCQUF1QjtRQUN2QixJQUFJQSxPQUFPRCxpQkFBaUIsT0FBTztZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQVVBOztDQUVDLEdBQ00sU0FBU0c7SUFDZCxJQUFJLEtBQWtCLEVBQWEsRUFBYTtJQUVoRCxxRUFBcUU7SUFDckUsTUFBTUMsU0FBU0M7SUFDZixJQUFJRCxXQUFXLE1B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QU0sS0FBSyxHQUFHLE9BQU9GLEtBQUssQ0FBQyxFQUFFLENBQUM0RyxLQUFLLENBQUMsR0FBRyxHQUFHQyxXQUFXO0lBQy9ELE9BQU8sQ0FBQzdHLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTZHLFdBQVc7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hdXRoL3Nlc3Npb24udHM/NTg4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTRUNVUklUWTogVG9rZW5zIGFyZSBub3cgc3RvcmVkIHNlcnZlci1zaWRlIGluIFJlZGlzIHZpYSBOZXh0QXV0aFxuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIGNvbXBhdGliaWxpdHkgZnVuY3Rpb25zIHRoYXQgdXNlIE5leHRBdXRoIHNlc3Npb24gaW5zdGVhZCBvZiBsb2NhbFN0b3JhZ2VcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCI7XG5cbmZ1bmN0aW9uIGRlY29kZUp3dCh0b2tlbjogc3RyaW5nKTogYW55IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdChcIi5cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFssIHBheWxvYWRdID0gcGFydHM7XG4gICAgY29uc3QganNvbiA9IGF0b2IocGF5bG9hZC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKSk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgSldUIHRva2VuIGZvcm1hdCBhbmQgZXhwaXJhdGlvblxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSnd0KHRva2VuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVKd3QodG9rZW4pO1xuICBpZiAoIXBheWxvYWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIENoZWNrIGV4cGlyYXRpb24gdGltZSAoZXhwIGlzIGluIHNlY29uZHMpXG4gIGlmIChwYXlsb2FkLmV4cCkge1xuICAgIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gcGF5bG9hZC5leHAgKiAxMDAwO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgLy8gQWRkIDYwIHNlY29uZCBidWZmZXJcbiAgICBpZiAobm93ID49IGV4cGlyYXRpb25UaW1lIC0gNjAwMDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgdHlwZSBBdXRoVXNlciA9IHtcbiAgc3ViPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBnaXZlbk5hbWU/OiBzdHJpbmc7XG4gIGZhbWlseU5hbWU/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhY2Nlc3MgdG9rZW4gZXhpc3RzIGFuZCBpcyB2YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIEluIGRldmVsb3BtZW50LCBjaGVjayBjYWNoZWQgYXV0aCBzdGF0dXMgZmlyc3QgdG8gcHJldmVudCBmbGFzaGluZ1xuICBjb25zdCBjYWNoZWQgPSBnZXRDYWNoZWRBdXRoQ2hlY2soKTtcbiAgaWYgKGNhY2hlZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgXG4gIC8vIFRyeSB0byByZXN0b3JlIHRva2VucyBpZiB0aGV5IHdlcmUgbG9zdCAoZGV2ZWxvcG1lbnQgb25seSlcbiAgcmVzdG9yZVRva2Vuc0lmTmVlZGVkKCk7XG4gIFxuICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKTtcbiAgaWYgKCF0b2tlbikge1xuICAgIGNhY2hlQXV0aENoZWNrKGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIENoZWNrIGlmIHRva2VuIGlzIEFDVFVBTExZIGV4cGlyZWQgKG5vIGJ1ZmZlcilcbiAgLy8gV2Ugb25seSB1c2UgYnVmZmVyIGZvciBwcm9hY3RpdmUgcmVmcmVzaCwgbm90IGZvciBhdXRoIHN0YXR1c1xuICBpZiAoaXNUb2tlbkV4cGlyZWQoMCkpIHtcbiAgICBjYWNoZUF1dGhDaGVjayhmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICBjYWNoZUF1dGhDaGVjayh0cnVlKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkIG9yIGFib3V0IHRvIGV4cGlyZVxuICogVmFsaWRhdGVzIGJvdGggc3RvcmVkIHRpbWVzdGFtcCBhbmQgYWN0dWFsIEpXVCBleHBpcmF0aW9uXG4gKiBEZWZhdWx0IGJ1ZmZlciBpbmNyZWFzZWQgdG8gMTIwIHNlY29uZHMgdG8gYXZvaWQgYWdncmVzc2l2ZSByZWZyZXNoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuRXhwaXJlZChidWZmZXJTZWNvbmRzOiBudW1iZXIgPSAxMjApOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdHJ1ZTtcbiAgXG4gIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpO1xuICBpZiAoIXRva2VuKSByZXR1cm4gdHJ1ZTtcbiAgXG4gIC8vIEZpcnN0IGNoZWNrIEpXVCBleHBpcmF0aW9uIGZyb20gdGhlIHRva2VuIGl0c2VsZiAobW9zdCByZWxpYWJsZSlcbiAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUp3dCh0b2tlbik7XG4gIGlmIChwYXlsb2FkPy5leHApIHtcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IHBheWxvYWQuZXhwICogMTAwMDsgLy8gSldUIGV4cCBpcyBpbiBzZWNvbmRzXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZVdpdGhCdWZmZXIgPSBleHBpcmF0aW9uVGltZSAtIChidWZmZXJTZWNvbmRzICogMTAwMCk7XG4gICAgaWYgKG5vdyA+PSBleHBpcmF0aW9uVGltZVdpdGhCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gc3RvcmVkIHRpbWVzdGFtcFxuICBjb25zdCBleHBpcmVzQXQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW5fZXhwaXJlc19hdCcpO1xuICBpZiAoIWV4cGlyZXNBdCkge1xuICAgIC8vIElmIHdlIGhhdmUgYSB0b2tlbiBidXQgbm8gc3RvcmVkIHRpbWVzdGFtcCwgdmFsaWRhdGUgdGhlIEpXVFxuICAgIHJldHVybiAhaXNWYWxpZEp3dCh0b2tlbik7XG4gIH1cbiAgXG4gIGNvbnN0IGV4cGlyZXNUaW1lc3RhbXAgPSBwYXJzZUludChleHBpcmVzQXQsIDEwKTtcbiAgaWYgKGlzTmFOKGV4cGlyZXNUaW1lc3RhbXApKSB7XG4gICAgcmV0dXJuICFpc1ZhbGlkSnd0KHRva2VuKTtcbiAgfVxuICBcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBleHBpcmVzVGltZXN0YW1wIC0gKGJ1ZmZlclNlY29uZHMgKiAxMDAwKTtcbiAgXG4gIHJldHVybiBub3cgPj0gZXhwaXJhdGlvblRpbWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhY2Nlc3MgdG9rZW4sIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgXG4gIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpO1xuICBpZiAoIXRva2VuKSByZXR1cm4gbnVsbDtcbiAgXG4gIC8vIE9ubHkgcmVmcmVzaCBpZiB0b2tlbiBpcyBhY3R1YWxseSBleHBpcmVkIG9yIHZlcnkgY2xvc2UgdG8gZXhwaXJ5ICgzMCBzZWNvbmRzKVxuICAvLyBUaGlzIHByZXZlbnRzIGFnZ3Jlc3NpdmUgcmVmcmVzaCBhdHRlbXB0c1xuICBpZiAoaXNUb2tlbkV4cGlyZWQoMzApKSB7XG4gICAgY29uc29sZS5sb2coJ1Rva2VuIGV4cGlyZWQgb3IgZXhwaXJpbmcgc29vbiwgYXR0ZW1wdGluZyByZWZyZXNoLi4uJyk7XG4gICAgY29uc3QgcmVmcmVzaGVkID0gYXdhaXQgcmVmcmVzaFRva2VuKCk7XG4gICAgaWYgKHJlZnJlc2hlZCkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKTtcbiAgICB9XG4gICAgLy8gSWYgcmVmcmVzaCBmYWlsZWQgYnV0IHRva2VuIG1pZ2h0IHN0aWxsIGJlIHZhbGlkLCByZXR1cm4gaXRcbiAgICAvLyBMZXQgdGhlIEFQSSBjYWxsIGZhaWwgaWYgdGhlIHRva2VuIGlzIHRydWx5IGludmFsaWRcbiAgICBpZiAoIWlzVG9rZW5FeHBpcmVkKDApKSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gdG9rZW47XG59XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgYWNjZXNzIHRva2VuIHVzaW5nIHRoZSByZWZyZXNoIHRva2VuXG4gKi9cbmxldCByZWZyZXNoaW5nUHJvbWlzZTogUHJvbWlzZTxib29sZWFuPiB8IG51bGwgPSBudWxsO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRva2VuKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIElmIGFscmVhZHkgcmVmcmVzaGluZywgd2FpdCBmb3IgdGhhdCBwcm9taXNlXG4gIGlmIChyZWZyZXNoaW5nUHJvbWlzZSkge1xuICAgIHJldHVybiByZWZyZXNoaW5nUHJvbWlzZTtcbiAgfVxuICBcbiAgLy8gRG91YmxlLWNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHRvIHJlZnJlc2hcbiAgY29uc3QgY3VycmVudFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpO1xuICBpZiAoY3VycmVudFRva2VuICYmICFpc1Rva2VuRXhwaXJlZCgzMCkpIHtcbiAgICAvLyBUb2tlbiBpcyBzdGlsbCB2YWxpZCwgbm8gbmVlZCB0byByZWZyZXNoXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgfVxuICBcbiAgY29uc3QgcmVmcmVzaFRva2VuVmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncmVmcmVzaF90b2tlbicpO1xuICBpZiAoIXJlZnJlc2hUb2tlblZhbHVlKSB7XG4gICAgLy8gTm8gcmVmcmVzaCB0b2tlbiwgbmVlZCB0byByZS1hdXRoZW50aWNhdGVcbiAgICBjbGVhclNlc3Npb24oKTtcbiAgICByZWRpcmVjdFRvTG9naW4oKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHJlZnJlc2hpbmdQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBncmFudF90eXBlOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgIGNsaWVudF9pZDogYXV0aENvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuVmFsdWUsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhdXRoQ29uZmlnLnRva2VuVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxuICAgICAgICBib2R5OiBib2R5LnRvU3RyaW5nKCksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAvLyBMb2cgdGhlIGVycm9yIGRldGFpbHMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkIHdpdGggc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgY2xlYXIgc2Vzc2lvbiBhbmQgcmVkaXJlY3QgaWYgaXQncyBhIDQwMSAodW5hdXRob3JpemVkKSBvciByZWZyZXNoIHRva2VuIGlzIHRydWx5IGludmFsaWRcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICAgICAgcmVkaXJlY3RUb0xvZ2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zdCBhY2Nlc3MgPSB0b2tlbnMuYWNjZXNzX3Rva2VuIGFzIHN0cmluZztcbiAgICAgIGNvbnN0IHJlZnJlc2ggPSB0b2tlbnMucmVmcmVzaF90b2tlbiBhcyBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRva2VucyBiZWZvcmUgc3RvcmluZ1xuICAgICAgaWYgKCFhY2Nlc3MgfHwgIWlzVmFsaWRKd3QoYWNjZXNzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGFjY2VzcyB0b2tlbiByZWNlaXZlZCBmcm9tIHJlZnJlc2gnKTtcbiAgICAgICAgY2xlYXJTZXNzaW9uKCk7XG4gICAgICAgIHJlZGlyZWN0VG9Mb2dpbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0b2tlbnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWNjZXNzX3Rva2VuJywgYWNjZXNzKTtcbiAgICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoX3Rva2VuJywgcmVmcmVzaCk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5zLmlkX3Rva2VuKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdpZF90b2tlbicsIHRva2Vucy5pZF90b2tlbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEJhY2t1cCB0b2tlbnMgaW4gZGV2ZWxvcG1lbnRcbiAgICAgIGJhY2t1cFRva2VucygpO1xuICAgICAgXG4gICAgICAvLyBVc2UgZXhwaXJlc19pbiBmcm9tIHJlc3BvbnNlLCBvciBjYWxjdWxhdGUgZnJvbSBKV1QgZXhwLCBvciBkZWZhdWx0IHRvIDM2MDBcbiAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHRva2Vucy5leHBpcmVzX2luIHx8IChkZWNvZGVKd3QoYWNjZXNzKT8uZXhwID8gdW5kZWZpbmVkIDogMzYwMCk7XG4gICAgICBpZiAoZXhwaXJlc0luKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbl9leHBpcmVzX2F0JywgU3RyaW5nKERhdGUubm93KCkgKyBleHBpcmVzSW4gKiAxMDAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYWxjdWxhdGUgZnJvbSBKV1QgZXhwXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVKd3QoYWNjZXNzKTtcbiAgICAgICAgaWYgKHBheWxvYWQ/LmV4cCkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbl9leHBpcmVzX2F0JywgU3RyaW5nKHBheWxvYWQuZXhwICogMTAwMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b2tlbl9leHBpcmVzX2F0JywgU3RyaW5nKERhdGUubm93KCkgKyAzNjAwICogMTAwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgc3RvcmFnZSBldmVudCB0byBub3RpZnkgb3RoZXIgdGFic1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IFN0b3JhZ2VFdmVudCgnc3RvcmFnZScsIHtcbiAgICAgICAga2V5OiAnYWNjZXNzX3Rva2VuJyxcbiAgICAgICAgbmV3VmFsdWU6IGFjY2VzcyxcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IGltbWVkaWF0ZWx5IGNsZWFyIHNlc3Npb24gLSBuZXR3b3JrIGVycm9ycyBzaG91bGRuJ3QgbG9nIHVzZXIgb3V0XG4gICAgICAvLyBPbmx5IGNsZWFyIGlmIHdlJ3JlIGNlcnRhaW4gdGhlIHJlZnJlc2ggdG9rZW4gaXMgaW52YWxpZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWZyZXNoaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICB9KSgpO1xuICBcbiAgcmV0dXJuIHJlZnJlc2hpbmdQcm9taXNlO1xufVxuXG4vKipcbiAqIENsZWFyIGFsbCBzZXNzaW9uIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU2Vzc2lvbigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NfdG9rZW4nKTtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hfdG9rZW4nKTtcbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2lkX3Rva2VuJyk7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd0b2tlbl9leHBpcmVzX2F0Jyk7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgdG8gbG9naW4gcGFnZVxuICovXG5mdW5jdGlvbiByZWRpcmVjdFRvTG9naW4oKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBcbiAgLy8gRG9uJ3QgcmVkaXJlY3QgaWYgYWxyZWFkeSBvbiBhdXRoIHBhZ2VzXG4gIGlmICh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3RhcnRzV2l0aCgnL2F1dGgvJykpIHJldHVybjtcbiAgXG4gIC8vIERvbid0IHJlZGlyZWN0IGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSByZWZyZXNoXG4gIGlmIChyZWZyZXNoaW5nUHJvbWlzZSkgcmV0dXJuO1xuICBcbiAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbnMgZHVyaW5nIGFwcCBpbml0aWFsaXphdGlvblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBEb3VibGUtY2hlY2sgdGhhdCB3ZSByZWFsbHkgbmVlZCB0byByZWRpcmVjdFxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpO1xuICAgIGlmICh0b2tlbiAmJiAhaXNUb2tlbkV4cGlyZWQoMCkpIHtcbiAgICAgIC8vIFRva2VuIGlzIHN0aWxsIHZhbGlkLCBkb24ndCByZWRpcmVjdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBVc2UgcmVwbGFjZSB0byBhdm9pZCBhZGRpbmcgdG8gaGlzdG9yeVxuICAgIHRyeSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnL2F1dGgvbG9naW4nKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9hdXRoL2xvZ2luJztcbiAgICB9XG4gIH0sIDEwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdXRoVXNlcigpOiBBdXRoVXNlciB7XG4gIGNvbnN0IGFjY2VzcyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc190b2tlbicpIDogbnVsbDtcbiAgY29uc3QgaWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdpZF90b2tlbicpIDogbnVsbDtcbiAgY29uc3QgdG9rZW5QYXlsb2FkID0gYWNjZXNzID8gZGVjb2RlSnd0KGFjY2VzcykgOiBudWxsO1xuICBjb25zdCBpZFBheWxvYWQgPSBpZCA/IGRlY29kZUp3dChpZCkgOiBudWxsO1xuXG4gIGNvbnN0IGZ1bGxOYW1lID0gaWRQYXlsb2FkPy5uYW1lXG4gICAgfHwgW2lkUGF5bG9hZD8uZ2l2ZW5fbmFtZSwgaWRQYXlsb2FkPy5mYW1pbHlfbmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKVxuICAgIHx8IHRva2VuUGF5bG9hZD8ubmFtZVxuICAgIHx8IFt0b2tlblBheWxvYWQ/LmdpdmVuX25hbWUsIHRva2VuUGF5bG9hZD8uZmFtaWx5X25hbWVdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJylcbiAgICB8fCBpZFBheWxvYWQ/LnByZWZlcnJlZF91c2VybmFtZVxuICAgIHx8IHRva2VuUGF5bG9hZD8ucHJlZmVycmVkX3VzZXJuYW1lXG4gICAgfHwgaWRQYXlsb2FkPy5lbWFpbFxuICAgIHx8IHRva2VuUGF5bG9hZD8uZW1haWxcbiAgICB8fCBcIlVzZXJcIjtcblxuICBjb25zdCBlbWFpbCA9IGlkUGF5bG9hZD8uZW1haWwgfHwgdG9rZW5QYXlsb2FkPy5lbWFpbDtcbiAgY29uc3Qgc3ViID0gaWRQYXlsb2FkPy5zdWIgfHwgdG9rZW5QYXlsb2FkPy5zdWI7XG5cbiAgcmV0dXJuIHtcbiAgICBzdWIsXG4gICAgbmFtZTogZnVsbE5hbWUsXG4gICAgZW1haWwsXG4gICAgZ2l2ZW5OYW1lOiBpZFBheWxvYWQ/LmdpdmVuX25hbWUgfHwgdG9rZW5QYXlsb2FkPy5naXZlbl9uYW1lLFxuICAgIGZhbWlseU5hbWU6IGlkUGF5bG9hZD8uZmFtaWx5X25hbWUgfHwgdG9rZW5QYXlsb2FkPy5mYW1pbHlfbmFtZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9nb3V0VXJsKHBvc3RMb2dvdXRSZWRpcmVjdFVyaTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgYmFzZSA9IGF1dGhDb25maWcuYXV0aFVybC5yZXBsYWNlKCcvYXV0aCcsICcvbG9nb3V0Jyk7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZSk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjbGllbnRfaWQnLCBhdXRoQ29uZmlnLmNsaWVudElkKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaScsIHBvc3RMb2dvdXRSZWRpcmVjdFVyaSk7XG4gIGNvbnN0IGlkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaWRfdG9rZW4nKSA6IG51bGw7XG4gIGlmIChpZCkgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2lkX3Rva2VuX2hpbnQnLCBpZCk7XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ291dChwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IHN0cmluZyA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvJykge1xuICB0cnkge1xuICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgIGNvbnN0IGxvZ291dFVybCA9IGJ1aWxkTG9nb3V0VXJsKHBvc3RMb2dvdXRSZWRpcmVjdFVyaSk7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBsb2dvdXRVcmw7XG4gIH0gY2F0Y2gge1xuICAgIGNsZWFyU2Vzc2lvbigpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcG9zdExvZ291dFJlZGlyZWN0VXJpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFscyhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdLnNsaWNlKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAocGFydHNbMF1bMF0gKyBwYXJ0c1sxXVswXSkudG9VcHBlckNhc2UoKTtcbn1cblxuXG4iXSwibmFtZXMiOlsiZGVjb2RlSnd0IiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwicGF5bG9hZCIsImpzb24iLCJhdG9iIiwicmVwbGFjZSIsIkpTT04iLCJwYXJzZSIsImlzVmFsaWRKd3QiLCJleHAiLCJleHBpcmF0aW9uVGltZSIsIm5vdyIsIkRhdGUiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjYWNoZWQiLCJnZXRDYWNoZWRBdXRoQ2hlY2siLCJyZXN0b3JlVG9rZW5zSWZOZWVkZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY2FjaGVBdXRoQ2hlY2siLCJpc1Rva2VuRXhwaXJlZCIsImJ1ZmZlclNlY29uZHMiLCJleHBpcmF0aW9uVGltZVdpdGhCdWZmZXIiLCJleHBpcmVzQXQiLCJleHBpcmVzVGltZXN0YW1wIiwicGFyc2VJbnQiLCJpc05hTiIsImdldEFjY2Vzc1Rva2VuIiwiY29uc29sZSIsImxvZyIsInJlZnJlc2hlZCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hpbmdQcm9taXNlIiwiY3VycmVudFRva2VuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWZyZXNoVG9rZW5WYWx1ZSIsImNsZWFyU2Vzc2lvbiIsInJlZGlyZWN0VG9Mb2dpbiIsImJvZHkiLCJVUkxTZWFyY2hQYXJhbXMiLCJncmFudF90eXBlIiwiY2xpZW50X2lkIiwiYXV0aENvbmZpZyIsImNsaWVudElkIiwicmVmcmVzaF90b2tlbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJ0b2tlblVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJ0b1N0cmluZyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwic3RhdHVzIiwidG9rZW5zIiwiYWNjZXNzIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaCIsInNldEl0ZW0iLCJpZF90b2tlbiIsImJhY2t1cFRva2VucyIsImV4cGlyZXNJbiIsImV4cGlyZXNfaW4iLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiU3RvcmFnZUV2ZW50Iiwia2V5IiwibmV3VmFsdWUiLCJyZW1vdmVJdGVtIiwibG9jYXRpb24iLCJwYXRobmFtZSIsInN0YXJ0c1dpdGgiLCJzZXRUaW1lb3V0IiwiaHJlZiIsImdldEF1dGhVc2VyIiwiaWQiLCJ0b2tlblBheWxvYWQiLCJpZFBheWxvYWQiLCJmdWxsTmFtZSIsIm5hbWUiLCJnaXZlbl9uYW1lIiwiZmFtaWx5X25hbWUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsInByZWZlcnJlZF91c2VybmFtZSIsImVtYWlsIiwic3ViIiwiZ2l2ZW5OYW1lIiwiZmFtaWx5TmFtZSIsImJ1aWxkTG9nb3V0VXJsIiwicG9zdExvZ291dFJlZGlyZWN0VXJpIiwiYmFzZSIsImF1dGhVcmwiLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJsb2dvdXQiLCJsb2dvdXRVcmwiLCJnZXRJbml0aWFscyIsInRyaW0iLCJzbGljZSIsInRvVXBwZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/auth/session.ts\n"));

/***/ })

});