"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/partner/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/auth/session.ts":
/*!*********************************!*\
  !*** ./src/lib/auth/session.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildLogoutUrl: function() { return /* binding */ buildLogoutUrl; },\n/* harmony export */   clearSession: function() { return /* binding */ clearSession; },\n/* harmony export */   getAccessToken: function() { return /* binding */ getAccessToken; },\n/* harmony export */   getAuthUser: function() { return /* binding */ getAuthUser; },\n/* harmony export */   getInitials: function() { return /* binding */ getInitials; },\n/* harmony export */   isAuthenticated: function() { return /* binding */ isAuthenticated; },\n/* harmony export */   isTokenExpired: function() { return /* binding */ isTokenExpired; },\n/* harmony export */   logout: function() { return /* binding */ logout; },\n/* harmony export */   refreshToken: function() { return /* binding */ refreshToken; }\n/* harmony export */ });\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// SECURITY: Tokens are now stored server-side in Redis via NextAuth\n// This file provides compatibility functions that use NextAuth session instead of localStorage\n// All token access is handled server-side by the API proxy\n\n/**\n * Check if user is authenticated using NextAuth session\n * Note: This is a synchronous check that may not be accurate during initial load\n * For accurate checks, use useSession() hook in React components\n */ function isAuthenticated() {\n    if (false) {}\n    // Check if session cookie exists (basic check)\n    // For accurate authentication status, use useSession() hook\n    const cookies = document.cookie.split(\";\");\n    const hasSessionCookie = cookies.some((cookie)=>cookie.trim().startsWith(\"next-auth.session-token=\") || cookie.trim().startsWith(\"__Secure-next-auth.session-token=\"));\n    return hasSessionCookie;\n}\n/**\n * SECURITY: Tokens are stored server-side in Redis\n * This function returns null - tokens should never be accessed from the frontend\n * The API proxy automatically injects tokens from Redis based on the session cookie\n */ async function getAccessToken() {\n    // SECURITY: Do not return tokens from frontend\n    // Tokens are stored server-side in Redis and injected by the proxy\n    console.warn(\"[SECURITY] getAccessToken() called - tokens are server-side only. Use API proxy instead.\");\n    return null;\n}\n/**\n * SECURITY: Token refresh is handled server-side by NextAuth\n * This function is deprecated - NextAuth handles token refresh automatically\n */ async function refreshToken() {\n    // Token refresh is handled server-side by NextAuth\n    // No action needed from frontend\n    console.warn(\"[SECURITY] refreshToken() called - token refresh is handled server-side by NextAuth\");\n    return false;\n}\n/**\n * Get authenticated user from NextAuth session\n * Note: This is a synchronous function that may not have accurate data during initial load\n * For accurate user data in React components, use useSession() hook from next-auth/react\n * or useAuth() hook from AuthContext\n */ function getAuthUser() {\n    if (false) {}\n    // Try to get user from NextAuth session via fetch (async but we return sync fallback)\n    // For accurate data, components should use useSession() hook\n    try {\n        // Check if session cookie exists\n        const cookies = document.cookie.split(\";\");\n        const hasSessionCookie = cookies.some((cookie)=>cookie.trim().startsWith(\"next-auth.session-token=\") || cookie.trim().startsWith(\"__Secure-next-auth.session-token=\"));\n        if (!hasSessionCookie) {\n            return {\n                name: \"User\"\n            };\n        }\n        // Try to get cached session data from sessionStorage (if available)\n        // This is a fallback - components should use useSession() hook\n        const sessionData = sessionStorage.getItem(\"nextauth.session.user\");\n        if (sessionData) {\n            try {\n                const user = JSON.parse(sessionData);\n                return {\n                    sub: user.id || user.email,\n                    name: user.name || user.email || \"User\",\n                    email: user.email\n                };\n            } catch (e) {\n            // Invalid session data\n            }\n        }\n    } catch (e) {\n    // Session storage not available or error\n    }\n    // Fallback: return default user\n    // Components should use useSession() hook or useAuth() for accurate data\n    return {\n        name: \"User\"\n    };\n}\n/**\n * Clear session and sign out using NextAuth\n */ function clearSession() {\n    if (false) {}\n    // Clear any legacy localStorage tokens (shouldn't exist, but clean up just in case)\n    localStorage.removeItem(\"access_token\");\n    localStorage.removeItem(\"refresh_token\");\n    localStorage.removeItem(\"id_token\");\n    localStorage.removeItem(\"token_expires_at\");\n    // Clear session storage\n    sessionStorage.removeItem(\"nextauth.session.user\");\n    // Sign out using NextAuth (this will clear the session cookie)\n    (0,next_auth_react__WEBPACK_IMPORTED_MODULE_0__.signOut)({\n        callbackUrl: \"/auth/login\"\n    });\n}\n/**\n * Redirect to login page\n */ function redirectToLogin() {\n    if (false) {}\n    // Don't redirect if already on auth pages\n    if (window.location.pathname.startsWith(\"/auth/\")) return;\n    // Use replace to avoid adding to history\n    try {\n        window.location.replace(\"/auth/login\");\n    } catch (e) {\n        window.location.href = \"/auth/login\";\n    }\n}\n/**\n * Build logout URL for Keycloak\n * Note: NextAuth handles logout, but this is kept for compatibility\n */ function buildLogoutUrl(postLogoutRedirectUri) {\n    // NextAuth handles logout, but if needed for Keycloak direct logout:\n    const keycloakIssuer = process.env.NEXT_PUBLIC_KEYCLOAK_ISSUER || \"https://keycloak-staging.app-stg.mukuru.io/realms/mukuru\";\n    const base = \"\".concat(keycloakIssuer, \"/protocol/openid-connect/logout\");\n    const url = new URL(base);\n    url.searchParams.set(\"post_logout_redirect_uri\", postLogoutRedirectUri);\n    return url.toString();\n}\n/**\n * Logout user using NextAuth\n */ function logout() {\n    let postLogoutRedirectUri = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"/auth/login\";\n    // Use NextAuth signOut which handles session cleanup\n    (0,next_auth_react__WEBPACK_IMPORTED_MODULE_0__.signOut)({\n        callbackUrl: postLogoutRedirectUri\n    });\n}\n/**\n * Get user initials from name\n */ function getInitials(name) {\n    const parts = name.trim().split(/\\s+/).filter(Boolean);\n    if (parts.length === 0) return \"\";\n    if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();\n    return (parts[0][0] + parts[1][0]).toUpperCase();\n}\n/**\n * DEPRECATED: Token expiration check is handled server-side\n * This function is kept for compatibility but always returns false\n */ function isTokenExpired() {\n    let bufferSeconds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 120;\n    // Token expiration is handled server-side by NextAuth\n    // This function is deprecated\n    console.warn(\"[DEPRECATED] isTokenExpired() - token expiration is handled server-side\");\n    return false;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXV0aC9zZXNzaW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRTtBQUNwRSwrRkFBK0Y7QUFDL0YsMkRBQTJEO0FBRWpCO0FBVTFDOzs7O0NBSUMsR0FDTSxTQUFTQztJQUNkLElBQUksS0FBa0IsRUFBYSxFQUFhO0lBRWhELCtDQUErQztJQUMvQyw0REFBNEQ7SUFDNUQsTUFBTUMsVUFBVUMsU0FBU0MsTUFBTSxDQUFDQyxLQUFLLENBQUM7SUFDdEMsTUFBTUMsbUJBQW1CSixRQUFRSyxJQUFJLENBQUNILENBQUFBLFNBQ3BDQSxPQUFPSSxJQUFJLEdBQUdDLFVBQVUsQ0FBQywrQkFDekJMLE9BQU9JLElBQUksR0FBR0MsVUFBVSxDQUFDO0lBRzNCLE9BQU9IO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ00sZUFBZUk7SUFDcEIsK0NBQStDO0lBQy9DLG1FQUFtRTtJQUNuRUMsUUFBUUMsSUFBSSxDQUFDO0lBQ2IsT0FBTztBQUNUO0FBRUE7OztDQUdDLEdBQ00sZUFBZUM7SUFDcEIsbURBQW1EO0lBQ25ELGlDQUFpQztJQUNqQ0YsUUFBUUMsSUFBSSxDQUFDO0lBQ2IsT0FBTztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTRTtJQUNkLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUVELHNGQUFzRjtJQUN0Riw2REFBNkQ7SUFDN0QsSUFBSTtRQUNGLGlDQUFpQztRQUNqQyxNQUFNWixVQUFVQyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQztRQUN0QyxNQUFNQyxtQkFBbUJKLFFBQVFLLElBQUksQ0FBQ0gsQ0FBQUEsU0FDcENBLE9BQU9JLElBQUksR0FBR0MsVUFBVSxDQUFDLCtCQUN6QkwsT0FBT0ksSUFBSSxHQUFHQyxVQUFVLENBQUM7UUFHM0IsSUFBSSxDQUFDSCxrQkFBa0I7WUFDckIsT0FBTztnQkFBRVMsTUFBTTtZQUFPO1FBQ3hCO1FBRUEsb0VBQW9FO1FBQ3BFLCtEQUErRDtRQUMvRCxNQUFNQyxjQUFjQyxlQUFlQyxPQUFPLENBQUM7UUFDM0MsSUFBSUYsYUFBYTtZQUNmLElBQUk7Z0JBQ0YsTUFBTUcsT0FBT0MsS0FBS0MsS0FBSyxDQUFDTDtnQkFDeEIsT0FBTztvQkFDTE0sS0FBS0gsS0FBS0ksRUFBRSxJQUFJSixLQUFLSyxLQUFLO29CQUMxQlQsTUFBTUksS0FBS0osSUFBSSxJQUFJSSxLQUFLSyxLQUFLLElBQUk7b0JBQ2pDQSxPQUFPTCxLQUFLSyxLQUFLO2dCQUNuQjtZQUNGLEVBQUUsVUFBTTtZQUNOLHVCQUF1QjtZQUN6QjtRQUNGO0lBQ0YsRUFBRSxVQUFNO0lBQ04seUNBQXlDO0lBQzNDO0lBRUEsZ0NBQWdDO0lBQ2hDLHlFQUF5RTtJQUN6RSxPQUFPO1FBQ0xULE1BQU07SUFDUjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTVTtJQUNkLElBQUksS0FBa0IsRUFBYSxFQUFPO0lBRTFDLG9GQUFvRjtJQUNwRkMsYUFBYUMsVUFBVSxDQUFDO0lBQ3hCRCxhQUFhQyxVQUFVLENBQUM7SUFDeEJELGFBQWFDLFVBQVUsQ0FBQztJQUN4QkQsYUFBYUMsVUFBVSxDQUFDO0lBRXhCLHdCQUF3QjtJQUN4QlYsZUFBZVUsVUFBVSxDQUFDO0lBRTFCLCtEQUErRDtJQUMvRDNCLHdEQUFPQSxDQUFDO1FBQUU0QixhQUFhO0lBQWM7QUFDdkM7QUFFQTs7Q0FFQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxLQUFrQixFQUFhLEVBQU87SUFFMUMsMENBQTBDO0lBQzFDLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDdkIsVUFBVSxDQUFDLFdBQVc7SUFFbkQseUNBQXlDO0lBQ3pDLElBQUk7UUFDRnFCLE9BQU9DLFFBQVEsQ0FBQ0UsT0FBTyxDQUFDO0lBQzFCLEVBQUUsVUFBTTtRQUNOSCxPQUFPQyxRQUFRLENBQUNHLElBQUksR0FBRztJQUN6QjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0MsZUFBZUMscUJBQTZCO0lBQzFELHFFQUFxRTtJQUNyRSxNQUFNQyxpQkFBaUJDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMkJBQTJCLElBQUk7SUFDbEUsTUFBTUMsT0FBTyxHQUFrQixPQUFmSixnQkFBZTtJQUMvQixNQUFNSyxNQUFNLElBQUlDLElBQUlGO0lBQ3BCQyxJQUFJRSxZQUFZLENBQUNDLEdBQUcsQ0FBQyw0QkFBNEJUO0lBQ2pELE9BQU9NLElBQUlJLFFBQVE7QUFDckI7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDO1FBQU9YLHdCQUFBQSxpRUFBZ0M7SUFDckQscURBQXFEO0lBQ3JEcEMsd0RBQU9BLENBQUM7UUFBRTRCLGFBQWFRO0lBQXNCO0FBQy9DO0FBRUE7O0NBRUMsR0FDTSxTQUFTWSxZQUFZakMsSUFBWTtJQUN0QyxNQUFNa0MsUUFBUWxDLEtBQUtQLElBQUksR0FBR0gsS0FBSyxDQUFDLE9BQU82QyxNQUFNLENBQUNDO0lBQzlDLElBQUlGLE1BQU1HLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFDL0IsSUFBSUgsTUFBTUcsTUFBTSxLQUFLLEdBQUcsT0FBT0gsS0FBSyxDQUFDLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDLEdBQUcsR0FBR0MsV0FBVztJQUMvRCxPQUFPLENBQUNMLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRUssV0FBVztBQUNoRDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO1FBQWVDLGdCQUFBQSxpRUFBd0I7SUFDckQsc0RBQXNEO0lBQ3RELDhCQUE4QjtJQUM5QjdDLFFBQVFDLElBQUksQ0FBQztJQUNiLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2F1dGgvc2Vzc2lvbi50cz81ODg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNFQ1VSSVRZOiBUb2tlbnMgYXJlIG5vdyBzdG9yZWQgc2VydmVyLXNpZGUgaW4gUmVkaXMgdmlhIE5leHRBdXRoXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgY29tcGF0aWJpbGl0eSBmdW5jdGlvbnMgdGhhdCB1c2UgTmV4dEF1dGggc2Vzc2lvbiBpbnN0ZWFkIG9mIGxvY2FsU3RvcmFnZVxuLy8gQWxsIHRva2VuIGFjY2VzcyBpcyBoYW5kbGVkIHNlcnZlci1zaWRlIGJ5IHRoZSBBUEkgcHJveHlcblxuaW1wb3J0IHsgc2lnbk91dCB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgQXV0aFVzZXIgPSB7XG4gIHN1Yj86IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbD86IHN0cmluZztcbiAgZ2l2ZW5OYW1lPzogc3RyaW5nO1xuICBmYW1pbHlOYW1lPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQgdXNpbmcgTmV4dEF1dGggc2Vzc2lvblxuICogTm90ZTogVGhpcyBpcyBhIHN5bmNocm9ub3VzIGNoZWNrIHRoYXQgbWF5IG5vdCBiZSBhY2N1cmF0ZSBkdXJpbmcgaW5pdGlhbCBsb2FkXG4gKiBGb3IgYWNjdXJhdGUgY2hlY2tzLCB1c2UgdXNlU2Vzc2lvbigpIGhvb2sgaW4gUmVhY3QgY29tcG9uZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIENoZWNrIGlmIHNlc3Npb24gY29va2llIGV4aXN0cyAoYmFzaWMgY2hlY2spXG4gIC8vIEZvciBhY2N1cmF0ZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMsIHVzZSB1c2VTZXNzaW9uKCkgaG9va1xuICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gIGNvbnN0IGhhc1Nlc3Npb25Db29raWUgPSBjb29raWVzLnNvbWUoY29va2llID0+IFxuICAgIGNvb2tpZS50cmltKCkuc3RhcnRzV2l0aCgnbmV4dC1hdXRoLnNlc3Npb24tdG9rZW49JykgfHwgXG4gICAgY29va2llLnRyaW0oKS5zdGFydHNXaXRoKCdfX1NlY3VyZS1uZXh0LWF1dGguc2Vzc2lvbi10b2tlbj0nKVxuICApO1xuICBcbiAgcmV0dXJuIGhhc1Nlc3Npb25Db29raWU7XG59XG5cbi8qKlxuICogU0VDVVJJVFk6IFRva2VucyBhcmUgc3RvcmVkIHNlcnZlci1zaWRlIGluIFJlZGlzXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbnVsbCAtIHRva2VucyBzaG91bGQgbmV2ZXIgYmUgYWNjZXNzZWQgZnJvbSB0aGUgZnJvbnRlbmRcbiAqIFRoZSBBUEkgcHJveHkgYXV0b21hdGljYWxseSBpbmplY3RzIHRva2VucyBmcm9tIFJlZGlzIGJhc2VkIG9uIHRoZSBzZXNzaW9uIGNvb2tpZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWNjZXNzVG9rZW4oKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIC8vIFNFQ1VSSVRZOiBEbyBub3QgcmV0dXJuIHRva2VucyBmcm9tIGZyb250ZW5kXG4gIC8vIFRva2VucyBhcmUgc3RvcmVkIHNlcnZlci1zaWRlIGluIFJlZGlzIGFuZCBpbmplY3RlZCBieSB0aGUgcHJveHlcbiAgY29uc29sZS53YXJuKCdbU0VDVVJJVFldIGdldEFjY2Vzc1Rva2VuKCkgY2FsbGVkIC0gdG9rZW5zIGFyZSBzZXJ2ZXItc2lkZSBvbmx5LiBVc2UgQVBJIHByb3h5IGluc3RlYWQuJyk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFNFQ1VSSVRZOiBUb2tlbiByZWZyZXNoIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUgYnkgTmV4dEF1dGhcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCAtIE5leHRBdXRoIGhhbmRsZXMgdG9rZW4gcmVmcmVzaCBhdXRvbWF0aWNhbGx5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW4oKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIC8vIFRva2VuIHJlZnJlc2ggaXMgaGFuZGxlZCBzZXJ2ZXItc2lkZSBieSBOZXh0QXV0aFxuICAvLyBObyBhY3Rpb24gbmVlZGVkIGZyb20gZnJvbnRlbmRcbiAgY29uc29sZS53YXJuKCdbU0VDVVJJVFldIHJlZnJlc2hUb2tlbigpIGNhbGxlZCAtIHRva2VuIHJlZnJlc2ggaXMgaGFuZGxlZCBzZXJ2ZXItc2lkZSBieSBOZXh0QXV0aCcpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2V0IGF1dGhlbnRpY2F0ZWQgdXNlciBmcm9tIE5leHRBdXRoIHNlc3Npb25cbiAqIE5vdGU6IFRoaXMgaXMgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IG1heSBub3QgaGF2ZSBhY2N1cmF0ZSBkYXRhIGR1cmluZyBpbml0aWFsIGxvYWRcbiAqIEZvciBhY2N1cmF0ZSB1c2VyIGRhdGEgaW4gUmVhY3QgY29tcG9uZW50cywgdXNlIHVzZVNlc3Npb24oKSBob29rIGZyb20gbmV4dC1hdXRoL3JlYWN0XG4gKiBvciB1c2VBdXRoKCkgaG9vayBmcm9tIEF1dGhDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdXRoVXNlcigpOiBBdXRoVXNlciB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7IG5hbWU6ICdVc2VyJyB9O1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB1c2VyIGZyb20gTmV4dEF1dGggc2Vzc2lvbiB2aWEgZmV0Y2ggKGFzeW5jIGJ1dCB3ZSByZXR1cm4gc3luYyBmYWxsYmFjaylcbiAgLy8gRm9yIGFjY3VyYXRlIGRhdGEsIGNvbXBvbmVudHMgc2hvdWxkIHVzZSB1c2VTZXNzaW9uKCkgaG9va1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHNlc3Npb24gY29va2llIGV4aXN0c1xuICAgIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICBjb25zdCBoYXNTZXNzaW9uQ29va2llID0gY29va2llcy5zb21lKGNvb2tpZSA9PiBcbiAgICAgIGNvb2tpZS50cmltKCkuc3RhcnRzV2l0aCgnbmV4dC1hdXRoLnNlc3Npb24tdG9rZW49JykgfHwgXG4gICAgICBjb29raWUudHJpbSgpLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLW5leHQtYXV0aC5zZXNzaW9uLXRva2VuPScpXG4gICAgKTtcbiAgICBcbiAgICBpZiAoIWhhc1Nlc3Npb25Db29raWUpIHtcbiAgICAgIHJldHVybiB7IG5hbWU6ICdVc2VyJyB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gZ2V0IGNhY2hlZCBzZXNzaW9uIGRhdGEgZnJvbSBzZXNzaW9uU3RvcmFnZSAoaWYgYXZhaWxhYmxlKVxuICAgIC8vIFRoaXMgaXMgYSBmYWxsYmFjayAtIGNvbXBvbmVudHMgc2hvdWxkIHVzZSB1c2VTZXNzaW9uKCkgaG9va1xuICAgIGNvbnN0IHNlc3Npb25EYXRhID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnbmV4dGF1dGguc2Vzc2lvbi51c2VyJyk7XG4gICAgaWYgKHNlc3Npb25EYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1c2VyID0gSlNPTi5wYXJzZShzZXNzaW9uRGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3ViOiB1c2VyLmlkIHx8IHVzZXIuZW1haWwsXG4gICAgICAgICAgbmFtZTogdXNlci5uYW1lIHx8IHVzZXIuZW1haWwgfHwgJ1VzZXInLFxuICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIEludmFsaWQgc2Vzc2lvbiBkYXRhXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBTZXNzaW9uIHN0b3JhZ2Ugbm90IGF2YWlsYWJsZSBvciBlcnJvclxuICB9XG5cbiAgLy8gRmFsbGJhY2s6IHJldHVybiBkZWZhdWx0IHVzZXJcbiAgLy8gQ29tcG9uZW50cyBzaG91bGQgdXNlIHVzZVNlc3Npb24oKSBob29rIG9yIHVzZUF1dGgoKSBmb3IgYWNjdXJhdGUgZGF0YVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdVc2VyJyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDbGVhciBzZXNzaW9uIGFuZCBzaWduIG91dCB1c2luZyBOZXh0QXV0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTZXNzaW9uKCk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgXG4gIC8vIENsZWFyIGFueSBsZWdhY3kgbG9jYWxTdG9yYWdlIHRva2VucyAoc2hvdWxkbid0IGV4aXN0LCBidXQgY2xlYW4gdXAganVzdCBpbiBjYXNlKVxuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWNjZXNzX3Rva2VuJyk7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoX3Rva2VuJyk7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdpZF90b2tlbicpO1xuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndG9rZW5fZXhwaXJlc19hdCcpO1xuICBcbiAgLy8gQ2xlYXIgc2Vzc2lvbiBzdG9yYWdlXG4gIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ25leHRhdXRoLnNlc3Npb24udXNlcicpO1xuICBcbiAgLy8gU2lnbiBvdXQgdXNpbmcgTmV4dEF1dGggKHRoaXMgd2lsbCBjbGVhciB0aGUgc2Vzc2lvbiBjb29raWUpXG4gIHNpZ25PdXQoeyBjYWxsYmFja1VybDogJy9hdXRoL2xvZ2luJyB9KTtcbn1cblxuLyoqXG4gKiBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXG4gKi9cbmZ1bmN0aW9uIHJlZGlyZWN0VG9Mb2dpbigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gIFxuICAvLyBEb24ndCByZWRpcmVjdCBpZiBhbHJlYWR5IG9uIGF1dGggcGFnZXNcbiAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zdGFydHNXaXRoKCcvYXV0aC8nKSkgcmV0dXJuO1xuICBcbiAgLy8gVXNlIHJlcGxhY2UgdG8gYXZvaWQgYWRkaW5nIHRvIGhpc3RvcnlcbiAgdHJ5IHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnL2F1dGgvbG9naW4nKTtcbiAgfSBjYXRjaCB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnL2F1dGgvbG9naW4nO1xuICB9XG59XG5cbi8qKlxuICogQnVpbGQgbG9nb3V0IFVSTCBmb3IgS2V5Y2xvYWtcbiAqIE5vdGU6IE5leHRBdXRoIGhhbmRsZXMgbG9nb3V0LCBidXQgdGhpcyBpcyBrZXB0IGZvciBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExvZ291dFVybChwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIE5leHRBdXRoIGhhbmRsZXMgbG9nb3V0LCBidXQgaWYgbmVlZGVkIGZvciBLZXljbG9hayBkaXJlY3QgbG9nb3V0OlxuICBjb25zdCBrZXljbG9ha0lzc3VlciA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0tFWUNMT0FLX0lTU1VFUiB8fCAnaHR0cHM6Ly9rZXljbG9hay1zdGFnaW5nLmFwcC1zdGcubXVrdXJ1LmlvL3JlYWxtcy9tdWt1cnUnO1xuICBjb25zdCBiYXNlID0gYCR7a2V5Y2xvYWtJc3N1ZXJ9L3Byb3RvY29sL29wZW5pZC1jb25uZWN0L2xvZ291dGA7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZSk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwb3N0X2xvZ291dF9yZWRpcmVjdF91cmknLCBwb3N0TG9nb3V0UmVkaXJlY3RVcmkpO1xuICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogTG9nb3V0IHVzZXIgdXNpbmcgTmV4dEF1dGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvZ291dChwb3N0TG9nb3V0UmVkaXJlY3RVcmk6IHN0cmluZyA9ICcvYXV0aC9sb2dpbicpIHtcbiAgLy8gVXNlIE5leHRBdXRoIHNpZ25PdXQgd2hpY2ggaGFuZGxlcyBzZXNzaW9uIGNsZWFudXBcbiAgc2lnbk91dCh7IGNhbGxiYWNrVXJsOiBwb3N0TG9nb3V0UmVkaXJlY3RVcmkgfSk7XG59XG5cbi8qKlxuICogR2V0IHVzZXIgaW5pdGlhbHMgZnJvbSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFscyhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdLnNsaWNlKDAsIDIpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiAocGFydHNbMF1bMF0gKyBwYXJ0c1sxXVswXSkudG9VcHBlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBERVBSRUNBVEVEOiBUb2tlbiBleHBpcmF0aW9uIGNoZWNrIGlzIGhhbmRsZWQgc2VydmVyLXNpZGVcbiAqIFRoaXMgZnVuY3Rpb24gaXMga2VwdCBmb3IgY29tcGF0aWJpbGl0eSBidXQgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5FeHBpcmVkKGJ1ZmZlclNlY29uZHM6IG51bWJlciA9IDEyMCk6IGJvb2xlYW4ge1xuICAvLyBUb2tlbiBleHBpcmF0aW9uIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUgYnkgTmV4dEF1dGhcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkXG4gIGNvbnNvbGUud2FybignW0RFUFJFQ0FURURdIGlzVG9rZW5FeHBpcmVkKCkgLSB0b2tlbiBleHBpcmF0aW9uIGlzIGhhbmRsZWQgc2VydmVyLXNpZGUnKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbInNpZ25PdXQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjb29raWVzIiwiZG9jdW1lbnQiLCJjb29raWUiLCJzcGxpdCIsImhhc1Nlc3Npb25Db29raWUiLCJzb21lIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJnZXRBY2Nlc3NUb2tlbiIsImNvbnNvbGUiLCJ3YXJuIiwicmVmcmVzaFRva2VuIiwiZ2V0QXV0aFVzZXIiLCJuYW1lIiwic2Vzc2lvbkRhdGEiLCJzZXNzaW9uU3RvcmFnZSIsImdldEl0ZW0iLCJ1c2VyIiwiSlNPTiIsInBhcnNlIiwic3ViIiwiaWQiLCJlbWFpbCIsImNsZWFyU2Vzc2lvbiIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJjYWxsYmFja1VybCIsInJlZGlyZWN0VG9Mb2dpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiaHJlZiIsImJ1aWxkTG9nb3V0VXJsIiwicG9zdExvZ291dFJlZGlyZWN0VXJpIiwia2V5Y2xvYWtJc3N1ZXIiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfS0VZQ0xPQUtfSVNTVUVSIiwiYmFzZSIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwibG9nb3V0IiwiZ2V0SW5pdGlhbHMiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJzbGljZSIsInRvVXBwZXJDYXNlIiwiaXNUb2tlbkV4cGlyZWQiLCJidWZmZXJTZWNvbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/auth/session.ts\n"));

/***/ })

});