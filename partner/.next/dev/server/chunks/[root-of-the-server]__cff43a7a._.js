module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/assert [external] (assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}),
"[externals]/querystring [external] (querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/node:timers/promises [external] (node:timers/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:timers/promises", () => require("node:timers/promises"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/dns/promises [external] (dns/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns/promises", () => require("dns/promises"));

module.exports = mod;
}),
"[externals]/node:assert [external] (node:assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:assert", () => require("node:assert"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[project]/src/lib/redis-session.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteTokenSession",
    ()=>deleteTokenSession,
    "getRedisClient",
    ()=>getRedisClient,
    "getTokenSession",
    ()=>getTokenSession,
    "storeTokenSession",
    ()=>storeTokenSession,
    "updateAccessToken",
    ()=>updateAccessToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redis$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redis/dist/index.js [app-route] (ecmascript)");
;
// Redis client singleton
let redisClient = null;
async function getRedisClient() {
    if (redisClient && redisClient.isOpen) {
        return redisClient;
    }
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    redisClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redis$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])({
        url: redisUrl
    });
    redisClient.on('error', (err)=>console.error('Redis Client Error', err));
    redisClient.on('connect', ()=>console.log('Redis Client Connected'));
    if (!redisClient.isOpen) {
        await redisClient.connect();
    }
    return redisClient;
}
const SESSION_PREFIX = 'session:';
const TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days
async function storeTokenSession(sessionId, tokens) {
    try {
        const client = await getRedisClient();
        const key = `${SESSION_PREFIX}${sessionId}`;
        await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));
        console.log(`[Redis] Stored token session: ${key}`);
    } catch (error) {
        console.error('[Redis] Failed to store token session:', error);
        throw error; // Re-throw so caller knows it failed
    }
}
async function getTokenSession(sessionId) {
    try {
        const client = await getRedisClient();
        const key = `${SESSION_PREFIX}${sessionId}`;
        const data = await client.get(key);
        if (!data) return null;
        return JSON.parse(data);
    } catch (error) {
        console.error('[Redis] Failed to get token session:', error);
        return null; // Return null instead of throwing
    }
}
async function deleteTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.del(key);
}
async function updateAccessToken(sessionId, accessToken, accessTokenExpiryTime) {
    const session = await getTokenSession(sessionId);
    if (!session) {
        throw new Error('Session not found');
    }
    await storeTokenSession(sessionId, {
        ...session,
        accessToken,
        accessTokenExpiryTime
    });
}
}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "authOptions",
    ()=>authOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$keycloak$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/keycloak.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-session.ts [app-route] (ecmascript)");
;
;
// Helper function to refresh tokens
const refreshAccessToken = async (token, sessionId)=>{
    try {
        // Get refresh token from Redis if sessionId provided
        let refreshToken = token.refreshToken;
        if (sessionId) {
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTokenSession"])(sessionId);
            if (session) {
                refreshToken = session.refreshToken;
            }
        }
        if (!refreshToken) {
            throw new Error('No refresh token available');
        }
        const tokenUrl = process.env.KEYCLOAK_TOKEN_URL || 'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru/protocol/openid-connect/token';
        const response = await fetch(tokenUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
                client_id: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
                client_secret: process.env.KEYCLOAK_CLIENT_SECRET || ''
            })
        });
        const refreshedTokens = await response.json();
        if (!response.ok) {
            throw refreshedTokens;
        }
        const newAccessToken = refreshedTokens.access_token;
        const newRefreshToken = refreshedTokens.refresh_token ?? refreshToken;
        const newExpiryTime = Date.now() + refreshedTokens.expires_in * 1000;
        // Update Redis if sessionId provided
        if (sessionId) {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateAccessToken"])(sessionId, newAccessToken, newExpiryTime);
            if (newRefreshToken !== refreshToken) {
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTokenSession"])(sessionId);
                if (session) {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storeTokenSession"])(sessionId, {
                        ...session,
                        refreshToken: newRefreshToken,
                        accessToken: newAccessToken,
                        accessTokenExpiryTime: newExpiryTime
                    });
                }
            }
        }
        return {
            ...token,
            accessToken: newAccessToken,
            accessTokenExpiryTime: newExpiryTime,
            refreshToken: newRefreshToken
        };
    } catch (error) {
        console.error('Error refreshing access token', error);
        return {
            ...token,
            error: 'RefreshAccessTokenError'
        };
    }
};
// Log configuration on startup for debugging
const keycloakConfig = {
    clientId: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',
    issuer: process.env.KEYCLOAK_ISSUER || 'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru',
    nextAuthUrl: process.env.NEXTAUTH_URL || 'http://localhost:3000',
    expectedRedirectUri: `${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/api/auth/callback/keycloak`
};
console.log('[NextAuth Config] Keycloak Configuration:', {
    clientId: keycloakConfig.clientId,
    issuer: keycloakConfig.issuer,
    nextAuthUrl: keycloakConfig.nextAuthUrl,
    expectedRedirectUri: keycloakConfig.expectedRedirectUri,
    hasClientSecret: !!process.env.KEYCLOAK_CLIENT_SECRET
});
// Build provider config - conditionally include clientSecret only if set
const keycloakProviderConfig = {
    clientId: keycloakConfig.clientId,
    issuer: keycloakConfig.issuer,
    authorization: {
        params: {
            // Ensure openid scope is first - required for id_token
            scope: 'openid email profile',
            // Request access to the kyb-connect resource to get roles
            audience: 'resource:kyb-connect'
        }
    },
    wellKnown: process.env.KEYCLOAK_WELL_KNOWN || `${keycloakConfig.issuer}/.well-known/openid-configuration`
};
// Only include clientSecret if it's actually set (for confidential clients)
// For public clients, omit it entirely and use 'none' authentication
if (process.env.KEYCLOAK_CLIENT_SECRET && process.env.KEYCLOAK_CLIENT_SECRET.trim() !== '') {
    keycloakProviderConfig.clientSecret = process.env.KEYCLOAK_CLIENT_SECRET;
    console.log('[NextAuth Config] Using confidential client (with secret)');
} else {
    // For public clients, configure token endpoint auth method to 'none'
    // This tells the openid-client library to not send client_secret
    // The library will still handle PKCE automatically
    keycloakProviderConfig.client = {
        token_endpoint_auth_method: 'none'
    };
    console.log('[NextAuth Config] Using public client (no secret, token_endpoint_auth_method: none)');
}
const authOptions = {
    debug: ("TURBOPACK compile-time value", "development") === 'development',
    logger: {
        error (code, metadata) {
            console.error('[NextAuth Error]', code, metadata);
        },
        warn (code) {
            console.warn('[NextAuth Warn]', code);
        },
        debug (code, metadata) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.log('[NextAuth Debug]', code, metadata);
            }
        }
    },
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$keycloak$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(keycloakProviderConfig)
    ],
    callbacks: {
        async signIn ({ user, account, profile }) {
            // Log sign-in attempt for debugging
            if (account) {
                console.log('[NextAuth] Sign-in attempt:', {
                    provider: account.provider,
                    type: account.type,
                    hasAccessToken: !!account.access_token,
                    hasRefreshToken: !!account.refresh_token
                });
            } else {
                console.error('[NextAuth] Sign-in failed - no account object');
                return false;
            }
            // Note: Role validation happens in JWT callback after token exchange
            // We don't validate here because id_token might not have resource_access
            // The access_token will have the roles we need
            return true;
        },
        async redirect ({ url, baseUrl }) {
            // Log redirects for debugging
            console.log('[NextAuth] Redirect:', {
                url,
                baseUrl,
                expectedBaseUrl: process.env.NEXTAUTH_URL
            });
            // Allows relative callback URLs
            if (url.startsWith('/')) return `${baseUrl}${url}`;
            // Allows callback URLs on the same origin
            if (new URL(url).origin === baseUrl) return url;
            return baseUrl;
        },
        async jwt ({ token, account, user }) {
            // Initial sign in - store tokens in Redis
            if (account && user) {
                console.log('[NextAuth] JWT callback - storing tokens:', {
                    hasAccessToken: !!account.access_token,
                    hasRefreshToken: !!account.refresh_token,
                    expiresAt: account.expires_at,
                    userEmail: user.email
                });
                const sessionId = token.sub || token.jti || `session-${Date.now()}-${Math.random()}`;
                token.sessionId = sessionId;
                token.accessTokenExpiryTime = account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000;
                // Ensure user object is properly set with all required fields
                token.user = {
                    id: user.id || user.email || sessionId,
                    name: user.name || user.email || 'User',
                    email: user.email || undefined,
                    image: user.image || undefined
                };
                // Also store email and name directly in token for fallback
                token.email = user.email;
                token.name = user.name || user.email || 'User';
                // Store tokens in Redis (not in JWT)
                if (!account.access_token) {
                    console.error('[NextAuth] No access token received from Keycloak - this will cause Callback error');
                    // Don't throw - let NextAuth handle the error, but log it
                    token.error = 'NoAccessToken';
                    return token;
                }
                // Validate required role from access token
                try {
                    const tokenParts = account.access_token.split('.');
                    if (tokenParts.length === 3) {
                        const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());
                        const resourceAccess = payload.resource_access || {};
                        const kybConnectRoles = resourceAccess['resource:kyb-connect']?.roles || [];
                        console.log('[NextAuth] Token payload resource_access:', JSON.stringify(resourceAccess, null, 2));
                        console.log('[NextAuth] kyb-connect roles:', kybConnectRoles);
                        if (!kybConnectRoles.includes('business-user')) {
                            console.warn('[NextAuth] User missing required role: business-user');
                            console.warn('[NextAuth] Available roles:', kybConnectRoles);
                            console.warn('[NextAuth] Full resource_access:', JSON.stringify(resourceAccess, null, 2));
                        // Don't fail auth - just log warning for now
                        // You can uncomment the next lines to enforce role requirement:
                        // token.error = 'MissingRole';
                        // return token;
                        } else {
                            // Store role info in token for session
                            token.roles = kybConnectRoles;
                            console.log('[NextAuth] âœ… User has required role: business-user');
                        }
                    }
                } catch (error) {
                    console.error('[NextAuth] Failed to parse access token for role validation:', error);
                // Continue anyway - don't block auth on parsing errors
                }
                try {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storeTokenSession"])(sessionId, {
                        accessToken: account.access_token,
                        refreshToken: account.refresh_token || '',
                        accessTokenExpiryTime: token.accessTokenExpiryTime || Date.now() + 3600 * 1000,
                        provider: 'keycloak',
                        userEmail: user.email || undefined,
                        userId: user.id || user.email || undefined
                    });
                    console.log('[NextAuth] Tokens stored in Redis successfully');
                } catch (error) {
                    console.error('[NextAuth] Failed to store tokens in Redis:', error);
                // Don't fail the auth flow if Redis fails - log it but continue
                // The tokens are still in the account object, so auth can proceed
                }
                // DO NOT store accessToken/refreshToken in JWT - only in Redis
                return token;
            }
            // Check if we need to refresh token
            const sessionId = token.sessionId;
            if (sessionId) {
                try {
                    const redisSession = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTokenSession"])(sessionId);
                    if (redisSession) {
                        // Check if token needs refresh
                        if (redisSession.accessTokenExpiryTime && Date.now() < redisSession.accessTokenExpiryTime - 60 * 1000) {
                            // Token still valid
                            return token;
                        }
                        // Token expired, refresh it
                        return refreshAccessToken(token, sessionId);
                    }
                } catch (error) {
                    console.error('[NextAuth] Failed to get Redis session:', error);
                // Continue with fallback logic
                }
            }
            // Fallback: if no Redis session, check JWT expiry (legacy support)
            if (token.accessTokenExpiryTime && Date.now() < token.accessTokenExpiryTime - 60 * 1000) {
                return token;
            }
            // Access token has expired, try to update it
            try {
                return refreshAccessToken(token, sessionId);
            } catch (error) {
                console.error('[NextAuth] Failed to refresh token:', error);
                // Return token with error instead of throwing
                token.error = 'RefreshTokenError';
                return token;
            }
        },
        async session ({ session, token }) {
            try {
                // DO NOT expose accessToken or sessionId to frontend - BFF pattern
                // sessionId is stored in httpOnly JWT cookie only, never exposed to client-side JS
                session.user = token.user;
                session.error = token.error;
                // session.sessionId is REMOVED - sessionId only exists in httpOnly JWT cookie
                // session.accessToken is removed - tokens are only in Redis
                // Log session creation for debugging
                console.log('[NextAuth] Session callback:', {
                    hasUser: !!session.user,
                    userEmail: session.user?.email,
                    hasError: !!session.error,
                    error: session.error,
                    hasSessionId: !!token.sessionId
                });
                // Ensure user is set - if not, session will be invalid
                if (!session.user) {
                    console.error('[NextAuth] Session callback: No user in token! Token keys:', Object.keys(token));
                    // Try to get user from token directly
                    if (token.email || token.name) {
                        session.user = {
                            email: token.email,
                            name: token.name,
                            id: token.sub
                        };
                        console.log('[NextAuth] Session callback: Reconstructed user from token');
                    } else {
                        console.error('[NextAuth] Session callback: Cannot create valid session - no user data');
                    // Return session anyway - let NextAuth handle it
                    }
                }
                if (token.error) {
                    console.error('[NextAuth] Session error:', token.error);
                    console.error('[NextAuth] Token details:', {
                        hasSessionId: !!token.sessionId,
                        hasUser: !!token.user,
                        error: token.error
                    });
                }
                return session;
            } catch (error) {
                console.error('[NextAuth] Session callback error:', error);
                console.error('[NextAuth] Session callback error stack:', error?.stack);
                // Return a minimal session to prevent 500 error
                return {
                    ...session,
                    user: token.user || {
                        email: token.email,
                        name: token.name,
                        id: token.sub
                    },
                    error: 'SessionError'
                };
            }
        }
    },
    pages: {
        signIn: '/auth/login'
    },
    session: {
        strategy: 'jwt',
        maxAge: 7 * 24 * 60 * 60
    },
    cookies: {
        sessionToken: {
            name: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : `next-auth.session-token`,
            options: {
                httpOnly: true,
                sameSite: 'strict',
                path: '/',
                secure: ("TURBOPACK compile-time value", "development") === 'production'
            }
        }
    }
};
}),
"[project]/src/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>handler,
    "POST",
    ()=>handler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
;
;
const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
;
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__cff43a7a._.js.map