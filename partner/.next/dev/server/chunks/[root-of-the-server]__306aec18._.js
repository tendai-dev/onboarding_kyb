module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/node:timers/promises [external] (node:timers/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:timers/promises", () => require("node:timers/promises"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/dns/promises [external] (dns/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns/promises", () => require("dns/promises"));

module.exports = mod;
}),
"[externals]/node:assert [external] (node:assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:assert", () => require("node:assert"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:url [external] (node:url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[project]/src/lib/redis-session.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteTokenSession",
    ()=>deleteTokenSession,
    "getRedisClient",
    ()=>getRedisClient,
    "getTokenSession",
    ()=>getTokenSession,
    "storeTokenSession",
    ()=>storeTokenSession,
    "updateAccessToken",
    ()=>updateAccessToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redis$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/redis/dist/index.js [app-route] (ecmascript)");
;
// Redis client singleton
let redisClient = null;
async function getRedisClient() {
    if (redisClient && redisClient.isOpen) {
        return redisClient;
    }
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    redisClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$redis$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])({
        url: redisUrl
    });
    redisClient.on('error', (err)=>console.error('Redis Client Error', err));
    redisClient.on('connect', ()=>console.log('Redis Client Connected'));
    if (!redisClient.isOpen) {
        await redisClient.connect();
    }
    return redisClient;
}
const SESSION_PREFIX = 'session:';
const TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days
async function storeTokenSession(sessionId, tokens) {
    try {
        const client = await getRedisClient();
        const key = `${SESSION_PREFIX}${sessionId}`;
        await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));
        console.log(`[Redis] Stored token session: ${key}`);
    } catch (error) {
        console.error('[Redis] Failed to store token session:', error);
        throw error; // Re-throw so caller knows it failed
    }
}
async function getTokenSession(sessionId) {
    try {
        const client = await getRedisClient();
        const key = `${SESSION_PREFIX}${sessionId}`;
        const data = await client.get(key);
        if (!data) return null;
        return JSON.parse(data);
    } catch (error) {
        console.error('[Redis] Failed to get token session:', error);
        return null; // Return null instead of throwing
    }
}
async function deleteTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.del(key);
}
async function updateAccessToken(sessionId, accessToken, accessTokenExpiryTime) {
    const session = await getTokenSession(sessionId);
    if (!session) {
        throw new Error('Session not found');
    }
    await storeTokenSession(sessionId, {
        ...session,
        accessToken,
        accessTokenExpiryTime
    });
}
}),
"[project]/src/app/api/proxy/[...path]/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DELETE",
    ()=>DELETE,
    "GET",
    ()=>GET,
    "OPTIONS",
    ()=>OPTIONS,
    "PATCH",
    ()=>PATCH,
    "POST",
    ()=>POST,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/jwt/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-session.ts [app-route] (ecmascript)");
;
;
;
// All services are now consolidated into the unified onboarding-api
const UNIFIED_API_TARGET = process.env.PROXY_TARGET || process.env.ONBOARDING_TARGET || 'http://localhost:8001';
const AUTH_TARGET = process.env.PROXY_TARGET_AUTH || process.env.AUTH_TARGET || 'http://localhost:8090';
function resolveUpstream(pathname, search) {
    // All services are now consolidated into the unified onboarding-api
    // Route /api/users/* to authentication service (if separate)
    // Everything else goes to unified API
    const afterProxy = pathname.split('/api/proxy')[1] || '';
    // Route /api/users/* to authentication service (if still separate)
    if (afterProxy.startsWith('/api/users')) {
        return `${AUTH_TARGET}${afterProxy}${search}`;
    }
    // All other routes go to unified onboarding-api
    return `${UNIFIED_API_TARGET}${afterProxy}${search}`;
}
async function forward(req) {
    const url = resolveUpstream(req.nextUrl.pathname, req.nextUrl.search);
    // Debug logging for messaging endpoints
    if (req.nextUrl.pathname.includes('/messages')) {
        console.log(`[Proxy] Messaging request - routing to: ${url}`);
        const userHeaders = [
            'X-User-Id',
            'X-User-Email',
            'X-User-Name',
            'X-User-Role'
        ];
        const headerValues = {};
        for (const headerName of userHeaders){
            const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());
            if (value) headerValues[headerName] = value;
        }
        console.log(`[Proxy] User headers received:`, headerValues);
    }
    // Debug logging for document uploads
    if (req.nextUrl.pathname.includes('/documents/upload')) {
        console.log(`[Proxy] Document upload request - routing to: ${url}`);
    }
    const headers = {};
    // Get NextAuth session token from httpOnly cookie (BFF pattern)
    // sessionId is stored in JWT cookie, never exposed to client-side JS
    let accessToken = null;
    try {
        const token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getToken"])({
            req,
            secret: process.env.NEXTAUTH_SECRET
        });
        if (token?.sessionId) {
            // Fetch tokens from Redis using sessionId from httpOnly JWT cookie
            const tokenSession = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTokenSession"])(token.sessionId);
            if (tokenSession) {
                // Check if token needs refresh (within 60 seconds of expiry)
                const needsRefresh = !tokenSession.accessTokenExpiryTime || Date.now() >= tokenSession.accessTokenExpiryTime - 60 * 1000;
                if (needsRefresh && tokenSession.refreshToken) {
                    // Token expired or expiring soon - refresh it automatically
                    try {
                        const tokenUrl = process.env.KEYCLOAK_TOKEN_URL || 'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru/protocol/openid-connect/token';
                        const refreshResponse = await fetch(tokenUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded'
                            },
                            body: new URLSearchParams({
                                client_id: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',
                                grant_type: 'refresh_token',
                                refresh_token: tokenSession.refreshToken,
                                client_secret: process.env.KEYCLOAK_CLIENT_SECRET || ''
                            })
                        });
                        if (refreshResponse.ok) {
                            const refreshedTokens = await refreshResponse.json();
                            const newAccessToken = refreshedTokens.access_token;
                            const newRefreshToken = refreshedTokens.refresh_token ?? tokenSession.refreshToken;
                            const newExpiryTime = Date.now() + refreshedTokens.expires_in * 1000;
                            // Update Redis with new tokens
                            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storeTokenSession"])(token.sessionId, {
                                ...tokenSession,
                                accessToken: newAccessToken,
                                refreshToken: newRefreshToken,
                                accessTokenExpiryTime: newExpiryTime
                            });
                            accessToken = newAccessToken;
                        } else {
                            // Refresh failed - use existing token and let backend handle 401
                            accessToken = tokenSession.accessToken;
                        }
                    } catch (refreshError) {
                        // Refresh failed - use existing token
                        console.warn('[Proxy] Token refresh failed:', refreshError);
                        accessToken = tokenSession.accessToken;
                    }
                } else {
                    // Token still valid
                    accessToken = tokenSession.accessToken;
                }
            }
        }
    } catch (error) {
        console.warn('Failed to get token from session:', error);
    // Continue without token - backend will return 401 if auth required
    }
    // Inject Authorization header from Redis-stored token (do NOT forward from client)
    if (accessToken) {
        headers['authorization'] = `Bearer ${accessToken}`;
        headers['Authorization'] = `Bearer ${accessToken}`;
    }
    const contentType = req.headers.get('content-type') || req.headers.get('Content-Type');
    if (contentType) {
        headers['content-type'] = contentType;
        headers['Content-Type'] = contentType;
    } else {
        // Only set default JSON content-type if not multipart/form-data
        if (!contentType?.includes('multipart/form-data')) {
            headers['content-type'] = 'application/json';
            headers['Content-Type'] = 'application/json';
        }
    }
    // Forward user identification headers to backend services
    const userHeaders = [
        'X-User-Id',
        'X-User-Email',
        'X-User-Name',
        'X-User-Role'
    ];
    for (const headerName of userHeaders){
        const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());
        if (value) {
            headers[headerName] = value;
            headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility
        }
    }
    // Forward schema-driven form headers (CRITICAL for dynamic validation)
    const schemaHeaders = [
        'X-Entity-Type',
        'X-Form-Config-Id',
        'X-Form-Version'
    ];
    for (const headerName of schemaHeaders){
        const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());
        if (value) {
            headers[headerName] = value;
            headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility
            console.log(`[Proxy] Forwarding ${headerName}: ${value}`);
        }
    }
    // Add additional headers for better debugging
    headers['user-agent'] = 'NextJS-Proxy/1.0';
    // Handle request body
    let body;
    if ([
        'GET',
        'HEAD'
    ].includes(req.method)) {
        body = undefined;
    } else if (contentType?.includes('multipart/form-data')) {
        // For file uploads, parse FormData and reconstruct it
        // This preserves the multipart structure that the backend expects
        const formData = await req.formData();
        body = formData;
        // Remove Content-Type header - fetch will set it with the correct boundary
        delete headers['content-type'];
        delete headers['Content-Type'];
    } else {
        // For JSON and other text-based content, read as text
        body = await req.text();
    }
    const init = {
        method: req.method,
        headers,
        body,
        redirect: 'manual'
    };
    try {
        const res = await fetch(url, init);
        const body = await res.arrayBuffer();
        // Log 500 errors for debugging
        if (res.status === 500) {
            const errorBody = new TextDecoder().decode(body);
            console.error(`[Proxy] Backend 500 error for ${url}:`, errorBody);
            console.error(`[Proxy] Request headers sent:`, Object.keys(headers).map((k)=>`${k}: ${headers[k]?.substring(0, 50)}`));
        }
        const respHeaders = new Headers();
        res.headers.forEach((v, k)=>respHeaders.set(k, v));
        // ensure CORS for browser even though this is same-origin
        respHeaders.set('Access-Control-Allow-Origin', '*');
        respHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
        respHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role, X-Entity-Type, X-Form-Config-Id, X-Form-Version, X-Request-Id');
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](body, {
            status: res.status,
            headers: respHeaders
        });
    } catch (error) {
        console.error('[Proxy] Error:', error, 'URL:', url);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        // If it's a connection error, provide more helpful message
        if (errorMessage.includes('ECONNREFUSED') || errorMessage.includes('fetch failed') || errorMessage.includes('ECONNREFUSED')) {
            console.error(`[Proxy] Connection failed to ${url} - service may not be running`);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
                error: 'Backend service unavailable',
                details: `Cannot connect to ${url}. Please ensure the backend service is running.`,
                originalError: errorMessage
            }), {
                status: 503,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
            error: 'Proxy request failed',
            details: errorMessage
        }), {
            status: 502,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
const GET = forward;
const POST = forward;
const PUT = forward;
const PATCH = forward;
const DELETE = forward;
const OPTIONS = forward;
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__306aec18._.js.map