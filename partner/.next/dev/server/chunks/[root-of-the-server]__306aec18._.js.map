{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/partner/src/lib/redis-session.ts"],"sourcesContent":["import { createClient } from 'redis';\n\n// Redis client singleton\nlet redisClient: ReturnType<typeof createClient> | null = null;\n\nexport async function getRedisClient() {\n  if (redisClient && redisClient.isOpen) {\n    return redisClient;\n  }\n\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n  redisClient = createClient({ url: redisUrl });\n\n  redisClient.on('error', (err) => console.error('Redis Client Error', err));\n  redisClient.on('connect', () => console.log('Redis Client Connected'));\n\n  if (!redisClient.isOpen) {\n    await redisClient.connect();\n  }\n\n  return redisClient;\n}\n\nexport interface TokenSession {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpiryTime: number;\n  provider: 'azure-ad' | 'keycloak';\n  userEmail?: string;\n  userId?: string;\n}\n\nconst SESSION_PREFIX = 'session:';\nconst TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days\n\n/**\n * Store IdP tokens in Redis, keyed by session ID\n */\nexport async function storeTokenSession(\n  sessionId: string,\n  tokens: TokenSession\n): Promise<void> {\n  try {\n    const client = await getRedisClient();\n    const key = `${SESSION_PREFIX}${sessionId}`;\n    await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));\n    console.log(`[Redis] Stored token session: ${key}`);\n  } catch (error) {\n    console.error('[Redis] Failed to store token session:', error);\n    throw error; // Re-throw so caller knows it failed\n  }\n}\n\n/**\n * Retrieve IdP tokens from Redis by session ID\n */\nexport async function getTokenSession(\n  sessionId: string\n): Promise<TokenSession | null> {\n  try {\n    const client = await getRedisClient();\n    const key = `${SESSION_PREFIX}${sessionId}`;\n    const data = await client.get(key);\n    if (!data) return null;\n    return JSON.parse(data) as TokenSession;\n  } catch (error) {\n    console.error('[Redis] Failed to get token session:', error);\n    return null; // Return null instead of throwing\n  }\n}\n\n/**\n * Delete token session from Redis\n */\nexport async function deleteTokenSession(sessionId: string): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.del(key);\n}\n\n/**\n * Update access token (for refresh scenarios)\n */\nexport async function updateAccessToken(\n  sessionId: string,\n  accessToken: string,\n  accessTokenExpiryTime: number\n): Promise<void> {\n  const session = await getTokenSession(sessionId);\n  if (!session) {\n    throw new Error('Session not found');\n  }\n  await storeTokenSession(sessionId, {\n    ...session,\n    accessToken,\n    accessTokenExpiryTime,\n  });\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEA,yBAAyB;AACzB,IAAI,cAAsD;AAEnD,eAAe;IACpB,IAAI,eAAe,YAAY,MAAM,EAAE;QACrC,OAAO;IACT;IAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS,IAAI;IAC1C,cAAc,IAAA,wJAAY,EAAC;QAAE,KAAK;IAAS;IAE3C,YAAY,EAAE,CAAC,SAAS,CAAC,MAAQ,QAAQ,KAAK,CAAC,sBAAsB;IACrE,YAAY,EAAE,CAAC,WAAW,IAAM,QAAQ,GAAG,CAAC;IAE5C,IAAI,CAAC,YAAY,MAAM,EAAE;QACvB,MAAM,YAAY,OAAO;IAC3B;IAEA,OAAO;AACT;AAWA,MAAM,iBAAiB;AACvB,MAAM,cAAc,IAAI,KAAK,KAAK,IAAI,SAAS;AAKxC,eAAe,kBACpB,SAAiB,EACjB,MAAoB;IAEpB,IAAI;QACF,MAAM,SAAS,MAAM;QACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;QAC3C,MAAM,OAAO,KAAK,CAAC,KAAK,aAAa,KAAK,SAAS,CAAC;QACpD,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,KAAK;IACpD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,MAAM,OAAO,qCAAqC;IACpD;AACF;AAKO,eAAe,gBACpB,SAAiB;IAEjB,IAAI;QACF,MAAM,SAAS,MAAM;QACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;QAC3C,MAAM,OAAO,MAAM,OAAO,GAAG,CAAC;QAC9B,IAAI,CAAC,MAAM,OAAO;QAClB,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO,MAAM,kCAAkC;IACjD;AACF;AAKO,eAAe,mBAAmB,SAAiB;IACxD,MAAM,SAAS,MAAM;IACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;IAC3C,MAAM,OAAO,GAAG,CAAC;AACnB;AAKO,eAAe,kBACpB,SAAiB,EACjB,WAAmB,EACnB,qBAA6B;IAE7B,MAAM,UAAU,MAAM,gBAAgB;IACtC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,kBAAkB,WAAW;QACjC,GAAG,OAAO;QACV;QACA;IACF;AACF"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/partner/src/app/api/proxy/%5B...path%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\nimport { getTokenSession, storeTokenSession } from '@/lib/redis-session';\n\n// All services are now consolidated into the unified onboarding-api\nconst UNIFIED_API_TARGET = process.env.PROXY_TARGET || process.env.ONBOARDING_TARGET || 'http://localhost:8001';\nconst AUTH_TARGET = process.env.PROXY_TARGET_AUTH || process.env.AUTH_TARGET || 'http://localhost:8090';\n\nfunction resolveUpstream(pathname: string, search: string) {\n  // All services are now consolidated into the unified onboarding-api\n  // Route /api/users/* to authentication service (if separate)\n  // Everything else goes to unified API\n  const afterProxy = pathname.split('/api/proxy')[1] || '';\n\n  // Route /api/users/* to authentication service (if still separate)\n  if (afterProxy.startsWith('/api/users')) {\n    return `${AUTH_TARGET}${afterProxy}${search}`;\n  }\n\n  // All other routes go to unified onboarding-api\n  return `${UNIFIED_API_TARGET}${afterProxy}${search}`;\n}\n\nasync function forward(req: NextRequest) {\n  const url = resolveUpstream(req.nextUrl.pathname, req.nextUrl.search);\n  \n  // Debug logging for messaging endpoints\n  if (req.nextUrl.pathname.includes('/messages')) {\n    console.log(`[Proxy] Messaging request - routing to: ${url}`);\n    const userHeaders = ['X-User-Id', 'X-User-Email', 'X-User-Name', 'X-User-Role'];\n    const headerValues: Record<string, string> = {};\n    for (const headerName of userHeaders) {\n      const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());\n      if (value) headerValues[headerName] = value;\n    }\n    console.log(`[Proxy] User headers received:`, headerValues);\n  }\n  \n  // Debug logging for document uploads\n  if (req.nextUrl.pathname.includes('/documents/upload')) {\n    console.log(`[Proxy] Document upload request - routing to: ${url}`);\n  }\n\n  const headers: Record<string, string> = {};\n  \n  // Get NextAuth session token from httpOnly cookie (BFF pattern)\n  // sessionId is stored in JWT cookie, never exposed to client-side JS\n  let accessToken: string | null = null;\n  try {\n    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });\n    if (token?.sessionId) {\n      // Fetch tokens from Redis using sessionId from httpOnly JWT cookie\n      const tokenSession = await getTokenSession(token.sessionId as string);\n      if (tokenSession) {\n        // Check if token needs refresh (within 60 seconds of expiry)\n        const needsRefresh = !tokenSession.accessTokenExpiryTime || \n                            Date.now() >= tokenSession.accessTokenExpiryTime - 60 * 1000;\n        \n        if (needsRefresh && tokenSession.refreshToken) {\n          // Token expired or expiring soon - refresh it automatically\n          try {\n            const tokenUrl = process.env.KEYCLOAK_TOKEN_URL || \n                           'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru/protocol/openid-connect/token';\n            \n            const refreshResponse = await fetch(tokenUrl, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n              },\n              body: new URLSearchParams({\n                client_id: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',\n                grant_type: 'refresh_token',\n                refresh_token: tokenSession.refreshToken,\n                client_secret: process.env.KEYCLOAK_CLIENT_SECRET || '',\n              }),\n            });\n\n            if (refreshResponse.ok) {\n              const refreshedTokens = await refreshResponse.json();\n              const newAccessToken = refreshedTokens.access_token;\n              const newRefreshToken = refreshedTokens.refresh_token ?? tokenSession.refreshToken;\n              const newExpiryTime = Date.now() + (refreshedTokens.expires_in * 1000);\n\n              // Update Redis with new tokens\n              await storeTokenSession(token.sessionId, {\n                ...tokenSession,\n                accessToken: newAccessToken,\n                refreshToken: newRefreshToken,\n                accessTokenExpiryTime: newExpiryTime,\n              });\n\n              accessToken = newAccessToken;\n            } else {\n              // Refresh failed - use existing token and let backend handle 401\n              accessToken = tokenSession.accessToken;\n            }\n          } catch (refreshError) {\n            // Refresh failed - use existing token\n            console.warn('[Proxy] Token refresh failed:', refreshError);\n            accessToken = tokenSession.accessToken;\n          }\n        } else {\n          // Token still valid\n          accessToken = tokenSession.accessToken;\n        }\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to get token from session:', error);\n    // Continue without token - backend will return 401 if auth required\n  }\n  \n  // Inject Authorization header from Redis-stored token (do NOT forward from client)\n  if (accessToken) {\n    headers['authorization'] = `Bearer ${accessToken}`;\n    headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n  \n  const contentType = req.headers.get('content-type') || req.headers.get('Content-Type');\n  if (contentType) {\n    headers['content-type'] = contentType;\n    headers['Content-Type'] = contentType;\n  } else {\n    // Only set default JSON content-type if not multipart/form-data\n    if (!contentType?.includes('multipart/form-data')) {\n      headers['content-type'] = 'application/json';\n      headers['Content-Type'] = 'application/json';\n    }\n  }\n\n  // Forward user identification headers to backend services\n  const userHeaders = ['X-User-Id', 'X-User-Email', 'X-User-Name', 'X-User-Role'];\n  for (const headerName of userHeaders) {\n    const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());\n    if (value) {\n      headers[headerName] = value;\n      headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility\n    }\n  }\n\n  // Forward schema-driven form headers (CRITICAL for dynamic validation)\n  const schemaHeaders = ['X-Entity-Type', 'X-Form-Config-Id', 'X-Form-Version'];\n  for (const headerName of schemaHeaders) {\n    const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());\n    if (value) {\n      headers[headerName] = value;\n      headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility\n      console.log(`[Proxy] Forwarding ${headerName}: ${value}`);\n    }\n  }\n\n  // Add additional headers for better debugging\n  headers['user-agent'] = 'NextJS-Proxy/1.0';\n\n  // Handle request body\n  let body: BodyInit | undefined;\n  if (['GET', 'HEAD'].includes(req.method)) {\n    body = undefined;\n  } else if (contentType?.includes('multipart/form-data')) {\n    // For file uploads, parse FormData and reconstruct it\n    // This preserves the multipart structure that the backend expects\n    const formData = await req.formData();\n    body = formData;\n    // Remove Content-Type header - fetch will set it with the correct boundary\n    delete headers['content-type'];\n    delete headers['Content-Type'];\n  } else {\n    // For JSON and other text-based content, read as text\n    body = await req.text();\n  }\n\n  const init: RequestInit = {\n    method: req.method,\n    headers,\n    body,\n    redirect: 'manual'\n  };\n\n  try {\n    const res = await fetch(url, init);\n    const body = await res.arrayBuffer();\n\n    // Log 500 errors for debugging\n    if (res.status === 500) {\n      const errorBody = new TextDecoder().decode(body);\n      console.error(`[Proxy] Backend 500 error for ${url}:`, errorBody);\n      console.error(`[Proxy] Request headers sent:`, Object.keys(headers).map(k => `${k}: ${headers[k]?.substring(0, 50)}`));\n    }\n\n    const respHeaders = new Headers();\n    res.headers.forEach((v, k) => respHeaders.set(k, v));\n    // ensure CORS for browser even though this is same-origin\n    respHeaders.set('Access-Control-Allow-Origin', '*');\n    respHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');\n    respHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role, X-Entity-Type, X-Form-Config-Id, X-Form-Version, X-Request-Id');\n\n    return new NextResponse(body, { status: res.status, headers: respHeaders });\n  } catch (error) {\n    console.error('[Proxy] Error:', error, 'URL:', url);\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    // If it's a connection error, provide more helpful message\n    if (errorMessage.includes('ECONNREFUSED') || errorMessage.includes('fetch failed') || errorMessage.includes('ECONNREFUSED')) {\n      console.error(`[Proxy] Connection failed to ${url} - service may not be running`);\n      return new NextResponse(JSON.stringify({ \n        error: 'Backend service unavailable', \n        details: `Cannot connect to ${url}. Please ensure the backend service is running.`,\n        originalError: errorMessage\n      }), { \n        status: 503, \n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    \n    return new NextResponse(JSON.stringify({ error: 'Proxy request failed', details: errorMessage }), { \n      status: 502, \n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n\nexport const GET = forward;\nexport const POST = forward;\nexport const PUT = forward;\nexport const PATCH = forward;\nexport const DELETE = forward;\nexport const OPTIONS = forward;\n"],"names":[],"mappings":"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"}}]
}