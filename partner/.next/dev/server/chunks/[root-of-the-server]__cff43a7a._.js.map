{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/partner/src/lib/redis-session.ts"],"sourcesContent":["import { createClient } from 'redis';\n\n// Redis client singleton\nlet redisClient: ReturnType<typeof createClient> | null = null;\n\nexport async function getRedisClient() {\n  if (redisClient && redisClient.isOpen) {\n    return redisClient;\n  }\n\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n  redisClient = createClient({ url: redisUrl });\n\n  redisClient.on('error', (err) => console.error('Redis Client Error', err));\n  redisClient.on('connect', () => console.log('Redis Client Connected'));\n\n  if (!redisClient.isOpen) {\n    await redisClient.connect();\n  }\n\n  return redisClient;\n}\n\nexport interface TokenSession {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpiryTime: number;\n  provider: 'azure-ad' | 'keycloak';\n  userEmail?: string;\n  userId?: string;\n}\n\nconst SESSION_PREFIX = 'session:';\nconst TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days\n\n/**\n * Store IdP tokens in Redis, keyed by session ID\n */\nexport async function storeTokenSession(\n  sessionId: string,\n  tokens: TokenSession\n): Promise<void> {\n  try {\n    const client = await getRedisClient();\n    const key = `${SESSION_PREFIX}${sessionId}`;\n    await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));\n    console.log(`[Redis] Stored token session: ${key}`);\n  } catch (error) {\n    console.error('[Redis] Failed to store token session:', error);\n    throw error; // Re-throw so caller knows it failed\n  }\n}\n\n/**\n * Retrieve IdP tokens from Redis by session ID\n */\nexport async function getTokenSession(\n  sessionId: string\n): Promise<TokenSession | null> {\n  try {\n    const client = await getRedisClient();\n    const key = `${SESSION_PREFIX}${sessionId}`;\n    const data = await client.get(key);\n    if (!data) return null;\n    return JSON.parse(data) as TokenSession;\n  } catch (error) {\n    console.error('[Redis] Failed to get token session:', error);\n    return null; // Return null instead of throwing\n  }\n}\n\n/**\n * Delete token session from Redis\n */\nexport async function deleteTokenSession(sessionId: string): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.del(key);\n}\n\n/**\n * Update access token (for refresh scenarios)\n */\nexport async function updateAccessToken(\n  sessionId: string,\n  accessToken: string,\n  accessTokenExpiryTime: number\n): Promise<void> {\n  const session = await getTokenSession(sessionId);\n  if (!session) {\n    throw new Error('Session not found');\n  }\n  await storeTokenSession(sessionId, {\n    ...session,\n    accessToken,\n    accessTokenExpiryTime,\n  });\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEA,yBAAyB;AACzB,IAAI,cAAsD;AAEnD,eAAe;IACpB,IAAI,eAAe,YAAY,MAAM,EAAE;QACrC,OAAO;IACT;IAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS,IAAI;IAC1C,cAAc,IAAA,wJAAY,EAAC;QAAE,KAAK;IAAS;IAE3C,YAAY,EAAE,CAAC,SAAS,CAAC,MAAQ,QAAQ,KAAK,CAAC,sBAAsB;IACrE,YAAY,EAAE,CAAC,WAAW,IAAM,QAAQ,GAAG,CAAC;IAE5C,IAAI,CAAC,YAAY,MAAM,EAAE;QACvB,MAAM,YAAY,OAAO;IAC3B;IAEA,OAAO;AACT;AAWA,MAAM,iBAAiB;AACvB,MAAM,cAAc,IAAI,KAAK,KAAK,IAAI,SAAS;AAKxC,eAAe,kBACpB,SAAiB,EACjB,MAAoB;IAEpB,IAAI;QACF,MAAM,SAAS,MAAM;QACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;QAC3C,MAAM,OAAO,KAAK,CAAC,KAAK,aAAa,KAAK,SAAS,CAAC;QACpD,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,KAAK;IACpD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,MAAM,OAAO,qCAAqC;IACpD;AACF;AAKO,eAAe,gBACpB,SAAiB;IAEjB,IAAI;QACF,MAAM,SAAS,MAAM;QACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;QAC3C,MAAM,OAAO,MAAM,OAAO,GAAG,CAAC;QAC9B,IAAI,CAAC,MAAM,OAAO;QAClB,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO,MAAM,kCAAkC;IACjD;AACF;AAKO,eAAe,mBAAmB,SAAiB;IACxD,MAAM,SAAS,MAAM;IACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;IAC3C,MAAM,OAAO,GAAG,CAAC;AACnB;AAKO,eAAe,kBACpB,SAAiB,EACjB,WAAmB,EACnB,qBAA6B;IAE7B,MAAM,UAAU,MAAM,gBAAgB;IACtC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,kBAAkB,WAAW;QACjC,GAAG,OAAO;QACV;QACA;IACF;AACF"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/partner/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from 'next-auth';\nimport KeycloakProvider from 'next-auth/providers/keycloak';\nimport { storeTokenSession, getTokenSession, updateAccessToken } from './redis-session';\n\n// Helper function to refresh tokens\nconst refreshAccessToken = async (token: any, sessionId?: string) => {\n  try {\n    // Get refresh token from Redis if sessionId provided\n    let refreshToken = token.refreshToken;\n    if (sessionId) {\n      const session = await getTokenSession(sessionId);\n      if (session) {\n        refreshToken = session.refreshToken;\n      }\n    }\n\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    const tokenUrl = process.env.KEYCLOAK_TOKEN_URL || \n                     'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru/protocol/openid-connect/token';\n    \n    const response = await fetch(tokenUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        client_id: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n        client_secret: process.env.KEYCLOAK_CLIENT_SECRET || '',\n      }),\n    });\n\n    const refreshedTokens = await response.json();\n\n    if (!response.ok) {\n      throw refreshedTokens;\n    }\n\n    const newAccessToken = refreshedTokens.access_token;\n    const newRefreshToken = refreshedTokens.refresh_token ?? refreshToken;\n    const newExpiryTime = Date.now() + (refreshedTokens.expires_in * 1000);\n\n    // Update Redis if sessionId provided\n    if (sessionId) {\n      await updateAccessToken(sessionId, newAccessToken, newExpiryTime);\n      if (newRefreshToken !== refreshToken) {\n        const session = await getTokenSession(sessionId);\n        if (session) {\n          await storeTokenSession(sessionId, {\n            ...session,\n            refreshToken: newRefreshToken,\n            accessToken: newAccessToken,\n            accessTokenExpiryTime: newExpiryTime,\n          });\n        }\n      }\n    }\n\n    return {\n      ...token,\n      accessToken: newAccessToken,\n      accessTokenExpiryTime: newExpiryTime,\n      refreshToken: newRefreshToken,\n    };\n  } catch (error) {\n    console.error('Error refreshing access token', error);\n    return {\n      ...token,\n      error: 'RefreshAccessTokenError',\n    };\n  }\n};\n\n// Log configuration on startup for debugging\nconst keycloakConfig = {\n  clientId: process.env.KEYCLOAK_CLIENT_ID || 'kyb-connect-portal',\n  issuer: process.env.KEYCLOAK_ISSUER || 'https://keycloak-staging.app-stg.mukuru.io/realms/mukuru',\n  nextAuthUrl: process.env.NEXTAUTH_URL || 'http://localhost:3000',\n  expectedRedirectUri: `${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/api/auth/callback/keycloak`,\n};\n\nconsole.log('[NextAuth Config] Keycloak Configuration:', {\n  clientId: keycloakConfig.clientId,\n  issuer: keycloakConfig.issuer,\n  nextAuthUrl: keycloakConfig.nextAuthUrl,\n  expectedRedirectUri: keycloakConfig.expectedRedirectUri,\n  hasClientSecret: !!process.env.KEYCLOAK_CLIENT_SECRET,\n});\n\n// Build provider config - conditionally include clientSecret only if set\nconst keycloakProviderConfig: any = {\n  clientId: keycloakConfig.clientId,\n  issuer: keycloakConfig.issuer,\n  authorization: {\n    params: {\n      // Ensure openid scope is first - required for id_token\n      scope: 'openid email profile',\n      // Request access to the kyb-connect resource to get roles\n      audience: 'resource:kyb-connect',\n    },\n  },\n  wellKnown: process.env.KEYCLOAK_WELL_KNOWN || `${keycloakConfig.issuer}/.well-known/openid-configuration`,\n};\n\n// Only include clientSecret if it's actually set (for confidential clients)\n// For public clients, omit it entirely and use 'none' authentication\nif (process.env.KEYCLOAK_CLIENT_SECRET && process.env.KEYCLOAK_CLIENT_SECRET.trim() !== '') {\n  keycloakProviderConfig.clientSecret = process.env.KEYCLOAK_CLIENT_SECRET;\n  console.log('[NextAuth Config] Using confidential client (with secret)');\n} else {\n  // For public clients, configure token endpoint auth method to 'none'\n  // This tells the openid-client library to not send client_secret\n  // The library will still handle PKCE automatically\n  keycloakProviderConfig.client = {\n    token_endpoint_auth_method: 'none',\n  };\n  console.log('[NextAuth Config] Using public client (no secret, token_endpoint_auth_method: none)');\n}\n\nexport const authOptions: NextAuthOptions = {\n  debug: process.env.NODE_ENV === 'development', // Enable debug logging in dev\n  logger: {\n    error(code, metadata) {\n      console.error('[NextAuth Error]', code, metadata);\n    },\n    warn(code) {\n      console.warn('[NextAuth Warn]', code);\n    },\n    debug(code, metadata) {\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[NextAuth Debug]', code, metadata);\n      }\n    },\n  },\n  providers: [\n    KeycloakProvider(keycloakProviderConfig),\n  ],\n  callbacks: {\n    async signIn({ user, account, profile }) {\n      // Log sign-in attempt for debugging\n      if (account) {\n        console.log('[NextAuth] Sign-in attempt:', {\n          provider: account.provider,\n          type: account.type,\n          hasAccessToken: !!account.access_token,\n          hasRefreshToken: !!account.refresh_token,\n        });\n      } else {\n        console.error('[NextAuth] Sign-in failed - no account object');\n        return false;\n      }\n\n      // Note: Role validation happens in JWT callback after token exchange\n      // We don't validate here because id_token might not have resource_access\n      // The access_token will have the roles we need\n      return true;\n    },\n    async redirect({ url, baseUrl }) {\n      // Log redirects for debugging\n      console.log('[NextAuth] Redirect:', { url, baseUrl, expectedBaseUrl: process.env.NEXTAUTH_URL });\n      // Allows relative callback URLs\n      if (url.startsWith('/')) return `${baseUrl}${url}`;\n      // Allows callback URLs on the same origin\n      if (new URL(url).origin === baseUrl) return url;\n      return baseUrl;\n    },\n    async jwt({ token, account, user }) {\n      // Initial sign in - store tokens in Redis\n      if (account && user) {\n        console.log('[NextAuth] JWT callback - storing tokens:', {\n          hasAccessToken: !!account.access_token,\n          hasRefreshToken: !!account.refresh_token,\n          expiresAt: account.expires_at,\n          userEmail: user.email,\n        });\n\n        const sessionId = (token.sub as string) || (token.jti as string) || `session-${Date.now()}-${Math.random()}`;\n        token.sessionId = sessionId;\n        token.accessTokenExpiryTime = account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000;\n        // Ensure user object is properly set with all required fields\n        token.user = {\n          id: user.id || user.email || sessionId,\n          name: user.name || user.email || 'User',\n          email: user.email || undefined,\n          image: user.image || undefined,\n        };\n        // Also store email and name directly in token for fallback\n        token.email = user.email;\n        token.name = user.name || user.email || 'User';\n        \n        // Store tokens in Redis (not in JWT)\n        if (!account.access_token) {\n          console.error('[NextAuth] No access token received from Keycloak - this will cause Callback error');\n          // Don't throw - let NextAuth handle the error, but log it\n          token.error = 'NoAccessToken';\n          return token;\n        }\n        \n        // Validate required role from access token\n        try {\n          const tokenParts = account.access_token.split('.');\n          if (tokenParts.length === 3) {\n            const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64').toString());\n            const resourceAccess = payload.resource_access || {};\n            const kybConnectRoles = resourceAccess['resource:kyb-connect']?.roles || [];\n            \n            console.log('[NextAuth] Token payload resource_access:', JSON.stringify(resourceAccess, null, 2));\n            console.log('[NextAuth] kyb-connect roles:', kybConnectRoles);\n            \n            if (!kybConnectRoles.includes('business-user')) {\n              console.warn('[NextAuth] User missing required role: business-user');\n              console.warn('[NextAuth] Available roles:', kybConnectRoles);\n              console.warn('[NextAuth] Full resource_access:', JSON.stringify(resourceAccess, null, 2));\n              // Don't fail auth - just log warning for now\n              // You can uncomment the next lines to enforce role requirement:\n              // token.error = 'MissingRole';\n              // return token;\n            } else {\n              // Store role info in token for session\n              token.roles = kybConnectRoles;\n              console.log('[NextAuth] âœ… User has required role: business-user');\n            }\n          }\n        } catch (error) {\n          console.error('[NextAuth] Failed to parse access token for role validation:', error);\n          // Continue anyway - don't block auth on parsing errors\n        }\n        \n        try {\n          await storeTokenSession(sessionId, {\n            accessToken: account.access_token,\n            refreshToken: account.refresh_token || '',\n            accessTokenExpiryTime: token.accessTokenExpiryTime || Date.now() + 3600 * 1000,\n            provider: 'keycloak',\n            userEmail: user.email || undefined,\n            userId: user.id || user.email || undefined,\n          });\n          console.log('[NextAuth] Tokens stored in Redis successfully');\n        } catch (error) {\n          console.error('[NextAuth] Failed to store tokens in Redis:', error);\n          // Don't fail the auth flow if Redis fails - log it but continue\n          // The tokens are still in the account object, so auth can proceed\n        }\n        \n        // DO NOT store accessToken/refreshToken in JWT - only in Redis\n        return token;\n      }\n\n      // Check if we need to refresh token\n      const sessionId = token.sessionId as string | undefined;\n      if (sessionId) {\n        try {\n          const redisSession = await getTokenSession(sessionId);\n          if (redisSession) {\n            // Check if token needs refresh\n            if (redisSession.accessTokenExpiryTime && Date.now() < redisSession.accessTokenExpiryTime - 60 * 1000) {\n              // Token still valid\n              return token;\n            }\n            // Token expired, refresh it\n            return refreshAccessToken(token, sessionId);\n          }\n        } catch (error) {\n          console.error('[NextAuth] Failed to get Redis session:', error);\n          // Continue with fallback logic\n        }\n      }\n\n      // Fallback: if no Redis session, check JWT expiry (legacy support)\n      if (token.accessTokenExpiryTime && Date.now() < token.accessTokenExpiryTime - 60 * 1000) {\n        return token;\n      }\n\n      // Access token has expired, try to update it\n      try {\n        return refreshAccessToken(token, sessionId);\n      } catch (error) {\n        console.error('[NextAuth] Failed to refresh token:', error);\n        // Return token with error instead of throwing\n        token.error = 'RefreshTokenError';\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        // DO NOT expose accessToken or sessionId to frontend - BFF pattern\n        // sessionId is stored in httpOnly JWT cookie only, never exposed to client-side JS\n        session.user = token.user as any;\n        session.error = token.error as string | undefined;\n        // session.sessionId is REMOVED - sessionId only exists in httpOnly JWT cookie\n        // session.accessToken is removed - tokens are only in Redis\n        \n        // Log session creation for debugging\n        console.log('[NextAuth] Session callback:', {\n          hasUser: !!session.user,\n          userEmail: session.user?.email,\n          hasError: !!session.error,\n          error: session.error,\n          hasSessionId: !!token.sessionId,\n        });\n        \n        // Ensure user is set - if not, session will be invalid\n        if (!session.user) {\n          console.error('[NextAuth] Session callback: No user in token! Token keys:', Object.keys(token));\n          // Try to get user from token directly\n          if (token.email || token.name) {\n            session.user = {\n              email: token.email as string,\n              name: token.name as string,\n              id: token.sub as string,\n            };\n            console.log('[NextAuth] Session callback: Reconstructed user from token');\n          } else {\n            console.error('[NextAuth] Session callback: Cannot create valid session - no user data');\n            // Return session anyway - let NextAuth handle it\n          }\n        }\n        \n        if (token.error) {\n          console.error('[NextAuth] Session error:', token.error);\n          console.error('[NextAuth] Token details:', {\n            hasSessionId: !!token.sessionId,\n            hasUser: !!token.user,\n            error: token.error,\n          });\n        }\n        \n        return session;\n      } catch (error: any) {\n        console.error('[NextAuth] Session callback error:', error);\n        console.error('[NextAuth] Session callback error stack:', error?.stack);\n        // Return a minimal session to prevent 500 error\n        return {\n          ...session,\n          user: token.user as any || {\n            email: token.email as string,\n            name: token.name as string,\n            id: token.sub as string,\n          },\n          error: 'SessionError',\n        };\n      }\n    },\n  },\n  pages: {\n    signIn: '/auth/login',\n  },\n  session: {\n    strategy: 'jwt',\n    maxAge: 7 * 24 * 60 * 60, // 7 days\n  },\n  cookies: {\n    sessionToken: {\n      name: process.env.NODE_ENV === 'production' \n        ? `__Secure-next-auth.session-token`\n        : `next-auth.session-token`,\n      options: {\n        httpOnly: true,\n        sameSite: 'lax',\n        path: '/',\n        secure: process.env.NODE_ENV === 'production',\n      },\n    },\n  },\n};\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 598, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/partner/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from 'next-auth';\nimport { authOptions } from '@/lib/auth';\n\nconst handler = NextAuth(authOptions);\n\n// NextAuth App Router handlers\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,MAAM,UAAU,IAAA,kJAAQ,EAAC,mIAAW"}}]
}