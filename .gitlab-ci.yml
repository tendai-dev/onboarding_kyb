# GitLab CI/CD Pipeline for Onboarding KYC Platform
# Includes API contract validation with Spectral

stages:
  - validate
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# ==========================================
# Stage 1: Validation
# ==========================================

api-contract-validation:
  stage: validate
  image: stoplight/spectral:latest
  script:
    - echo "üîç Validating OpenAPI specifications..."
    - |
      # Find all openapi.yaml files
      for spec in $(find services -name "openapi.yaml"); do
        echo "Validating $spec..."
        spectral lint "$spec" --fail-severity=error --format=stylish
        if [ $? -ne 0 ]; then
          echo "‚ùå API contract validation failed for $spec"
          exit 1
        fi
      done
    - echo "‚úÖ All API contracts validated successfully"
  rules:
    - changes:
        - services/**/openapi.yaml
        - .spectral.yaml
  allow_failure: false

breaking-change-detection:
  stage: validate
  image: node:20-alpine
  before_script:
    - npm install -g @openapitools/openapi-diff
  script:
    - echo "üîç Checking for breaking API changes..."
    - ./scripts/check-breaking-changes.sh
    - echo "‚úÖ No breaking changes detected"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - services/**/openapi.yaml
  allow_failure: false

lint-dotnet:
  stage: validate
  image: mcr.microsoft.com/dotnet/sdk:8.0
  script:
    - echo "üîç Linting .NET code..."
    - |
      for sln in $(find services -name "*.sln"); do
        echo "Linting $sln..."
        dotnet format "$sln" --verify-no-changes --verbosity diagnostic
      done
    - echo "‚úÖ .NET code style check passed"
  rules:
    - changes:
        - services/**/*.cs
  allow_failure: true

lint-typescript:
  stage: validate
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci
  script:
    - echo "üîç Linting TypeScript code..."
    - npm run lint
    - echo "‚úÖ TypeScript linting passed"
  rules:
    - changes:
        - frontend/**/*.ts
        - frontend/**/*.tsx
  allow_failure: true

security-scan:
  stage: validate
  image: aquasec/trivy:latest
  script:
    - echo "üîç Scanning for security vulnerabilities..."
    - |
      for dockerfile in $(find services -name "Dockerfile"); do
        echo "Scanning $dockerfile..."
        trivy config "$dockerfile" --severity HIGH,CRITICAL --exit-code 1
      done
    - echo "‚úÖ Security scan passed"
  allow_failure: false

# ==========================================
# Stage 2: Build
# ==========================================

build-services:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  script:
    - echo "üî® Building service Docker images..."
    - |
      for service in services/*/; do
        service_name=$(basename "$service")
        if [ -f "$service/Dockerfile" ]; then
          echo "Building $service_name..."
          docker build -t "onboarding-kyc/$service_name:$CI_COMMIT_SHA" "$service"
          docker tag "onboarding-kyc/$service_name:$CI_COMMIT_SHA" "onboarding-kyc/$service_name:latest"
        fi
      done
    - echo "‚úÖ All services built successfully"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

build-frontend:
  stage: build
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci
  script:
    - echo "üî® Building frontend..."
    - npm run build
    - echo "‚úÖ Frontend built successfully"
  artifacts:
    paths:
      - frontend/.next/
      - frontend/out/
    expire_in: 1 day
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

# ==========================================
# Stage 3: Test
# ==========================================

test-unit:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  script:
    - echo "üß™ Running unit tests with coverage..."
    - |
      for test_proj in $(find services -name "*Tests.csproj" -o -name "*Tests.Unit.csproj"); do
        echo "Testing $test_proj..."
        # Run tests with coverage - will fail if threshold not met
        dotnet test "$test_proj" \
          --configuration Release \
          --logger "trx;LogFileName=test_results.xml" \
          --collect:"XPlat Code Coverage" \
          --settings coverlet.runsettings || TEST_FAILED=$?
      done
      
      # Extract coverage from coverage.cobertura.xml files and enforce 80% threshold
      COV_FILES=$(find services -name "coverage.cobertura.xml" 2>/dev/null || true)
      if [ -n "$COV_FILES" ]; then
        # Use Python to calculate average coverage
        COVERAGE=$(python3 -c "
import xml.etree.ElementTree as ET
import sys
import glob

files = glob.glob('services/**/coverage.cobertura.xml', recursive=True)
if not files:
    print('0.00')
    sys.exit(1)

total = 0
count = 0
for f in files:
    try:
        tree = ET.parse(f)
        root = tree.getroot()
        line_rate = float(root.get('line-rate', 0))
        total += line_rate
        count += 1
    except Exception as e:
        print(f'Error parsing {f}: {e}', file=sys.stderr)
        pass

if count > 0:
    avg = (total / count) * 100
    print(f'{avg:.2f}')
    # Exit with error if below 80%
    if avg < 80.0:
        sys.exit(1)
else:
    print('0.00')
    sys.exit(1)
" 2>&1)
        COVERAGE_EXIT=$?
        echo "Coverage percentage: ${COVERAGE}%"
        
        # Check if coverage is below 80%
        # Use awk for comparison (works in all environments)
        COVERAGE_CHECK=$(echo "$COVERAGE" | awk '{if ($1 < 80) exit 1; exit 0}' 2>/dev/null)
        if [ $COVERAGE_EXIT -ne 0 ] || [ $? -ne 0 ]; then
          echo "‚ùå Coverage ${COVERAGE}% is below required 80% threshold"
          echo "MR BLOCKED: Backend coverage threshold not met. Please add unit tests to reach 80% coverage."
          echo "View coverage report: Download coverage artifacts"
          exit 1
        else
          echo "‚úÖ Coverage ${COVERAGE}% meets 80% threshold requirement"
        fi
      else
        echo "‚ùå No coverage files found"
        echo "MR BLOCKED: Coverage collection failed. Please ensure tests are running with coverage collection."
        exit 1
      fi
    # Check if any tests failed
    - |
      if [ -n "$TEST_FAILED" ]; then
        echo "‚ùå Unit tests failed or coverage threshold not met"
        exit 1
      fi
    - echo "‚úÖ Unit tests passed with coverage threshold met"
  coverage: '/Coverage percentage:\s*(\d+\.\d+)%/'
  artifacts:
    when: always
    reports:
      junit: "**/test_results.xml"
      coverage_report:
        coverage_format: cobertura
        path: "**/coverage.cobertura.xml"
    paths:
      - "**/coverage/"
      - "**/coverage.cobertura.xml"
      - "**/coverage.json"
      - "**/coverage.lcov"
    expire_in: 1 week

test-integration:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  services:
    - postgres:15-alpine
    - redis:7-alpine
  variables:
    DATABASE_CONNECTION_STRING: "Host=postgres;Database=test;Username=postgres;Password=test"
    REDIS_CONNECTION_STRING: "redis:6379"
  script:
    - echo "üß™ Running integration tests..."
    - dotnet test tests/integration/ --configuration Release --logger "trx;LogFileName=integration_results.xml"
    - echo "‚úÖ Integration tests passed"
  artifacts:
    when: always
    reports:
      junit: "**/integration_results.xml"

test-frontend:
  stage: test
  image: node:20-alpine
  before_script:
    - cd frontend
    - npm ci
  script:
    - echo "üß™ Running frontend tests..."
    - npm run test -- --coverage
    - echo "‚úÖ Frontend tests passed"
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura-coverage.xml

# ==========================================
# Stage 4: Deploy
# ==========================================

deploy-staging:
  stage: deploy
  image: alpine/helm:latest
  before_script:
    - kubectl config use-context staging
  script:
    - echo "üöÄ Deploying to staging..."
    - cd infra/helm
    - helmfile -e staging apply
    - echo "‚úÖ Deployed to staging successfully"
  environment:
    name: staging
    url: https://staging-onboarding.mukuru.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'
  when: manual

deploy-production:
  stage: deploy
  image: alpine/helm:latest
  before_script:
    - kubectl config use-context production
  script:
    - echo "üöÄ Deploying to production..."
    - cd infra/helm
    - helmfile -e production apply
    - echo "‚úÖ Deployed to production successfully"
  environment:
    name: production
    url: https://onboarding.mukuru.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual

# ==========================================
# Notification
# ==========================================

notify-success:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"‚úÖ Pipeline succeeded for $CI_PROJECT_NAME on $CI_COMMIT_BRANCH\"}"
  rules:
    - when: on_success

notify-failure:
  stage: .post
  image: curlimages/curl:latest
  script:
    - |
      curl -X POST https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"‚ùå Pipeline failed for $CI_PROJECT_NAME on $CI_COMMIT_BRANCH\"}"
  rules:
    - when: on_failure

