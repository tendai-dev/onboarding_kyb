{
  "version": 3,
  "sources": [],
  "debugId": "ed784b8c-6b18-1154-eccb-5dc8beb51f23",
  "sections": [
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/lib/sentry.ts"],"sourcesContent":["/**\n * Sentry error reporting utilities\n * Use these functions instead of console.error/warn for proper error tracking\n */\n\nimport * as Sentry from \"@sentry/nextjs\";\n\n/**\n * Report an error to Sentry with optional context\n */\nexport function reportError(\n  error: Error | unknown,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n    level?: Sentry.SeverityLevel;\n    user?: {\n      id?: string;\n      email?: string;\n      username?: string;\n    };\n  }\n): void {\n  if (error instanceof Error) {\n    Sentry.captureException(error, {\n      tags: context?.tags,\n      extra: context?.extra,\n      level: context?.level || \"error\",\n      user: context?.user,\n    });\n  } else {\n    // For non-Error objects, create an Error from the value\n    const errorMessage = typeof error === \"string\" ? error : JSON.stringify(error);\n    Sentry.captureException(new Error(errorMessage), {\n      tags: context?.tags,\n      extra: { originalError: error, ...context?.extra },\n      level: context?.level || \"error\",\n      user: context?.user,\n    });\n  }\n}\n\n/**\n * Report a warning to Sentry\n */\nexport function reportWarning(\n  message: string,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): void {\n  Sentry.captureMessage(message, {\n    level: \"warning\",\n    tags: context?.tags,\n    extra: context?.extra,\n  });\n}\n\n/**\n * Report an API error with request context\n */\nexport function reportApiError(\n  error: Error | unknown,\n  apiContext: {\n    endpoint: string;\n    method?: string;\n    statusCode?: number;\n    responseBody?: string;\n    requestBody?: unknown;\n  },\n  additionalContext?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): void {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  \n  reportError(error, {\n    tags: {\n      error_type: \"api_error\",\n      api_endpoint: apiContext.endpoint,\n      api_method: apiContext.method || \"GET\",\n      ...additionalContext?.tags,\n    },\n    extra: {\n      api_endpoint: apiContext.endpoint,\n      api_method: apiContext.method,\n      status_code: apiContext.statusCode,\n      response_body: apiContext.responseBody,\n      request_body: apiContext.requestBody,\n      ...additionalContext?.extra,\n    },\n  });\n}\n\n/**\n * Set user context for Sentry\n */\nexport function setUserContext(user: {\n  id?: string;\n  email?: string;\n  username?: string;\n  name?: string;\n}): void {\n  Sentry.setUser({\n    id: user.id,\n    email: user.email,\n    username: user.username || user.name,\n  });\n}\n\n/**\n * Clear user context (e.g., on logout)\n */\nexport function clearUserContext(): void {\n  Sentry.setUser(null);\n}\n\n/**\n * Add breadcrumb for debugging\n */\nexport function addBreadcrumb(\n  message: string,\n  category?: string,\n  level?: Sentry.SeverityLevel,\n  data?: Record<string, unknown>\n): void {\n  Sentry.addBreadcrumb({\n    message,\n    category: category || \"default\",\n    level: level || \"info\",\n    data,\n  });\n}\n\n/**\n * Wrap an async function to automatically capture errors\n */\nexport function withErrorReporting<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): T {\n  return (async (...args: any[]) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      reportError(error, context);\n      throw error; // Re-throw to maintain original behavior\n    }\n  }) as T;\n}\n\n/**\n * Wrap a sync function to automatically capture errors\n */\nexport function withErrorReportingSync<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): T {\n  return ((...args: any[]) => {\n    try {\n      return fn(...args);\n    } catch (error) {\n      reportError(error, context);\n      throw error; // Re-throw to maintain original behavior\n    }\n  }) as T;\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;AAED;;AAKO,SAAS,YACd,KAAsB,EACtB,OASC;IAED,IAAI,iBAAiB,OAAO;QAC1B,2LAAuB,CAAC,OAAO;YAC7B,MAAM,SAAS;YACf,OAAO,SAAS;YAChB,OAAO,SAAS,SAAS;YACzB,MAAM,SAAS;QACjB;IACF,OAAO;QACL,wDAAwD;QACxD,MAAM,eAAe,OAAO,UAAU,WAAW,QAAQ,KAAK,SAAS,CAAC;QACxE,2LAAuB,CAAC,IAAI,MAAM,eAAe;YAC/C,MAAM,SAAS;YACf,OAAO;gBAAE,eAAe;gBAAO,GAAG,SAAS,KAAK;YAAC;YACjD,OAAO,SAAS,SAAS;YACzB,MAAM,SAAS;QACjB;IACF;AACF;AAKO,SAAS,cACd,OAAe,EACf,OAGC;IAED,yLAAqB,CAAC,SAAS;QAC7B,OAAO;QACP,MAAM,SAAS;QACf,OAAO,SAAS;IAClB;AACF;AAKO,SAAS,eACd,KAAsB,EACtB,UAMC,EACD,iBAGC;IAED,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;IAErE,YAAY,OAAO;QACjB,MAAM;YACJ,YAAY;YACZ,cAAc,WAAW,QAAQ;YACjC,YAAY,WAAW,MAAM,IAAI;YACjC,GAAG,mBAAmB,IAAI;QAC5B;QACA,OAAO;YACL,cAAc,WAAW,QAAQ;YACjC,YAAY,WAAW,MAAM;YAC7B,aAAa,WAAW,UAAU;YAClC,eAAe,WAAW,YAAY;YACtC,cAAc,WAAW,WAAW;YACpC,GAAG,mBAAmB,KAAK;QAC7B;IACF;AACF;AAKO,SAAS,eAAe,IAK9B;IACC,kLAAc,CAAC;QACb,IAAI,KAAK,EAAE;QACX,OAAO,KAAK,KAAK;QACjB,UAAU,KAAK,QAAQ,IAAI,KAAK,IAAI;IACtC;AACF;AAKO,SAAS;IACd,kLAAc,CAAC;AACjB;AAKO,SAAS,cACd,OAAe,EACf,QAAiB,EACjB,KAA4B,EAC5B,IAA8B;IAE9B,wLAAoB,CAAC;QACnB;QACA,UAAU,YAAY;QACtB,OAAO,SAAS;QAChB;IACF;AACF;AAKO,SAAS,mBACd,EAAK,EACL,OAGC;IAED,OAAQ,OAAO,GAAG;QAChB,IAAI;YACF,OAAO,MAAM,MAAM;QACrB,EAAE,OAAO,OAAO;YACd,YAAY,OAAO;YACnB,MAAM,OAAO,yCAAyC;QACxD;IACF;AACF;AAKO,SAAS,uBACd,EAAK,EACL,OAGC;IAED,OAAQ,CAAC,GAAG;QACV,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAO;YACd,YAAY,OAAO;YACnB,MAAM,OAAO,yCAAyC;QACxD;IACF;AACF"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/lib/redis-session.ts"],"sourcesContent":["import { createClient } from 'redis';\nimport { reportError } from './sentry';\n\n// Redis client singleton\nlet redisClient: ReturnType<typeof createClient> | null = null;\n\nexport async function getRedisClient() {\n  if (redisClient && redisClient.isOpen) {\n    return redisClient;\n  }\n\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n  redisClient = createClient({ url: redisUrl });\n\n  redisClient.on('error', (err) => {\n    reportError(err, {\n      tags: { error_type: 'redis_connection', operation: 'redis_client_error' },\n      level: 'error',\n    });\n  });\n  redisClient.on('connect', () => {\n    // Only log in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Redis Client Connected');\n    }\n  });\n\n  if (!redisClient.isOpen) {\n    await redisClient.connect();\n  }\n\n  return redisClient;\n}\n\nexport interface TokenSession {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpiryTime: number;\n  provider: 'azure-ad' | 'keycloak';\n  userEmail?: string;\n  userId?: string;\n}\n\nconst SESSION_PREFIX = 'session:';\nconst TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days\n\n/**\n * Store IdP tokens in Redis, keyed by session ID\n */\nexport async function storeTokenSession(\n  sessionId: string,\n  tokens: TokenSession\n): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));\n}\n\n/**\n * Retrieve IdP tokens from Redis by session ID\n */\nexport async function getTokenSession(\n  sessionId: string\n): Promise<TokenSession | null> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  const data = await client.get(key);\n  if (!data) return null;\n  return JSON.parse(data) as TokenSession;\n}\n\n/**\n * Delete token session from Redis\n */\nexport async function deleteTokenSession(sessionId: string): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.del(key);\n}\n\n/**\n * Update access token (for refresh scenarios)\n */\nexport async function updateAccessToken(\n  sessionId: string,\n  accessToken: string,\n  accessTokenExpiryTime: number\n): Promise<void> {\n  const session = await getTokenSession(sessionId);\n  if (!session) {\n    throw new Error('Session not found');\n  }\n  await storeTokenSession(sessionId, {\n    ...session,\n    accessToken,\n    accessTokenExpiryTime,\n  });\n}\n\n/**\n * Get account tokens from NextAuth Account format\n * Maps NextAuth Account to TokenSession format for compatibility\n */\nexport async function getAccountTokensFromNextAuth(\n  userId: string,\n  provider: string = 'azure-ad'\n): Promise<TokenSession | null> {\n  const client = await getRedisClient();\n  const accountKey = `nextauth:account:user:${userId}:${provider}`;\n  const accountRefKey = await client.get(accountKey);\n  if (!accountRefKey) return null;\n\n  const accountData = await client.get(accountRefKey);\n  if (!accountData) return null;\n\n  const account = JSON.parse(accountData) as {\n    access_token?: string;\n    refresh_token?: string;\n    expires_at?: number;\n    provider: string;\n    providerAccountId: string;\n  };\n\n  if (!account.access_token) return null;\n\n  return {\n    accessToken: account.access_token,\n    refreshToken: account.refresh_token || '',\n    accessTokenExpiryTime: account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000,\n    provider: account.provider as 'azure-ad' | 'keycloak',\n    userId,\n  };\n}\n\n/**\n * Update NextAuth Account tokens (for refresh scenarios)\n */\nexport async function updateNextAuthAccountTokens(\n  userId: string,\n  provider: string,\n  accessToken: string,\n  refreshToken: string,\n  expiresAt: number\n): Promise<void> {\n  const client = await getRedisClient();\n  const accountKey = `nextauth:account:user:${userId}:${provider}`;\n  const accountRefKey = await client.get(accountKey);\n  if (!accountRefKey) {\n    throw new Error(`Account not found for user ${userId} and provider ${provider}`);\n  }\n\n  const accountData = await client.get(accountRefKey);\n  if (!accountData) {\n    throw new Error(`Account data not found for user ${userId} and provider ${provider}`);\n  }\n\n  const account = JSON.parse(accountData) as {\n    access_token?: string;\n    refresh_token?: string;\n    expires_at?: number;\n    [key: string]: any;\n  };\n\n  const updatedAccount = {\n    ...account,\n    access_token: accessToken,\n    refresh_token: refreshToken,\n    expires_at: Math.floor(expiresAt / 1000), // Convert to seconds\n  };\n\n  await client.setEx(accountRefKey, 30 * 24 * 60 * 60, JSON.stringify(updatedAccount));\n  logger.debug('[RedisSession] Updated NextAuth account tokens', { userId, provider });\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/app/api/proxy/%5B...path%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\nimport { getTokenSession, updateAccessToken, storeTokenSession } from '@/lib/redis-session';\nimport { reportApiError } from '@/lib/sentry';\n\n// All services are now consolidated into the unified onboarding-api\nconst UNIFIED_API_TARGET = process.env.PROXY_TARGET || process.env.ONBOARDING_TARGET || 'http://localhost:8001';\nconst AUTH_TARGET = process.env.PROXY_TARGET_AUTH || process.env.AUTH_TARGET || 'http://localhost:8090';\nconst ENTITY_CONFIG_TARGET = process.env.ENTITY_CONFIG_TARGET || process.env.NEXT_PUBLIC_ENTITY_CONFIG_API_BASE_URL || 'http://localhost:8003';\n\nfunction resolveUpstream(pathname: string, search: string) {\n  // All services are now consolidated into the unified onboarding-api\n  // Route /api/users/* to authentication service (if separate)\n  // Route entity config endpoints to entity configuration service\n  // Everything else goes to unified API\n  const afterProxy = pathname.split('/api/proxy')[1] || '';\n\n  // Route /api/users/* and /api/v1/users/* to unified API\n  // Authentication service may not be running, so route to unified API\n  if (afterProxy.startsWith('/api/users') || afterProxy.startsWith('/api/v1/users')) {\n    // Convert /api/users to /api/v1/users for unified API\n    let unifiedPath = afterProxy;\n    if (afterProxy.startsWith('/api/users')) {\n      unifiedPath = afterProxy.replace('/api/users', '/api/v1/users');\n    }\n    return `${UNIFIED_API_TARGET}${unifiedPath}${search}`;\n  }\n\n  // Route /api/roles and /api/v1/roles to unified API\n  // Authentication service may not be running, so route to unified API\n  if (afterProxy.startsWith('/api/roles') || afterProxy.startsWith('/api/v1/roles')) {\n    // Convert /api/roles to /api/v1/roles for unified API\n    let unifiedPath = afterProxy;\n    if (afterProxy.startsWith('/api/roles')) {\n      unifiedPath = afterProxy.replace('/api/roles', '/api/v1/roles');\n    }\n    return `${UNIFIED_API_TARGET}${unifiedPath}${search}`;\n  }\n\n  // Route checklists endpoints to unified API\n  if (afterProxy.startsWith('/api/v1/checklists')) {\n    return `${UNIFIED_API_TARGET}${afterProxy}${search}`;\n  }\n\n  // Route entity configuration endpoints\n  // Wizard configurations are in the unified API (8001), others go to entity config service (8003)\n  if (afterProxy.startsWith('/api/v1/wizardconfigurations')) {\n    // Wizard configurations are in the unified onboarding-api\n    return `${UNIFIED_API_TARGET}${afterProxy}${search}`;\n  }\n  \n  // Route other entity config endpoints to entity config service\n  // These include: /api/v1/entity-types, /api/v1/requirements, /api/v1/permissions\n  // NOTE: If entity config service (8003) is not running, route to unified API as fallback\n  if (afterProxy.startsWith('/api/v1/entity-types') || \n      afterProxy.startsWith('/api/v1/requirements') ||\n      afterProxy.startsWith('/api/v1/permissions')) {\n    // Try entity config service first, but fallback to unified API if service unavailable\n    // This allows graceful degradation when entity config service is down\n    return `${ENTITY_CONFIG_TARGET}${afterProxy}${search}`;\n  }\n\n  // All other routes go to unified onboarding-api\n  return `${UNIFIED_API_TARGET}${afterProxy}${search}`;\n}\n\nasync function forward(req: NextRequest) {\n  const url = resolveUpstream(req.nextUrl.pathname, req.nextUrl.search);\n\n  const headers: Record<string, string> = {};\n  \n  // Get NextAuth session token from httpOnly cookie (BFF pattern)\n  // sessionId is stored in JWT cookie, never exposed to client-side JS\n  let accessToken: string | null = null;\n  try {\n    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });\n    if (token?.sessionId) {\n      // Fetch tokens from Redis using sessionId from httpOnly JWT cookie\n      const tokenSession = await getTokenSession(token.sessionId as string);\n      if (tokenSession) {\n        // Check if token needs refresh (within 60 seconds of expiry)\n        const needsRefresh = !tokenSession.accessTokenExpiryTime || \n                            Date.now() >= tokenSession.accessTokenExpiryTime - 60 * 1000;\n        \n        if (needsRefresh && tokenSession.refreshToken) {\n          // Token expired or expiring soon - refresh it automatically\n          try {\n            const issuer = process.env.NEXT_PUBLIC_AZURE_AD_ISSUER || \n                          `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;\n            \n            const refreshResponse = await fetch(`${issuer}/oauth2/v2.0/token`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n              },\n              body: new URLSearchParams({\n                client_id: process.env.AZURE_AD_CLIENT_ID!,\n                grant_type: 'refresh_token',\n                refresh_token: tokenSession.refreshToken,\n                client_secret: process.env.AZURE_AD_CLIENT_SECRET!,\n              }),\n            });\n\n            if (refreshResponse.ok) {\n              const refreshedTokens = await refreshResponse.json();\n              const newAccessToken = refreshedTokens.access_token;\n              const newRefreshToken = refreshedTokens.refresh_token ?? tokenSession.refreshToken;\n              const newExpiryTime = Date.now() + (refreshedTokens.expires_in * 1000);\n\n              // Update Redis with new tokens\n              await storeTokenSession(token.sessionId, {\n                ...tokenSession,\n                accessToken: newAccessToken,\n                refreshToken: newRefreshToken,\n                accessTokenExpiryTime: newExpiryTime,\n              });\n\n              accessToken = newAccessToken;\n            } else {\n              // Refresh failed - use existing token and let backend handle 401\n              accessToken = tokenSession.accessToken;\n            }\n          } catch (refreshError) {\n            // Refresh failed - use existing token\n            reportApiError(refreshError, {\n              endpoint: url,\n              method: req.method,\n            }, {\n              tags: { error_type: 'proxy_token_refresh' },\n            });\n            accessToken = tokenSession.accessToken;\n          }\n        } else {\n          // Token still valid\n          accessToken = tokenSession.accessToken;\n        }\n      }\n    }\n  } catch (error) {\n    reportApiError(error, {\n      endpoint: url,\n      method: req.method,\n    }, {\n      tags: { error_type: 'proxy_token_retrieval' },\n    });\n    // Continue without token - backend will return 401 if auth required\n  }\n  \n  // Inject Authorization header from Redis-stored token (do NOT forward from client)\n  if (accessToken) {\n    headers['authorization'] = `Bearer ${accessToken}`;\n    headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n  \n  const contentType = req.headers.get('content-type') || req.headers.get('Content-Type');\n  if (contentType) {\n    headers['content-type'] = contentType;\n    headers['Content-Type'] = contentType;\n  } else {\n    headers['content-type'] = 'application/json';\n    headers['Content-Type'] = 'application/json';\n  }\n\n  // Forward user identification headers to backend services\n  const userHeaders = ['X-User-Id', 'X-User-Email', 'X-User-Name', 'X-User-Role'];\n  for (const headerName of userHeaders) {\n    const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());\n    if (value) {\n      headers[headerName] = value;\n      headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility\n    }\n  }\n\n  // Add additional headers for better debugging\n  headers['user-agent'] = 'NextJS-Proxy/1.0';\n\n  const init: RequestInit = {\n    method: req.method,\n    headers,\n    body: ['GET','HEAD'].includes(req.method) ? undefined : await req.text(),\n    redirect: 'manual'\n  };\n\n  try {\n    const res = await fetch(url, init);\n    const body = await res.arrayBuffer();\n\n    const respHeaders = new Headers();\n    res.headers.forEach((v, k) => respHeaders.set(k, v));\n    // ensure CORS for browser even though this is same-origin\n    respHeaders.set('Access-Control-Allow-Origin', '*');\n    respHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');\n    respHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');\n\n    return new NextResponse(body, { status: res.status, headers: respHeaders });\n  } catch (error) {\n    reportApiError(error, {\n      endpoint: url,\n      method: req.method,\n    }, {\n      tags: { error_type: 'proxy_request' },\n    });\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    // If it's a connection error, try fallback for entity config endpoints or auth service\n    if (errorMessage.includes('ECONNREFUSED') || errorMessage.includes('fetch failed')) {\n      const afterProxy = req.nextUrl.pathname.split('/api/proxy')[1] || '';\n      \n      // If authentication service is down and this is a roles/users endpoint, try unified API as fallback\n      if (url.includes(AUTH_TARGET) && \n          (afterProxy.startsWith('/api/roles') || \n           afterProxy.startsWith('/api/v1/roles') ||\n           afterProxy.startsWith('/api/users') ||\n           afterProxy.startsWith('/api/v1/users'))) {\n        // Fallback to unified API - convert /api/roles to /api/v1/roles if needed\n        let fallbackPath = afterProxy;\n        if (afterProxy.startsWith('/api/roles')) {\n          fallbackPath = afterProxy.replace('/api/roles', '/api/v1/roles');\n        } else if (afterProxy.startsWith('/api/users')) {\n          fallbackPath = afterProxy.replace('/api/users', '/api/v1/users');\n        }\n        const fallbackUrl = `${UNIFIED_API_TARGET}${fallbackPath}${req.nextUrl.search}`;\n        try {\n          const fallbackRes = await fetch(fallbackUrl, init);\n          const fallbackBody = await fallbackRes.arrayBuffer();\n          const fallbackHeaders = new Headers();\n          fallbackRes.headers.forEach((v, k) => fallbackHeaders.set(k, v));\n          fallbackHeaders.set('Access-Control-Allow-Origin', '*');\n          fallbackHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');\n          fallbackHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');\n          return new NextResponse(fallbackBody, { status: fallbackRes.status, headers: fallbackHeaders });\n        } catch (fallbackError) {\n          // Both services failed - return helpful error\n          return new NextResponse(JSON.stringify({ \n            error: 'Backend service unavailable', \n            details: `Authentication Service (${AUTH_TARGET}) is not running. Please start the authentication service on port 8090, or ensure the Unified API (${UNIFIED_API_TARGET}) has the roles/users endpoints.`,\n            originalError: errorMessage,\n            attemptedFallback: fallbackUrl\n          }), { \n            status: 503, \n            headers: { 'Content-Type': 'application/json' }\n          });\n        }\n      }\n      \n      // If entity config service is down and this is an entity config endpoint, try unified API as fallback\n      if (url.includes(ENTITY_CONFIG_TARGET) && \n          (afterProxy.startsWith('/api/v1/requirements') || \n           afterProxy.startsWith('/api/v1/entity-types') ||\n           afterProxy.startsWith('/api/v1/permissions'))) {\n        // Fallback to unified API\n        const fallbackUrl = `${UNIFIED_API_TARGET}${afterProxy}${req.nextUrl.search}`;\n        try {\n          const fallbackRes = await fetch(fallbackUrl, init);\n          const fallbackBody = await fallbackRes.arrayBuffer();\n          const fallbackHeaders = new Headers();\n          fallbackRes.headers.forEach((v, k) => fallbackHeaders.set(k, v));\n          fallbackHeaders.set('Access-Control-Allow-Origin', '*');\n          fallbackHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');\n          fallbackHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');\n          return new NextResponse(fallbackBody, { status: fallbackRes.status, headers: fallbackHeaders });\n        } catch (fallbackError) {\n          // Both services failed - return helpful error\n          return new NextResponse(JSON.stringify({ \n            error: 'Backend service unavailable', \n            details: `Entity Configuration Service (${ENTITY_CONFIG_TARGET}) is not running. Please start the service on port 8003, or ensure the Unified API (${UNIFIED_API_TARGET}) has the requirements endpoint.`,\n            originalError: errorMessage,\n            attemptedFallback: fallbackUrl\n          }), { \n            status: 503, \n            headers: { 'Content-Type': 'application/json' }\n          });\n        }\n      }\n      \n      return new NextResponse(JSON.stringify({ \n        error: 'Backend service unavailable', \n        details: `Cannot connect to ${url}. Please ensure the backend service is running.`,\n        originalError: errorMessage\n      }), { \n        status: 503, \n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n    \n    return new NextResponse(JSON.stringify({ error: 'Proxy request failed', details: errorMessage }), { \n      status: 502, \n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n\nexport const GET = forward;\nexport const POST = forward;\nexport const PUT = forward;\nexport const PATCH = forward;\nexport const DELETE = forward;\nexport const OPTIONS = forward;\n\n"],"names":[],"mappings":"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"}}]
}