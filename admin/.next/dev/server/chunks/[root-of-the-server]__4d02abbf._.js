;!function(){try { var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]="ed784b8c-6b18-1154-eccb-5dc8beb51f23")}catch(e){}}();
module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/redis [external] (redis, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("redis", () => require("redis"));

module.exports = mod;
}),
"[externals]/perf_hooks [external] (perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("perf_hooks", () => require("perf_hooks"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/require-in-the-middle [external] (require-in-the-middle, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("require-in-the-middle", () => require("require-in-the-middle"));

module.exports = mod;
}),
"[externals]/import-in-the-middle [external] (import-in-the-middle, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("import-in-the-middle", () => require("import-in-the-middle"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/diagnostics_channel [external] (diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("diagnostics_channel", () => require("diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:os [external] (node:os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:os", () => require("node:os"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/node:readline [external] (node:readline, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:readline", () => require("node:readline"));

module.exports = mod;
}),
"[externals]/node:worker_threads [external] (node:worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:worker_threads", () => require("node:worker_threads"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:module [external] (node:module, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:module", () => require("node:module"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/module [external] (module, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("module", () => require("module"));

module.exports = mod;
}),
"[externals]/async_hooks [external] (async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/worker_threads [external] (worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("worker_threads", () => require("worker_threads"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/sentry.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Sentry error reporting utilities
 * Use these functions instead of console.error/warn for proper error tracking
 */ __turbopack_context__.s([
    "addBreadcrumb",
    ()=>addBreadcrumb,
    "clearUserContext",
    ()=>clearUserContext,
    "reportApiError",
    ()=>reportApiError,
    "reportError",
    ()=>reportError,
    "reportWarning",
    ()=>reportWarning,
    "setUserContext",
    ()=>setUserContext,
    "withErrorReporting",
    ()=>withErrorReporting,
    "withErrorReportingSync",
    ()=>withErrorReportingSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sentry/nextjs/build/cjs/index.server.js [app-route] (ecmascript)");
;
function reportError(error, context) {
    if (error instanceof Error) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureException"](error, {
            tags: context?.tags,
            extra: context?.extra,
            level: context?.level || "error",
            user: context?.user
        });
    } else {
        // For non-Error objects, create an Error from the value
        const errorMessage = typeof error === "string" ? error : JSON.stringify(error);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureException"](new Error(errorMessage), {
            tags: context?.tags,
            extra: {
                originalError: error,
                ...context?.extra
            },
            level: context?.level || "error",
            user: context?.user
        });
    }
}
function reportWarning(message, context) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureMessage"](message, {
        level: "warning",
        tags: context?.tags,
        extra: context?.extra
    });
}
function reportApiError(error, apiContext, additionalContext) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    reportError(error, {
        tags: {
            error_type: "api_error",
            api_endpoint: apiContext.endpoint,
            api_method: apiContext.method || "GET",
            ...additionalContext?.tags
        },
        extra: {
            api_endpoint: apiContext.endpoint,
            api_method: apiContext.method,
            status_code: apiContext.statusCode,
            response_body: apiContext.responseBody,
            request_body: apiContext.requestBody,
            ...additionalContext?.extra
        }
    });
}
function setUserContext(user) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUser"]({
        id: user.id,
        email: user.email,
        username: user.username || user.name
    });
}
function clearUserContext() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUser"](null);
}
function addBreadcrumb(message, category, level, data) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addBreadcrumb"]({
        message,
        category: category || "default",
        level: level || "info",
        data
    });
}
function withErrorReporting(fn, context) {
    return async (...args)=>{
        try {
            return await fn(...args);
        } catch (error) {
            reportError(error, context);
            throw error; // Re-throw to maintain original behavior
        }
    };
}
function withErrorReportingSync(fn, context) {
    return (...args)=>{
        try {
            return fn(...args);
        } catch (error) {
            reportError(error, context);
            throw error; // Re-throw to maintain original behavior
        }
    };
}
}),
"[project]/src/lib/redis-session.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteTokenSession",
    ()=>deleteTokenSession,
    "getAccountTokensFromNextAuth",
    ()=>getAccountTokensFromNextAuth,
    "getRedisClient",
    ()=>getRedisClient,
    "getTokenSession",
    ()=>getTokenSession,
    "storeTokenSession",
    ()=>storeTokenSession,
    "updateAccessToken",
    ()=>updateAccessToken,
    "updateNextAuthAccountTokens",
    ()=>updateNextAuthAccountTokens
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$redis__$5b$external$5d$__$28$redis$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/redis [external] (redis, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sentry.ts [app-route] (ecmascript)");
;
;
// Redis client singleton
let redisClient = null;
async function getRedisClient() {
    if (redisClient && redisClient.isOpen) {
        return redisClient;
    }
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    redisClient = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$redis__$5b$external$5d$__$28$redis$2c$__cjs$29$__["createClient"])({
        url: redisUrl
    });
    redisClient.on('error', (err)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
            tags: {
                error_type: 'redis_connection',
                operation: 'redis_client_error'
            },
            level: 'error'
        });
    });
    redisClient.on('connect', ()=>{
        // Only log in development
        if ("TURBOPACK compile-time truthy", 1) {
            console.log('Redis Client Connected');
        }
    });
    if (!redisClient.isOpen) {
        await redisClient.connect();
    }
    return redisClient;
}
const SESSION_PREFIX = 'session:';
const TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days
async function storeTokenSession(sessionId, tokens) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));
}
async function getTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    const data = await client.get(key);
    if (!data) return null;
    return JSON.parse(data);
}
async function deleteTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.del(key);
}
async function updateAccessToken(sessionId, accessToken, accessTokenExpiryTime) {
    const session = await getTokenSession(sessionId);
    if (!session) {
        throw new Error('Session not found');
    }
    await storeTokenSession(sessionId, {
        ...session,
        accessToken,
        accessTokenExpiryTime
    });
}
async function getAccountTokensFromNextAuth(userId, provider = 'azure-ad') {
    const client = await getRedisClient();
    const accountKey = `nextauth:account:user:${userId}:${provider}`;
    const accountRefKey = await client.get(accountKey);
    if (!accountRefKey) return null;
    const accountData = await client.get(accountRefKey);
    if (!accountData) return null;
    const account = JSON.parse(accountData);
    if (!account.access_token) return null;
    return {
        accessToken: account.access_token,
        refreshToken: account.refresh_token || '',
        accessTokenExpiryTime: account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000,
        provider: account.provider,
        userId
    };
}
async function updateNextAuthAccountTokens(userId, provider, accessToken, refreshToken, expiresAt) {
    const client = await getRedisClient();
    const accountKey = `nextauth:account:user:${userId}:${provider}`;
    const accountRefKey = await client.get(accountKey);
    if (!accountRefKey) {
        throw new Error(`Account not found for user ${userId} and provider ${provider}`);
    }
    const accountData = await client.get(accountRefKey);
    if (!accountData) {
        throw new Error(`Account data not found for user ${userId} and provider ${provider}`);
    }
    const account = JSON.parse(accountData);
    const updatedAccount = {
        ...account,
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_at: Math.floor(expiresAt / 1000)
    };
    await client.setEx(accountRefKey, 30 * 24 * 60 * 60, JSON.stringify(updatedAccount));
    logger.debug('[RedisSession] Updated NextAuth account tokens', {
        userId,
        provider
    });
}
}),
"[project]/src/app/api/proxy/[...path]/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DELETE",
    ()=>DELETE,
    "GET",
    ()=>GET,
    "OPTIONS",
    ()=>OPTIONS,
    "PATCH",
    ()=>PATCH,
    "POST",
    ()=>POST,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/jwt.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/core/jwt.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-session.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sentry.ts [app-route] (ecmascript)");
;
;
;
;
// All services are now consolidated into the unified onboarding-api
const UNIFIED_API_TARGET = process.env.PROXY_TARGET || process.env.ONBOARDING_TARGET || 'http://localhost:8001';
const AUTH_TARGET = process.env.PROXY_TARGET_AUTH || process.env.AUTH_TARGET || 'http://localhost:8090';
const ENTITY_CONFIG_TARGET = process.env.ENTITY_CONFIG_TARGET || process.env.NEXT_PUBLIC_ENTITY_CONFIG_API_BASE_URL || 'http://localhost:8003';
function resolveUpstream(pathname, search) {
    // All services are now consolidated into the unified onboarding-api
    // Route /api/users/* to authentication service (if separate)
    // Route entity config endpoints to entity configuration service
    // Everything else goes to unified API
    const afterProxy = pathname.split('/api/proxy')[1] || '';
    // Route /api/users/* and /api/v1/users/* to unified API
    // Authentication service may not be running, so route to unified API
    if (afterProxy.startsWith('/api/users') || afterProxy.startsWith('/api/v1/users')) {
        // Convert /api/users to /api/v1/users for unified API
        let unifiedPath = afterProxy;
        if (afterProxy.startsWith('/api/users')) {
            unifiedPath = afterProxy.replace('/api/users', '/api/v1/users');
        }
        return `${UNIFIED_API_TARGET}${unifiedPath}${search}`;
    }
    // Route /api/roles and /api/v1/roles to unified API
    // Authentication service may not be running, so route to unified API
    if (afterProxy.startsWith('/api/roles') || afterProxy.startsWith('/api/v1/roles')) {
        // Convert /api/roles to /api/v1/roles for unified API
        let unifiedPath = afterProxy;
        if (afterProxy.startsWith('/api/roles')) {
            unifiedPath = afterProxy.replace('/api/roles', '/api/v1/roles');
        }
        return `${UNIFIED_API_TARGET}${unifiedPath}${search}`;
    }
    // Route checklists endpoints to unified API
    if (afterProxy.startsWith('/api/v1/checklists')) {
        return `${UNIFIED_API_TARGET}${afterProxy}${search}`;
    }
    // Route entity configuration endpoints
    // Wizard configurations are in the unified API (8001), others go to entity config service (8003)
    if (afterProxy.startsWith('/api/v1/wizardconfigurations')) {
        // Wizard configurations are in the unified onboarding-api
        return `${UNIFIED_API_TARGET}${afterProxy}${search}`;
    }
    // Route other entity config endpoints to entity config service
    // These include: /api/v1/entity-types, /api/v1/requirements, /api/v1/permissions
    // NOTE: If entity config service (8003) is not running, route to unified API as fallback
    if (afterProxy.startsWith('/api/v1/entity-types') || afterProxy.startsWith('/api/v1/requirements') || afterProxy.startsWith('/api/v1/permissions')) {
        // Try entity config service first, but fallback to unified API if service unavailable
        // This allows graceful degradation when entity config service is down
        return `${ENTITY_CONFIG_TARGET}${afterProxy}${search}`;
    }
    // All other routes go to unified onboarding-api
    return `${UNIFIED_API_TARGET}${afterProxy}${search}`;
}
async function forward(req) {
    const url = resolveUpstream(req.nextUrl.pathname, req.nextUrl.search);
    const headers = {};
    // Get NextAuth session token from httpOnly cookie (BFF pattern)
    // sessionId is stored in JWT cookie, never exposed to client-side JS
    let accessToken = null;
    try {
        const token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getToken"])({
            req,
            secret: process.env.NEXTAUTH_SECRET
        });
        if (token?.sessionId) {
            // Fetch tokens from Redis using sessionId from httpOnly JWT cookie
            const tokenSession = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getTokenSession"])(token.sessionId);
            if (tokenSession) {
                // Check if token needs refresh (within 60 seconds of expiry)
                const needsRefresh = !tokenSession.accessTokenExpiryTime || Date.now() >= tokenSession.accessTokenExpiryTime - 60 * 1000;
                if (needsRefresh && tokenSession.refreshToken) {
                    // Token expired or expiring soon - refresh it automatically
                    try {
                        const issuer = ("TURBOPACK compile-time value", "https://login.microsoftonline.com/dd5a90ad-b0ae-463b-bef5-5bae77f1adf2/v2.0") || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;
                        const refreshResponse = await fetch(`${issuer}/oauth2/v2.0/token`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded'
                            },
                            body: new URLSearchParams({
                                client_id: process.env.AZURE_AD_CLIENT_ID,
                                grant_type: 'refresh_token',
                                refresh_token: tokenSession.refreshToken,
                                client_secret: process.env.AZURE_AD_CLIENT_SECRET
                            })
                        });
                        if (refreshResponse.ok) {
                            const refreshedTokens = await refreshResponse.json();
                            const newAccessToken = refreshedTokens.access_token;
                            const newRefreshToken = refreshedTokens.refresh_token ?? tokenSession.refreshToken;
                            const newExpiryTime = Date.now() + refreshedTokens.expires_in * 1000;
                            // Update Redis with new tokens
                            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["storeTokenSession"])(token.sessionId, {
                                ...tokenSession,
                                accessToken: newAccessToken,
                                refreshToken: newRefreshToken,
                                accessTokenExpiryTime: newExpiryTime
                            });
                            accessToken = newAccessToken;
                        } else {
                            // Refresh failed - use existing token and let backend handle 401
                            accessToken = tokenSession.accessToken;
                        }
                    } catch (refreshError) {
                        // Refresh failed - use existing token
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportApiError"])(refreshError, {
                            endpoint: url,
                            method: req.method
                        }, {
                            tags: {
                                error_type: 'proxy_token_refresh'
                            }
                        });
                        accessToken = tokenSession.accessToken;
                    }
                } else {
                    // Token still valid
                    accessToken = tokenSession.accessToken;
                }
            }
        }
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportApiError"])(error, {
            endpoint: url,
            method: req.method
        }, {
            tags: {
                error_type: 'proxy_token_retrieval'
            }
        });
    // Continue without token - backend will return 401 if auth required
    }
    // Inject Authorization header from Redis-stored token (do NOT forward from client)
    if (accessToken) {
        headers['authorization'] = `Bearer ${accessToken}`;
        headers['Authorization'] = `Bearer ${accessToken}`;
    }
    const contentType = req.headers.get('content-type') || req.headers.get('Content-Type');
    if (contentType) {
        headers['content-type'] = contentType;
        headers['Content-Type'] = contentType;
    } else {
        headers['content-type'] = 'application/json';
        headers['Content-Type'] = 'application/json';
    }
    // Forward user identification headers to backend services
    const userHeaders = [
        'X-User-Id',
        'X-User-Email',
        'X-User-Name',
        'X-User-Role'
    ];
    for (const headerName of userHeaders){
        const value = req.headers.get(headerName) || req.headers.get(headerName.toLowerCase());
        if (value) {
            headers[headerName] = value;
            headers[headerName.toLowerCase()] = value; // Also set lowercase for compatibility
        }
    }
    // Add additional headers for better debugging
    headers['user-agent'] = 'NextJS-Proxy/1.0';
    const init = {
        method: req.method,
        headers,
        body: [
            'GET',
            'HEAD'
        ].includes(req.method) ? undefined : await req.text(),
        redirect: 'manual'
    };
    try {
        const res = await fetch(url, init);
        const body = await res.arrayBuffer();
        const respHeaders = new Headers();
        res.headers.forEach((v, k)=>respHeaders.set(k, v));
        // ensure CORS for browser even though this is same-origin
        respHeaders.set('Access-Control-Allow-Origin', '*');
        respHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
        respHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](body, {
            status: res.status,
            headers: respHeaders
        });
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportApiError"])(error, {
            endpoint: url,
            method: req.method
        }, {
            tags: {
                error_type: 'proxy_request'
            }
        });
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        // If it's a connection error, try fallback for entity config endpoints or auth service
        if (errorMessage.includes('ECONNREFUSED') || errorMessage.includes('fetch failed')) {
            const afterProxy = req.nextUrl.pathname.split('/api/proxy')[1] || '';
            // If authentication service is down and this is a roles/users endpoint, try unified API as fallback
            if (url.includes(AUTH_TARGET) && (afterProxy.startsWith('/api/roles') || afterProxy.startsWith('/api/v1/roles') || afterProxy.startsWith('/api/users') || afterProxy.startsWith('/api/v1/users'))) {
                // Fallback to unified API - convert /api/roles to /api/v1/roles if needed
                let fallbackPath = afterProxy;
                if (afterProxy.startsWith('/api/roles')) {
                    fallbackPath = afterProxy.replace('/api/roles', '/api/v1/roles');
                } else if (afterProxy.startsWith('/api/users')) {
                    fallbackPath = afterProxy.replace('/api/users', '/api/v1/users');
                }
                const fallbackUrl = `${UNIFIED_API_TARGET}${fallbackPath}${req.nextUrl.search}`;
                try {
                    const fallbackRes = await fetch(fallbackUrl, init);
                    const fallbackBody = await fallbackRes.arrayBuffer();
                    const fallbackHeaders = new Headers();
                    fallbackRes.headers.forEach((v, k)=>fallbackHeaders.set(k, v));
                    fallbackHeaders.set('Access-Control-Allow-Origin', '*');
                    fallbackHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
                    fallbackHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](fallbackBody, {
                        status: fallbackRes.status,
                        headers: fallbackHeaders
                    });
                } catch (fallbackError) {
                    // Both services failed - return helpful error
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
                        error: 'Backend service unavailable',
                        details: `Authentication Service (${AUTH_TARGET}) is not running. Please start the authentication service on port 8090, or ensure the Unified API (${UNIFIED_API_TARGET}) has the roles/users endpoints.`,
                        originalError: errorMessage,
                        attemptedFallback: fallbackUrl
                    }), {
                        status: 503,
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                }
            }
            // If entity config service is down and this is an entity config endpoint, try unified API as fallback
            if (url.includes(ENTITY_CONFIG_TARGET) && (afterProxy.startsWith('/api/v1/requirements') || afterProxy.startsWith('/api/v1/entity-types') || afterProxy.startsWith('/api/v1/permissions'))) {
                // Fallback to unified API
                const fallbackUrl = `${UNIFIED_API_TARGET}${afterProxy}${req.nextUrl.search}`;
                try {
                    const fallbackRes = await fetch(fallbackUrl, init);
                    const fallbackBody = await fallbackRes.arrayBuffer();
                    const fallbackHeaders = new Headers();
                    fallbackRes.headers.forEach((v, k)=>fallbackHeaders.set(k, v));
                    fallbackHeaders.set('Access-Control-Allow-Origin', '*');
                    fallbackHeaders.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
                    fallbackHeaders.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-User-Id, X-User-Email, X-User-Name, X-User-Role');
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](fallbackBody, {
                        status: fallbackRes.status,
                        headers: fallbackHeaders
                    });
                } catch (fallbackError) {
                    // Both services failed - return helpful error
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
                        error: 'Backend service unavailable',
                        details: `Entity Configuration Service (${ENTITY_CONFIG_TARGET}) is not running. Please start the service on port 8003, or ensure the Unified API (${UNIFIED_API_TARGET}) has the requirements endpoint.`,
                        originalError: errorMessage,
                        attemptedFallback: fallbackUrl
                    }), {
                        status: 503,
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                }
            }
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
                error: 'Backend service unavailable',
                details: `Cannot connect to ${url}. Please ensure the backend service is running.`,
                originalError: errorMessage
            }), {
                status: 503,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](JSON.stringify({
            error: 'Proxy request failed',
            details: errorMessage
        }), {
            status: 502,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    }
}
const GET = forward;
const POST = forward;
const PUT = forward;
const PATCH = forward;
const DELETE = forward;
const OPTIONS = forward;
}),
];

//# debugId=ed784b8c-6b18-1154-eccb-5dc8beb51f23
//# sourceMappingURL=%5Broot-of-the-server%5D__4d02abbf._.js.map