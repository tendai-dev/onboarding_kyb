;!function(){try { var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]="6cea137c-3655-122a-1bf0-ef918db55e7a")}catch(e){}}();
module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/redis [external] (redis, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("redis", () => require("redis"));

module.exports = mod;
}),
"[externals]/perf_hooks [external] (perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("perf_hooks", () => require("perf_hooks"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/require-in-the-middle [external] (require-in-the-middle, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("require-in-the-middle", () => require("require-in-the-middle"));

module.exports = mod;
}),
"[externals]/import-in-the-middle [external] (import-in-the-middle, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("import-in-the-middle", () => require("import-in-the-middle"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/diagnostics_channel [external] (diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("diagnostics_channel", () => require("diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:os [external] (node:os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:os", () => require("node:os"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/node:readline [external] (node:readline, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:readline", () => require("node:readline"));

module.exports = mod;
}),
"[externals]/node:worker_threads [external] (node:worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:worker_threads", () => require("node:worker_threads"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:module [external] (node:module, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:module", () => require("node:module"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/module [external] (module, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("module", () => require("module"));

module.exports = mod;
}),
"[externals]/async_hooks [external] (async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("async_hooks", () => require("async_hooks"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/worker_threads [external] (worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("worker_threads", () => require("worker_threads"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/sentry.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Sentry error reporting utilities
 * Use these functions instead of console.error/warn for proper error tracking
 */ __turbopack_context__.s([
    "addBreadcrumb",
    ()=>addBreadcrumb,
    "clearUserContext",
    ()=>clearUserContext,
    "reportApiError",
    ()=>reportApiError,
    "reportError",
    ()=>reportError,
    "reportWarning",
    ()=>reportWarning,
    "setUserContext",
    ()=>setUserContext,
    "withErrorReporting",
    ()=>withErrorReporting,
    "withErrorReportingSync",
    ()=>withErrorReportingSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sentry/nextjs/build/cjs/index.server.js [app-route] (ecmascript)");
;
function reportError(error, context) {
    if (error instanceof Error) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureException"](error, {
            tags: context?.tags,
            extra: context?.extra,
            level: context?.level || "error",
            user: context?.user
        });
    } else {
        // For non-Error objects, create an Error from the value
        const errorMessage = typeof error === "string" ? error : JSON.stringify(error);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureException"](new Error(errorMessage), {
            tags: context?.tags,
            extra: {
                originalError: error,
                ...context?.extra
            },
            level: context?.level || "error",
            user: context?.user
        });
    }
}
function reportWarning(message, context) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["captureMessage"](message, {
        level: "warning",
        tags: context?.tags,
        extra: context?.extra
    });
}
function reportApiError(error, apiContext, additionalContext) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    reportError(error, {
        tags: {
            error_type: "api_error",
            api_endpoint: apiContext.endpoint,
            api_method: apiContext.method || "GET",
            ...additionalContext?.tags
        },
        extra: {
            api_endpoint: apiContext.endpoint,
            api_method: apiContext.method,
            status_code: apiContext.statusCode,
            response_body: apiContext.responseBody,
            request_body: apiContext.requestBody,
            ...additionalContext?.extra
        }
    });
}
function setUserContext(user) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUser"]({
        id: user.id,
        email: user.email,
        username: user.username || user.name
    });
}
function clearUserContext() {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUser"](null);
}
function addBreadcrumb(message, category, level, data) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sentry$2f$nextjs$2f$build$2f$cjs$2f$index$2e$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addBreadcrumb"]({
        message,
        category: category || "default",
        level: level || "info",
        data
    });
}
function withErrorReporting(fn, context) {
    return async (...args)=>{
        try {
            return await fn(...args);
        } catch (error) {
            reportError(error, context);
            throw error; // Re-throw to maintain original behavior
        }
    };
}
function withErrorReportingSync(fn, context) {
    return (...args)=>{
        try {
            return fn(...args);
        } catch (error) {
            reportError(error, context);
            throw error; // Re-throw to maintain original behavior
        }
    };
}
}),
"[project]/src/lib/logger.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Centralized logging utility
 * Replaces console.log/warn/error with proper logging that can be controlled
 * and integrated with Sentry in production
 */ __turbopack_context__.s([
    "Logger",
    ()=>Logger,
    "logger",
    ()=>logger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sentry.ts [app-route] (ecmascript)");
;
class Logger {
    isDevelopment = ("TURBOPACK compile-time value", "development") === 'development';
    isProduction = ("TURBOPACK compile-time value", "development") === 'production';
    /**
   * Log debug messages (only in development)
   */ debug(message, ...args) {
        if (this.isDevelopment) {
            // eslint-disable-next-line no-console
            console.debug(`[DEBUG] ${message}`, ...args);
        }
    }
    /**
   * Log info messages
   */ info(message, ...args) {
        if (this.isDevelopment) {
            // eslint-disable-next-line no-console
            console.info(`[INFO] ${message}`, ...args);
        }
        // Add breadcrumb in production for debugging
        if (this.isProduction) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addBreadcrumb"])(message, 'info', 'info', {
                args
            });
        }
    }
    /**
   * Log warning messages
   */ warn(message, options) {
        // eslint-disable-next-line no-console
        console.warn(`[WARN] ${message}`);
        // Report to Sentry in production
        if (this.isProduction) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportWarning"])(message, {
                tags: options?.tags,
                extra: options?.extra
            });
        }
    }
    /**
   * Log error messages
   */ error(error, message, options) {
        const errorMessage = message || (error instanceof Error ? error.message : String(error));
        // eslint-disable-next-line no-console
        console.error(`[ERROR] ${errorMessage}`, error);
        // Map LogLevel to Sentry.SeverityLevel
        const sentryLevel = options?.level === 'warn' ? 'warning' : options?.level === 'error' ? 'error' : options?.level === 'info' ? 'info' : 'error';
        // Report to Sentry
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(error, {
            tags: options?.tags,
            extra: options?.extra,
            level: sentryLevel
        });
    }
    /**
   * Log with context (replaces console.log with structured logging)
   */ log(message, context, level = 'info') {
        if (this.isDevelopment) {
            // eslint-disable-next-line no-console
            console.log(`[${level.toUpperCase()}] ${message}`, context || '');
        }
        // Add breadcrumb in production
        if (this.isProduction && level !== 'debug') {
            const sentryLevel = level === 'warn' ? 'warning' : level === 'error' ? 'error' : 'info';
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addBreadcrumb"])(message, 'log', sentryLevel, context);
        }
    }
}
const logger = new Logger();
;
}),
"[project]/src/lib/redis-session.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteTokenSession",
    ()=>deleteTokenSession,
    "getAccountTokensFromNextAuth",
    ()=>getAccountTokensFromNextAuth,
    "getRedisClient",
    ()=>getRedisClient,
    "getTokenSession",
    ()=>getTokenSession,
    "storeTokenSession",
    ()=>storeTokenSession,
    "updateAccessToken",
    ()=>updateAccessToken,
    "updateNextAuthAccountTokens",
    ()=>updateNextAuthAccountTokens
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$redis__$5b$external$5d$__$28$redis$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/redis [external] (redis, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sentry.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/logger.ts [app-route] (ecmascript)");
;
;
;
// Redis client singleton
let redisClient = null;
async function getRedisClient() {
    if (redisClient && redisClient.isOpen) {
        return redisClient;
    }
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    redisClient = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$redis__$5b$external$5d$__$28$redis$2c$__cjs$29$__["createClient"])({
        url: redisUrl
    });
    redisClient.on('error', (err)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
            tags: {
                error_type: 'redis_connection',
                operation: 'redis_client_error'
            },
            level: 'error'
        });
    });
    redisClient.on('connect', ()=>{
        // Only log in development
        if ("TURBOPACK compile-time truthy", 1) {
            console.log('Redis Client Connected');
        }
    });
    if (!redisClient.isOpen) {
        await redisClient.connect();
    }
    return redisClient;
}
const SESSION_PREFIX = 'session:';
const TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days
async function storeTokenSession(sessionId, tokens) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));
}
async function getTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    const data = await client.get(key);
    if (!data) return null;
    return JSON.parse(data);
}
async function deleteTokenSession(sessionId) {
    const client = await getRedisClient();
    const key = `${SESSION_PREFIX}${sessionId}`;
    await client.del(key);
}
async function updateAccessToken(sessionId, accessToken, accessTokenExpiryTime) {
    const session = await getTokenSession(sessionId);
    if (!session) {
        throw new Error('Session not found');
    }
    await storeTokenSession(sessionId, {
        ...session,
        accessToken,
        accessTokenExpiryTime
    });
}
async function getAccountTokensFromNextAuth(userId, provider = 'azure-ad') {
    const client = await getRedisClient();
    const accountKey = `nextauth:account:user:${userId}:${provider}`;
    const accountRefKey = await client.get(accountKey);
    if (!accountRefKey) return null;
    const accountData = await client.get(accountRefKey);
    if (!accountData) return null;
    const account = JSON.parse(accountData);
    if (!account.access_token) return null;
    return {
        accessToken: account.access_token,
        refreshToken: account.refresh_token || '',
        accessTokenExpiryTime: account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000,
        provider: account.provider,
        userId
    };
}
async function updateNextAuthAccountTokens(userId, provider, accessToken, refreshToken, expiresAt) {
    const client = await getRedisClient();
    const accountKey = `nextauth:account:user:${userId}:${provider}`;
    const accountRefKey = await client.get(accountKey);
    if (!accountRefKey) {
        throw new Error(`Account not found for user ${userId} and provider ${provider}`);
    }
    const accountData = await client.get(accountRefKey);
    if (!accountData) {
        throw new Error(`Account data not found for user ${userId} and provider ${provider}`);
    }
    const account = JSON.parse(accountData);
    const updatedAccount = {
        ...account,
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_at: Math.floor(expiresAt / 1000)
    };
    await client.setEx(accountRefKey, 30 * 24 * 60 * 60, JSON.stringify(updatedAccount));
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisSession] Updated NextAuth account tokens', {
        userId,
        provider
    });
}
}),
"[project]/src/lib/redis-adapter.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Custom Redis Adapter for NextAuth v5
 * Implements NextAuth's Adapter interface to store sessions, accounts, and users in Redis
 * This enables database strategy with opaque session tokens instead of JWTs
 */ __turbopack_context__.s([
    "RedisAdapter",
    ()=>RedisAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-session.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/logger.ts [app-route] (ecmascript)");
;
;
// Redis key prefixes
const SESSION_PREFIX = 'nextauth:session:';
const ACCOUNT_PREFIX = 'nextauth:account:';
const USER_PREFIX = 'nextauth:user:';
const VERIFICATION_TOKEN_PREFIX = 'nextauth:verification-token:';
// TTLs (in seconds)
const SESSION_TTL = 30 * 24 * 60 * 60; // 30 days
const ACCOUNT_TTL = 30 * 24 * 60 * 60; // 30 days
const USER_TTL = 30 * 24 * 60 * 60; // 30 days
const VERIFICATION_TOKEN_TTL = 24 * 60 * 60; // 24 hours
function RedisAdapter() {
    return {
        // User operations
        async createUser (user) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const userId = `user-${Date.now()}-${Math.random().toString(36).substring(7)}`;
            const adapterUser = {
                ...user,
                id: userId,
                emailVerified: user.emailVerified || null
            };
            const key = `${USER_PREFIX}${userId}`;
            await client.setEx(key, USER_TTL, JSON.stringify(adapterUser));
            // Also index by email for getUserByEmail
            if (user.email) {
                const emailKey = `${USER_PREFIX}email:${user.email}`;
                await client.setEx(emailKey, USER_TTL, userId);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Created user', {
                userId,
                email: user.email
            });
            return adapterUser;
        },
        async getUser (id) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${USER_PREFIX}${id}`;
            const data = await client.get(key);
            if (!data) return null;
            return JSON.parse(data);
        },
        async getUserByEmail (email) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const emailKey = `${USER_PREFIX}email:${email}`;
            const userId = await client.get(emailKey);
            if (!userId) return null;
            return this.getUser(userId);
        },
        async getUserByAccount ({ providerAccountId, provider }) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const accountKey = `${ACCOUNT_PREFIX}${provider}:${providerAccountId}`;
            const accountData = await client.get(accountKey);
            if (!accountData) return null;
            const account = JSON.parse(accountData);
            return this.getUser(account.userId);
        },
        async updateUser (user) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const existing = await this.getUser(user.id);
            if (!existing) {
                throw new Error(`User ${user.id} not found`);
            }
            const updated = {
                ...existing,
                ...user
            };
            const key = `${USER_PREFIX}${user.id}`;
            await client.setEx(key, USER_TTL, JSON.stringify(updated));
            // Update email index if email changed
            if (user.email && user.email !== existing.email) {
                // Remove old email index
                if (existing.email) {
                    const oldEmailKey = `${USER_PREFIX}email:${existing.email}`;
                    await client.del(oldEmailKey);
                }
                // Add new email index
                const newEmailKey = `${USER_PREFIX}email:${user.email}`;
                await client.setEx(newEmailKey, USER_TTL, user.id);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Updated user', {
                userId: user.id
            });
            return updated;
        },
        async deleteUser (userId) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const user = await this.getUser(userId);
            if (user) {
                // Delete email index
                if (user.email) {
                    const emailKey = `${USER_PREFIX}email:${user.email}`;
                    await client.del(emailKey);
                }
                // Delete user
                const key = `${USER_PREFIX}${userId}`;
                await client.del(key);
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Deleted user', {
                    userId
                });
            }
        },
        // Session operations
        async createSession (session) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${SESSION_PREFIX}${session.sessionToken}`;
            const sessionData = {
                ...session,
                expires: session.expires.toISOString()
            };
            await client.setEx(key, SESSION_TTL, JSON.stringify(sessionData));
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Created session', {
                sessionToken: session.sessionToken,
                userId: session.userId
            });
            return session;
        },
        async getSessionAndUser (sessionToken) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${SESSION_PREFIX}${sessionToken}`;
            const sessionData = await client.get(key);
            if (!sessionData) return null;
            const session = JSON.parse(sessionData);
            const adapterSession = {
                ...session,
                expires: new Date(session.expires)
            };
            const user = await this.getUser(adapterSession.userId);
            if (!user) return null;
            return {
                session: adapterSession,
                user
            };
        },
        async updateSession (session) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${SESSION_PREFIX}${session.sessionToken}`;
            const existing = await client.get(key);
            if (!existing) return null;
            const existingSession = JSON.parse(existing);
            const updated = {
                ...existingSession,
                ...session,
                expires: session.expires || new Date(existingSession.expires)
            };
            await client.setEx(key, SESSION_TTL, JSON.stringify({
                ...updated,
                expires: updated.expires.toISOString()
            }));
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Updated session', {
                sessionToken: session.sessionToken
            });
            return updated;
        },
        async deleteSession (sessionToken) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${SESSION_PREFIX}${sessionToken}`;
            await client.del(key);
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Deleted session', {
                sessionToken
            });
        },
        // Account operations
        async linkAccount (account) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const accountKey = `${ACCOUNT_PREFIX}${account.provider}:${account.providerAccountId}`;
            await client.setEx(accountKey, ACCOUNT_TTL, JSON.stringify(account));
            // Also store by userId for account lookup
            const userAccountKey = `${ACCOUNT_PREFIX}user:${account.userId}:${account.provider}`;
            await client.setEx(userAccountKey, ACCOUNT_TTL, accountKey);
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Linked account', {
                userId: account.userId,
                provider: account.provider,
                providerAccountId: account.providerAccountId
            });
        },
        async unlinkAccount ({ providerAccountId, provider }) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const accountKey = `${ACCOUNT_PREFIX}${provider}:${providerAccountId}`;
            const accountData = await client.get(accountKey);
            if (accountData) {
                const account = JSON.parse(accountData);
                const userAccountKey = `${ACCOUNT_PREFIX}user:${account.userId}:${provider}`;
                await client.del(userAccountKey);
            }
            await client.del(accountKey);
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Unlinked account', {
                provider,
                providerAccountId
            });
        },
        // Verification token operations (for email verification, password reset, etc.)
        async createVerificationToken (verificationToken) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${VERIFICATION_TOKEN_PREFIX}${verificationToken.identifier}:${verificationToken.token}`;
            await client.setEx(key, VERIFICATION_TOKEN_TTL, JSON.stringify(verificationToken));
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Created verification token', {
                identifier: verificationToken.identifier
            });
            return verificationToken;
        },
        async useVerificationToken ({ identifier, token }) {
            const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRedisClient"])();
            const key = `${VERIFICATION_TOKEN_PREFIX}${identifier}:${token}`;
            const data = await client.get(key);
            if (!data) return null;
            await client.del(key); // Delete after use (one-time token)
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[RedisAdapter] Used verification token', {
                identifier
            });
            return JSON.parse(data);
        }
    };
}
}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-expect-error - NextAuth v5 beta compatibility - types not fully available yet
__turbopack_context__.s([
    "auth",
    ()=>auth,
    "authOptions",
    ()=>authOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$azure$2d$ad$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/azure-ad.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$azure$2d$ad$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/core/providers/azure-ad.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-adapter.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/redis-session.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/sentry.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/logger.ts [app-route] (ecmascript)");
;
;
;
;
;
;
// Helper function to refresh tokens for NextAuth Account
const refreshAccessTokenForAccount = async (userId, provider = 'azure-ad')=>{
    try {
        // Get account tokens from NextAuth Account storage
        const accountTokens = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAccountTokensFromNextAuth"])(userId, provider);
        if (!accountTokens || !accountTokens.refreshToken) {
            throw new Error('No refresh token available');
        }
        const issuer = ("TURBOPACK compile-time value", "https://login.microsoftonline.com/dd5a90ad-b0ae-463b-bef5-5bae77f1adf2/v2.0") || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;
        const response = await fetch(`${issuer}/oauth2/v2.0/token`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
                client_id: process.env.AZURE_AD_CLIENT_ID,
                grant_type: 'refresh_token',
                refresh_token: accountTokens.refreshToken,
                client_secret: process.env.AZURE_AD_CLIENT_SECRET
            })
        });
        const refreshedTokens = await response.json();
        if (!response.ok) {
            throw refreshedTokens;
        }
        const newAccessToken = refreshedTokens.access_token;
        const newRefreshToken = refreshedTokens.refresh_token ?? accountTokens.refreshToken;
        const newExpiryTime = Date.now() + refreshedTokens.expires_in * 1000;
        // Update NextAuth Account in Redis
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$session$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateNextAuthAccountTokens"])(userId, provider, newAccessToken, newRefreshToken, newExpiryTime);
        return {
            accessToken: newAccessToken,
            refreshToken: newRefreshToken,
            expiresAt: Math.floor(newExpiryTime / 1000)
        };
    } catch (error) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(error, {
            tags: {
                error_type: 'token_refresh',
                operation: 'refresh_access_token'
            },
            extra: {
                userId,
                provider
            },
            level: 'error'
        });
        throw error;
    }
};
// Validate required environment variables
const requiredEnvVars = {
    AZURE_AD_CLIENT_ID: process.env.AZURE_AD_CLIENT_ID,
    AZURE_AD_CLIENT_SECRET: process.env.AZURE_AD_CLIENT_SECRET,
    AZURE_AD_TENANT_ID: process.env.AZURE_AD_TENANT_ID,
    NEXTAUTH_URL: process.env.NEXTAUTH_URL,
    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET
};
const missingVars = Object.entries(requiredEnvVars).filter(([_, value])=>!value).map(([key])=>key);
if (missingVars.length > 0) {
    // eslint-disable-next-line no-console
    console.error('[NextAuth] Missing required environment variables:', missingVars);
}
// Log Azure AD configuration for debugging
if ("TURBOPACK compile-time truthy", 1) {
    const issuer = ("TURBOPACK compile-time value", "https://login.microsoftonline.com/dd5a90ad-b0ae-463b-bef5-5bae77f1adf2/v2.0") || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;
    // eslint-disable-next-line no-console
    console.log('[NextAuth Config] Azure AD Configuration:', {
        clientId: process.env.AZURE_AD_CLIENT_ID,
        tenantId: process.env.AZURE_AD_TENANT_ID,
        issuer,
        nextAuthUrl: process.env.NEXTAUTH_URL,
        expectedCallbackUrl: `${process.env.NEXTAUTH_URL}/api/auth/callback/azure-ad`,
        hasClientSecret: !!process.env.AZURE_AD_CLIENT_SECRET
    });
}
const authOptions = {
    debug: ("TURBOPACK compile-time value", "development") === 'development',
    adapter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$redis$2d$adapter$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RedisAdapter"])(),
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$core$2f$providers$2f$azure$2d$ad$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            clientId: process.env.AZURE_AD_CLIENT_ID,
            clientSecret: process.env.AZURE_AD_CLIENT_SECRET,
            // @ts-expect-error - tenantId is valid but not in types for v5 beta - will be fixed in stable release
            tenantId: process.env.AZURE_AD_TENANT_ID,
            // Explicitly set issuer to ensure correct URL construction
            issuer: ("TURBOPACK compile-time value", "https://login.microsoftonline.com/dd5a90ad-b0ae-463b-bef5-5bae77f1adf2/v2.0") || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`,
            authorization: {
                params: {
                    // Using only the absolute minimum permissions that don't require admin consent:
                    // - openid: Sign users in (Delegated, no admin consent)
                    // - email: View users' email address (Delegated, no admin consent)
                    // Note: Removed 'profile' and 'offline_access' as they may require admin consent
                    // depending on Azure AD app registration settings
                    scope: 'openid email'
                }
            },
            profile (profile) {
                return {
                    id: profile.sub || profile.oid || profile.id,
                    name: profile.name || profile.displayName || (profile.given_name && profile.family_name ? `${profile.given_name} ${profile.family_name}` : null) || profile.preferred_username || profile.email,
                    email: profile.email || profile.preferred_username || profile.upn,
                    image: profile.picture || undefined
                };
            }
        })
    ],
    callbacks: {
        // With database strategy, NextAuth handles account linking automatically via adapter
        // We only need to handle user registration and session data
        async signIn ({ user, account, profile }) {
            try {
                // Log sign-in for debugging
                if ("TURBOPACK compile-time truthy", 1) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[NextAuth] Sign in event', {
                        userId: user?.id,
                        userEmail: user?.email,
                        provider: account?.provider,
                        hasAccessToken: !!account?.access_token
                    });
                }
                // Automatically save user email to backend (fire and forget)
                // NextAuth adapter automatically stores account tokens via linkAccount
                if (user?.email && account?.access_token) {
                    try {
                        const entityConfigApiBaseUrl = process.env.NEXT_PUBLIC_ENTITY_CONFIG_API_BASE_URL || 'http://localhost:8003';
                        await fetch(`${entityConfigApiBaseUrl}/api/v1/users`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${account.access_token}`,
                                'X-User-Email': user.email
                            },
                            body: JSON.stringify({
                                email: user.email,
                                name: user.name || null
                            })
                        }).catch((err)=>{
                            // Silently fail - don't block login if user creation fails
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
                                tags: {
                                    error_type: 'user_registration',
                                    operation: 'register_user_on_login'
                                },
                                extra: {
                                    userEmail: user.email
                                },
                                level: 'warning'
                            });
                        });
                    } catch (err) {
                        // Silently fail - don't block login if user creation fails
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
                            tags: {
                                error_type: 'user_registration',
                                operation: 'register_user_on_login'
                            },
                            extra: {
                                userEmail: user.email
                            },
                            level: 'warning'
                        });
                    }
                }
                return true;
            } catch (error) {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(error, '[NextAuth] Sign in callback error', {
                    tags: {
                        error_type: 'signin_callback'
                    },
                    extra: {
                        stack: error?.stack
                    }
                });
                // Allow sign-in to proceed even if callbacks fail
                return true;
            }
        },
        async session ({ session, user }) {
            try {
                // With database strategy, user is provided directly from adapter
                // No need to extract from token - NextAuth handles this
                if (user) {
                    session.user = {
                        id: user.id || undefined,
                        name: user.name || undefined,
                        email: user.email || undefined,
                        image: user.image || undefined
                    };
                }
                // Log session for debugging
                if ("TURBOPACK compile-time truthy", 1) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[NextAuth] Session callback', {
                        hasUser: !!session.user,
                        userName: session.user?.name,
                        userEmail: session.user?.email
                    });
                }
                // Update user last login (fire and forget) - use proxy endpoint instead
                if (session.user?.email) {
                    try {
                        // This will go through proxy which will inject token from NextAuth Account
                        fetch('/api/proxy/api/v1/users', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-User-Email': session.user.email
                            },
                            body: JSON.stringify({
                                email: session.user.email,
                                name: session.user.name || null
                            })
                        }).catch((err)=>{
                            // Silently fail - don't block session if update fails
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
                                tags: {
                                    error_type: 'user_update',
                                    operation: 'update_user_last_login'
                                },
                                extra: {
                                    userEmail: session.user?.email
                                },
                                level: 'warning'
                            });
                        });
                    } catch (err) {
                        // Silently fail - don't block session if update fails
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(err, {
                            tags: {
                                error_type: 'user_update',
                                operation: 'update_user_last_login'
                            },
                            extra: {
                                userEmail: session.user?.email
                            },
                            level: 'warning'
                        });
                    }
                }
                return session;
            } catch (error) {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(error, '[NextAuth] Session callback error', {
                    tags: {
                        error_type: 'session_callback'
                    },
                    extra: {
                        stack: error?.stack
                    }
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(error, {
                    tags: {
                        error_type: 'session_callback',
                        operation: 'session_callback'
                    },
                    extra: {
                        hasUser: !!user,
                        userId: user?.id
                    },
                    level: 'error'
                });
                // Return session anyway to prevent complete failure
                return session;
            }
        },
        async redirect ({ url, baseUrl }) {
            // Handle redirect after successful authentication
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('NextAuth redirect callback', {
                url,
                baseUrl
            });
            // If url is the sign-in page, redirect to dashboard instead
            if (url === `${baseUrl}/` || url === baseUrl || url === '/') {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('Redirecting from sign-in page to dashboard');
                return `${baseUrl}/dashboard`;
            }
            // If url is a relative path, prepend baseUrl
            if (url.startsWith('/')) {
                return `${baseUrl}${url}`;
            }
            // If url is on the same origin, allow it
            try {
                if (new URL(url).origin === baseUrl) {
                    return url;
                }
            } catch (e) {
            // URL parsing failed, fall through to default
            }
            // Default to dashboard
            return `${baseUrl}/dashboard`;
        }
    },
    pages: {
        signIn: '/',
        error: '/'
    },
    events: {
        async signIn ({ user, account, profile }) {
            if ("TURBOPACK compile-time truthy", 1) {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[NextAuth] Sign in event', {
                    userId: user?.id,
                    userEmail: user?.email,
                    provider: account?.provider
                });
            }
            return true;
        },
        async signOut ({ session, token }) {
            if ("TURBOPACK compile-time truthy", 1) {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[NextAuth] Sign out event');
            }
        },
        async error ({ error, message }) {
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(error || new Error(message), '[NextAuth] Error event', {
                tags: {
                    error_type: 'nextauth_error_event'
                },
                extra: {
                    message,
                    errorType: error?.type,
                    errorStack: error?.stack
                }
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$sentry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["reportError"])(error || new Error(message), {
                tags: {
                    error_type: 'nextauth_error',
                    operation: 'nextauth_error_event'
                },
                extra: {
                    message,
                    errorType: error?.type
                },
                level: 'error'
            });
        }
    },
    session: {
        strategy: 'database',
        maxAge: 30 * 24 * 60 * 60
    },
    // Ensure proper base URL for callbacks
    trustHost: true
};
const { auth } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(authOptions);
}),
"[project]/src/app/api/workqueue/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DELETE",
    ()=>DELETE,
    "GET",
    ()=>GET,
    "PATCH",
    ()=>PATCH,
    "POST",
    ()=>POST,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/logger.ts [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    try {
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
        const searchParams = request.nextUrl.searchParams;
        const queryString = searchParams.toString();
        // Build proxy URL - proxy will handle token injection and refresh
        const proxyPath = `/api/proxy/api/v1/workqueue${queryString ? `?${queryString}` : ''}`;
        const proxyUrl = new URL(proxyPath, request.url);
        __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].debug('[WorkQueue API Route] Proxying request', {
            url: proxyUrl.toString()
        });
        // Prepare headers
        const headers = {
            'Content-Type': 'application/json'
        };
        // Add user identification headers (proxy will inject token from Redis)
        if (session?.user) {
            const user = session.user;
            if (user.email) headers['X-User-Email'] = user.email;
            if (user.name) headers['X-User-Name'] = user.name;
            if (user.id) headers['X-User-Id'] = user.id;
            if (user.role) headers['X-User-Role'] = user.role;
        }
        // Forward request through proxy (proxy handles token from httpOnly cookie)
        const response = await fetch(proxyUrl.toString(), {
            method: 'GET',
            headers,
            cache: 'no-store',
            signal: AbortSignal.timeout(30000)
        });
        if (!response.ok) {
            let errorText = '';
            let errorJson = null;
            try {
                errorText = await response.text();
                try {
                    errorJson = JSON.parse(errorText);
                } catch  {
                // Not JSON, use text as is
                }
            } catch (readError) {
                errorText = `Failed to read error response: ${readError instanceof Error ? readError.message : 'Unknown error'}`;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(new Error(`Backend error: ${response.status} ${response.statusText}`), '[WorkQueue API Route] Backend error', {
                tags: {
                    error_type: 'api_backend_error'
                },
                extra: {
                    status: response.status,
                    statusText: response.statusText,
                    body: errorText,
                    errorJson,
                    url: proxyUrl.toString()
                }
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: `API request failed: ${response.status} ${response.statusText}`,
                details: errorJson?.message || errorJson?.error || errorText || 'No error details available',
                backendError: errorJson,
                status: response.status
            }, {
                status: response.status
            });
        }
        let data;
        try {
            const responseText = await response.text();
            if (!responseText || responseText.trim() === '') {
                __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].warn('[WorkQueue API Route] Empty response from backend');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    items: [],
                    total_count: 0,
                    page: 1,
                    page_size: 20
                });
            }
            data = JSON.parse(responseText);
        } catch (parseError) {
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(parseError, '[WorkQueue API Route] Failed to parse response', {
                tags: {
                    error_type: 'api_parse_error'
                },
                extra: {
                    url: proxyUrl.toString()
                }
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid response from backend',
                message: parseError instanceof Error ? parseError.message : 'Failed to parse response'
            }, {
                status: 502
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(data);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(error, '[WorkQueue API Route] Request error', {
            tags: {
                error_type: 'api_request_error'
            }
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch work queue data',
            message: errorMessage
        }, {
            status: 500
        });
    }
}
/**
 * Forward work queue requests through proxy (BFF pattern)
 */ async function forwardRequest(request, method) {
    try {
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
        const pathname = request.nextUrl.pathname;
        const pathAfterWorkqueue = pathname.replace('/api/workqueue', '') || '';
        const searchParams = request.nextUrl.searchParams;
        const queryString = searchParams.toString();
        // Build proxy URL - proxy will handle token injection and refresh
        const proxyPath = `/api/proxy/api/v1/workqueue${pathAfterWorkqueue}${queryString ? `?${queryString}` : ''}`;
        const proxyUrl = new URL(proxyPath, request.url);
        // Prepare headers
        const headers = {
            'Content-Type': 'application/json'
        };
        // Add user identification headers (proxy will inject token from Redis)
        if (session?.user) {
            const user = session.user;
            if (user.email) headers['X-User-Email'] = user.email;
            if (user.name) headers['X-User-Name'] = user.name;
            if (user.id) headers['X-User-Id'] = user.id;
            if (user.role) headers['X-User-Role'] = user.role;
        }
        // Get request body if present
        let body;
        if (method !== 'GET' && method !== 'DELETE') {
            try {
                body = await request.text();
            } catch (e) {
            // No body
            }
        }
        // Forward request through proxy (proxy handles token from httpOnly cookie)
        const response = await fetch(proxyUrl.toString(), {
            method,
            headers,
            body: body || undefined,
            cache: 'no-store',
            signal: AbortSignal.timeout(30000)
        });
        if (!response.ok) {
            let errorText = '';
            let errorJson = null;
            try {
                errorText = await response.text();
                try {
                    errorJson = JSON.parse(errorText);
                } catch  {
                // Not JSON, use text as is
                }
            } catch (readError) {
                errorText = `Failed to read error response: ${readError instanceof Error ? readError.message : 'Unknown error'}`;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$logger$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["logger"].error(new Error(`Backend error: ${response.status} ${response.statusText}`), '[WorkQueue API Route] Backend error in forwardRequest', {
                tags: {
                    error_type: 'api_backend_error'
                },
                extra: {
                    status: response.status,
                    statusText: response.statusText,
                    body: errorText,
                    errorJson,
                    url: proxyUrl.toString()
                }
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: `API request failed: ${response.status} ${response.statusText}`,
                details: errorJson?.message || errorJson?.error || errorText,
                backendError: errorJson
            }, {
                status: response.status
            });
        }
        // Handle empty responses
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            const data = await response.json();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(data);
        } else {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"](null, {
                status: response.status
            });
        }
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to process work queue request',
            message: errorMessage
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    return forwardRequest(request, 'POST');
}
async function PUT(request) {
    return forwardRequest(request, 'PUT');
}
async function DELETE(request) {
    return forwardRequest(request, 'DELETE');
}
async function PATCH(request) {
    return forwardRequest(request, 'PATCH');
}
}),
];

//# debugId=6cea137c-3655-122a-1bf0-ef918db55e7a
//# sourceMappingURL=%5Broot-of-the-server%5D__6ac6e702._.js.map