{
  "version": 3,
  "sources": [],
  "debugId": "1d857a4c-82f9-bfc1-b80d-26242b917b74",
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/opentelemetry/build/cjs/index.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/semanticAttributes.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getParentSpanId.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/spanTypes.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getRequestSpanData.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/custom/client.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getSpanKind.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/constants.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/contextData.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/isSentryRequest.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getSamplingDecision.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/parseSpanDescription.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/enhanceDscWithOpenTelemetryRootSpanName.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getActiveSpan.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/debug-build.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/makeTraceState.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/setupCheck.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/propagator.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/trace.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/suppressTracing.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/setupEventContextTrace.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/getTraceData.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/asyncContextStrategy.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/contextManager.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/groupSpansWithParents.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/utils/mapStatus.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/spanExporter.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/spanProcessor.ts","file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/opentelemetry/src/sampler.ts"],"sourcesContent":["/** If this attribute is true, it means that the parent is a remote span. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n// These are not standardized yet, but used by the graphql instrumentation\nexport const SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = 'sentry.graphql.operation';\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\n\n/**\n * Get the parent span id from a span.\n * In OTel v1, the parent span id is accessed as `parentSpanId`\n * In OTel v2, the parent span id is accessed as `spanId` on the `parentSpanContext`\n */\nexport function getParentSpanId(span: ReadableSpan): string | undefined {\n  if ('parentSpanId' in span) {\n    return span.parentSpanId as string | undefined;\n  } else if ('parentSpanContext' in span) {\n    return (span.parentSpanContext as { spanId?: string } | undefined)?.spanId;\n  }\n\n  return undefined;\n}\n","import type { SpanKind, SpanStatus } from '@opentelemetry/api';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { AbstractSpan } from '../types';\nimport { getParentSpanId } from './getParentSpanId';\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nexport function spanHasAttributes<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { attributes: ReadableSpan['attributes'] } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasKind<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { kind: SpanKind } {\n  const castSpan = span as ReadableSpan;\n  return typeof castSpan.kind === 'number';\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasStatus<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { status: SpanStatus } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasName<SpanType extends AbstractSpan>(span: SpanType): span is SpanType & { name: string } {\n  const castSpan = span as ReadableSpan;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasParentId<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { parentSpanId: string } {\n  const castSpan = span as ReadableSpan;\n  return !!getParentSpanId(castSpan);\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nexport function spanHasEvents<SpanType extends AbstractSpan>(\n  span: SpanType,\n): span is SpanType & { events: TimedEvent[] } {\n  const castSpan = span as ReadableSpan;\n  return Array.isArray(castSpan.events);\n}\n","import type { Span } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { SanitizedRequestData } from '@sentry/core';\nimport { getSanitizedUrlString, parseUrl } from '@sentry/core';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nexport function getRequestSpanData(span: Span | ReadableSpan): Partial<SanitizedRequestData> {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeUrlAttribute = (span.attributes[ATTR_URL_FULL] || span.attributes[SEMATTRS_HTTP_URL]) as\n    | string\n    | undefined;\n\n  const data: Partial<SanitizedRequestData> = {\n    url: maybeUrlAttribute,\n    // eslint-disable-next-line deprecation/deprecation\n    'http.method': (span.attributes[ATTR_HTTP_REQUEST_METHOD] || span.attributes[SEMATTRS_HTTP_METHOD]) as\n      | string\n      | undefined,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    if (typeof maybeUrlAttribute === 'string') {\n      const url = parseUrl(maybeUrlAttribute);\n\n      data.url = getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch {\n    // ignore\n  }\n\n  return data;\n}\n","import type { Tracer } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\nimport type { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';\nimport type { Client } from '@sentry/core';\nimport { SDK_VERSION } from '@sentry/core';\nimport type { OpenTelemetryClient as OpenTelemetryClientInterface } from '../types';\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client class with things we need for OpenTelemetry support.\n * Make sure that the Client class passed in is non-abstract!\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nexport function wrapClientClass<\n  ClassConstructor extends new (...args: any[]) => Client,\n  WrappedClassConstructor extends new (...args: any[]) => Client & OpenTelemetryClientInterface,\n>(ClientClass: ClassConstructor): WrappedClassConstructor {\n  // @ts-expect-error We just assume that this is non-abstract, if you pass in an abstract class this would make it non-abstract\n  class OpenTelemetryClient extends ClientClass implements OpenTelemetryClientInterface {\n    public traceProvider: BasicTracerProvider | undefined;\n    private _tracer: Tracer | undefined;\n\n    public constructor(...args: any[]) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n    public get tracer(): Tracer {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = SDK_VERSION;\n      const tracer = trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public async flush(timeout?: number): Promise<boolean> {\n      const provider = this.traceProvider;\n      await provider?.forceFlush();\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient as unknown as WrappedClassConstructor;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n","import { SpanKind } from '@opentelemetry/api';\nimport type { AbstractSpan } from '../types';\nimport { spanHasKind } from './spanTypes';\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nexport function getSpanKind(span: AbstractSpan): SpanKind {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return SpanKind.INTERNAL;\n}\n","import { createContextKey } from '@opentelemetry/api';\n\nexport const SENTRY_TRACE_HEADER = 'sentry-trace';\nexport const SENTRY_BAGGAGE_HEADER = 'baggage';\n\nexport const SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nexport const SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nexport const SENTRY_TRACE_STATE_URL = 'sentry.url';\nexport const SENTRY_TRACE_STATE_SAMPLE_RAND = 'sentry.sample_rand';\nexport const SENTRY_TRACE_STATE_SAMPLE_RATE = 'sentry.sample_rate';\n\nexport const SENTRY_SCOPES_CONTEXT_KEY = createContextKey('sentry_scopes');\n\nexport const SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_isolation_scope');\n\nexport const SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_scope');\n\nexport const SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = createContextKey('sentry_fork_set_isolation_scope');\n","import type { Context } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { addNonEnumerableProperty } from '@sentry/core';\nimport { SENTRY_SCOPES_CONTEXT_KEY } from '../constants';\nimport type { CurrentScopes } from '../types';\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nexport function getScopesFromContext(context: Context): CurrentScopes | undefined {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) as CurrentScopes | undefined;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nexport function setScopesOnContext(context: Context, scopes: CurrentScopes): Context {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nexport function setContextOnScope(scope: Scope, context: Context): void {\n  addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n */\nexport function getContextFromScope(scope: Scope): Context | undefined {\n  return (scope as { [SCOPE_CONTEXT_FIELD]?: Context })[SCOPE_CONTEXT_FIELD];\n}\n","import { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport { getClient, isSentryRequestUrl } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes } from './spanTypes';\n\n/**\n *\n * @param otelSpan Checks whether a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nexport function isSentryRequestSpan(span: AbstractSpan): boolean {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return isSentryRequestUrl(httpUrl.toString(), getClient());\n}\n","import type { SpanContext } from '@opentelemetry/api';\nimport { TraceFlags } from '@opentelemetry/api';\nimport { baggageHeaderToDynamicSamplingContext } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nexport function getSamplingDecision(spanContext: SpanContext): boolean | undefined {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (dsc?.sampled === 'true') {\n    return true;\n  }\n  if (dsc?.sampled === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_ROUTE,\n  ATTR_URL_FULL,\n  SEMATTRS_DB_STATEMENT,\n  SEMATTRS_DB_SYSTEM,\n  SEMATTRS_FAAS_TRIGGER,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_TARGET,\n  SEMATTRS_HTTP_URL,\n  SEMATTRS_MESSAGING_SYSTEM,\n  SEMATTRS_RPC_SERVICE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, TransactionSource } from '@sentry/core';\nimport {\n  getSanitizedUrlString,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION } from '../semanticAttributes';\nimport type { AbstractSpan } from '../types';\nimport { getSpanKind } from './getSpanKind';\nimport { spanHasAttributes, spanHasName } from './spanTypes';\n\ninterface SpanDescription {\n  op: string | undefined;\n  description: string;\n  source: TransactionSource;\n  data?: Record<string, string | undefined>;\n}\n\n/**\n * Infer the op & description for a set of name, attributes and kind of a span.\n */\nexport function inferSpanData(spanName: string, attributes: SpanAttributes, kind: SpanKind): SpanDescription {\n  // if http.method exists, this is an http request span\n  // eslint-disable-next-line deprecation/deprecation\n  const httpMethod = attributes[ATTR_HTTP_REQUEST_METHOD] || attributes[SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name: spanName, kind }, httpMethod);\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const dbSystem = attributes[SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name: spanName });\n  }\n\n  const customSourceOrRoute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom' ? 'custom' : 'route';\n\n  // If rpc.service exists then this is a rpc call span.\n  // eslint-disable-next-line deprecation/deprecation\n  const rpcService = attributes[SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, 'route'),\n      op: 'rpc',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  // eslint-disable-next-line deprecation/deprecation\n  const messagingSystem = attributes[SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: 'message',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  // eslint-disable-next-line deprecation/deprecation\n  const faasTrigger = attributes[SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return {\n      ...getUserUpdatedNameAndSource(spanName, attributes, customSourceOrRoute),\n      op: faasTrigger.toString(),\n    };\n  }\n\n  return { op: undefined, description: spanName, source: 'custom' };\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Does not overwrite the span name if the source is already set to custom to ensure\n * that user-updated span names are preserved. In this case, we only adjust the op but\n * leave span description and source unchanged.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nexport function parseSpanDescription(span: AbstractSpan): SpanDescription {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n  const kind = getSpanKind(span);\n\n  return inferSpanData(name, attributes, kind);\n}\n\nfunction descriptionForDbSystem({ attributes, name }: { attributes: Attributes; name: string }): SpanDescription {\n  // if we already have a custom name, we don't overwrite it but only set the op\n  const userDefinedName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  if (typeof userDefinedName === 'string') {\n    return {\n      op: 'db',\n      description: userDefinedName,\n      source: (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || 'custom',\n    };\n  }\n\n  // if we already have the source set to custom, we don't overwrite the span description but only set the op\n  if (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom') {\n    return { op: 'db', description: name, source: 'custom' };\n  }\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  // eslint-disable-next-line deprecation/deprecation\n  const statement = attributes[SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nexport function descriptionForHttpMethod(\n  { name, kind, attributes }: { name: string; attributes: Attributes; kind: SpanKind },\n  httpMethod: AttributeValue,\n): SpanDescription {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  // Spans for HTTP requests we have determined to be prefetch requests will have a `.prefetch` postfix in the op\n  if (attributes['sentry.http.prefetch']) {\n    opParts.push('prefetch');\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { ...getUserUpdatedNameAndSource(name, attributes), op: opParts.join('.') };\n  }\n\n  const graphqlOperationsAttribute = attributes[SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION];\n\n  // Ex. GET /api/users\n  const baseDescription = `${httpMethod} ${urlPath}`;\n\n  // When the http span has a graphql operation, append it to the description\n  // We add these in the graphqlIntegration\n  const inferredDescription = graphqlOperationsAttribute\n    ? `${baseDescription} (${getGraphqlOperationNamesFromAttribute(graphqlOperationsAttribute)})`\n    : baseDescription;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const inferredSource: TransactionSource = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data: Record<string, string> = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  // If the span kind is neither client nor server, we use the original name\n  // this infers that somebody manually started this span, in which case we don't want to overwrite the name\n  const isClientOrServerKind = kind === SpanKind.CLIENT || kind === SpanKind.SERVER;\n\n  // If the span is an auto-span (=it comes from one of our instrumentations),\n  // we always want to infer the name\n  // this is necessary because some of the auto-instrumentation we use uses kind=INTERNAL\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual';\n  const isManualSpan = !`${origin}`.startsWith('auto');\n\n  // If users (or in very rare occasions we) set the source to custom, we don't overwrite the name\n  const alreadyHasCustomSource = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'custom';\n  const customSpanName = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  const useInferredDescription =\n    !alreadyHasCustomSource && customSpanName == null && (isClientOrServerKind || !isManualSpan);\n\n  const { description, source } = useInferredDescription\n    ? { description: inferredDescription, source: inferredSource }\n    : getUserUpdatedNameAndSource(name, attributes);\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\nfunction getGraphqlOperationNamesFromAttribute(attr: AttributeValue): string {\n  if (Array.isArray(attr)) {\n    const sorted = attr.slice().sort();\n\n    // Up to 5 items, we just add all of them\n    if (sorted.length <= 5) {\n      return sorted.join(', ');\n    } else {\n      // Else, we add the first 5 and the diff of other operations\n      return `${sorted.slice(0, 5).join(', ')}, +${sorted.length - 5}`;\n    }\n  }\n\n  return `${attr}`;\n}\n\n/** Exported for tests only */\nexport function getSanitizedUrl(\n  attributes: Attributes,\n  kind: SpanKind,\n): {\n  url: string | undefined;\n  urlPath: string | undefined;\n  query: string | undefined;\n  fragment: string | undefined;\n  hasRoute: boolean;\n} {\n  // This is the relative path of the URL, e.g. /sub\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = attributes[SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  // eslint-disable-next-line deprecation/deprecation\n  const httpUrl = attributes[SEMATTRS_HTTP_URL] || attributes[ATTR_URL_FULL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[ATTR_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl?.search || undefined;\n  const fragment = parsedUrl?.hash || undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Because Otel instrumentation sometimes mutates span names via `span.updateName`, the only way\n * to ensure that a user-set span name is preserved is to store it as a tmp attribute on the span.\n * We delete this attribute once we're done with it when preparing the event envelope.\n *\n * This temp attribute always takes precedence over the original name.\n *\n * We also need to take care of setting the correct source. Users can always update the source\n * after updating the name, so we need to respect that.\n *\n * @internal exported only for testing\n */\nexport function getUserUpdatedNameAndSource(\n  originalName: string,\n  attributes: Attributes,\n  fallbackSource: TransactionSource = 'custom',\n): {\n  description: string;\n  source: TransactionSource;\n} {\n  const source = (attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource) || fallbackSource;\n  const description = attributes[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n\n  if (description && typeof description === 'string') {\n    return {\n      description,\n      source,\n    };\n  }\n\n  return { description: originalName, source };\n}\n","import type { Client } from '@sentry/core';\nimport { hasSpansEnabled, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, spanToJSON } from '@sentry/core';\nimport { getSamplingDecision } from './getSamplingDecision';\nimport { parseSpanDescription } from './parseSpanDescription';\nimport { spanHasName } from './spanTypes';\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nexport function enhanceDscWithOpenTelemetryRootSpanName(client: Client): void {\n  client.on('createDsc', (dsc, rootSpan) => {\n    if (!rootSpan) {\n      return;\n    }\n\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n\n    const jsonSpan = spanToJSON(rootSpan);\n    const attributes = jsonSpan.data;\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n    if (source !== 'url' && description) {\n      dsc.transaction = description;\n    }\n\n    // Also ensure sampling decision is correctly inferred\n    // In core, we use `spanIsSampled`, which just looks at the trace flags\n    // but in OTEL, we use a slightly more complex logic to be able to differntiate between unsampled and deferred sampling\n    if (hasSpansEnabled()) {\n      const sampled = getSamplingDecision(rootSpan.spanContext());\n      dsc.sampled = sampled == undefined ? undefined : String(sampled);\n    }\n  });\n}\n","import type { Span } from '@opentelemetry/api';\nimport { trace } from '@opentelemetry/api';\n\n/**\n * Returns the currently active span.\n */\nexport function getActiveSpan(): Span | undefined {\n  return trace.getActiveSpan();\n}\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { TraceState } from '@opentelemetry/core';\nimport type { DynamicSamplingContext } from '@sentry/core';\nimport { dynamicSamplingContextToSentryBaggageHeader } from '@sentry/core';\nimport { SENTRY_TRACE_STATE_DSC, SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING } from '../constants';\n\n/**\n * Generate a TraceState for the given data.\n */\nexport function makeTraceState({\n  dsc,\n  sampled,\n}: {\n  dsc?: Partial<DynamicSamplingContext>;\n  sampled?: boolean;\n}): TraceState {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  const traceStateBase = new TraceState();\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n","type OpenTelemetryElement = 'SentrySpanProcessor' | 'SentryContextManager' | 'SentryPropagator' | 'SentrySampler';\n\nconst setupElements = new Set<OpenTelemetryElement>();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nexport function openTelemetrySetupCheck(): OpenTelemetryElement[] {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nexport function setIsSetup(element: OpenTelemetryElement): void {\n  setupElements.add(element);\n}\n\n/** Only exported for tests. */\nexport function clearOpenTelemetrySetupCheck(): void {\n  setupElements.clear();\n}\n","import type { Baggage, Context, Span, SpanContext, TextMapGetter, TextMapSetter } from '@opentelemetry/api';\nimport { context, INVALID_TRACEID, propagation, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed, W3CBaggagePropagator } from '@opentelemetry/core';\nimport { ATTR_URL_FULL, SEMATTRS_HTTP_URL } from '@opentelemetry/semantic-conventions';\nimport type { Client, continueTrace, DynamicSamplingContext, Options, Scope } from '@sentry/core';\nimport {\n  baggageHeaderToDynamicSamplingContext,\n  debug,\n  generateSentryTraceHeader,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  LRUMap,\n  parseBaggageHeader,\n  propagationContextFromHeaders,\n  SENTRY_BAGGAGE_KEY_PREFIX,\n  shouldContinueTrace,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport { SENTRY_BAGGAGE_HEADER, SENTRY_TRACE_HEADER, SENTRY_TRACE_STATE_URL } from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext, setScopesOnContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nexport class SentryPropagator extends W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n  private _urlMatchesTargetsMap: LRUMap<string, boolean>;\n\n  public constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new LRUMap<string, boolean>(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    if (isTracingSuppressed(context)) {\n      DEBUG_BUILD && debug.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = getClient()?.getOptions()?.tracePropagationTargets;\n    if (!shouldPropagateTraceForUrl(url, tracePropagationTargets, this._urlMatchesTargetsMap)) {\n      DEBUG_BUILD &&\n        debug.log('[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:', url);\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = propagation.getBaggage(context) || propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce<Baggage>((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const maybeSentryTraceHeader: string | string[] | undefined = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    // Add remote parent span context\n    // If there is no incoming trace, this will return the context as-is\n    return ensureScopesOnContext(getContextWithRemoteActiveSpan(context, { sentryTrace, baggage }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public fields(): string[] {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n}\n\nconst NOT_PROPAGATED_MESSAGE =\n  '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';\n\n/**\n * Check if a given URL should be propagated to or not.\n * If no url is defined, or no trace propagation targets are defined, this will always return `true`.\n * You can also optionally provide a decision map, to cache decisions and avoid repeated regex lookups.\n */\nexport function shouldPropagateTraceForUrl(\n  url: string | undefined,\n  tracePropagationTargets: Options['tracePropagationTargets'],\n  decisionMap?: LRUMap<string, boolean>,\n): boolean {\n  if (typeof url !== 'string' || !tracePropagationTargets) {\n    return true;\n  }\n\n  const cachedDecision = decisionMap?.get(url);\n  if (cachedDecision !== undefined) {\n    DEBUG_BUILD && !cachedDecision && debug.log(NOT_PROPAGATED_MESSAGE, url);\n    return cachedDecision;\n  }\n\n  const decision = stringMatchesSomePattern(url, tracePropagationTargets);\n  decisionMap?.set(url, decision);\n\n  DEBUG_BUILD && !decision && debug.log(NOT_PROPAGATED_MESSAGE, url);\n  return decision;\n}\n\n/**\n * Get propagation injection data for the given context.\n * The additional options can be passed to override the scope and client that is otherwise derived from the context.\n */\nexport function getInjectionData(\n  context: Context,\n  options: { scope?: Scope; client?: Client } = {},\n): {\n  dynamicSamplingContext: Partial<DynamicSamplingContext> | undefined;\n  traceId: string | undefined;\n  spanId: string | undefined;\n  sampled: boolean | undefined;\n} {\n  const span = trace.getSpan(context);\n\n  // If we have a remote span, the spanId should be considered as the parentSpanId, not spanId itself\n  // Instead, we use a virtual (generated) spanId for propagation\n  if (span?.spanContext().isRemote) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: undefined,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // If we have a local span, we just use this\n  if (span) {\n    const spanContext = span.spanContext();\n    const dynamicSamplingContext = getDynamicSamplingContextFromSpan(span);\n\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext), // TODO: Do we need to change something here?\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  // The only scenario where this should happen is when we neither have a span, nor an incoming trace\n  const scope = options.scope || getScopesFromContext(context)?.scope || getCurrentScope();\n  const client = options.client || getClient();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = client ? getDynamicSamplingContextFromScope(client, scope) : undefined;\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.propagationSpanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx: Context,\n  { sentryTrace, baggage }: Parameters<typeof continueTrace>[0],\n): Context {\n  const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n\n  const { traceId, parentSpanId, sampled, dsc } = propagationContext;\n\n  const client = getClient();\n  const incomingDsc = baggageHeaderToDynamicSamplingContext(baggage);\n\n  // We only want to set the virtual span if we are continuing a concrete trace\n  // Otherwise, we ignore the incoming trace here, e.g. if we have no trace headers\n  if (!parentSpanId || (client && !shouldContinueTrace(client, incomingDsc?.org_id))) {\n    return ctx;\n  }\n\n  const spanContext = generateRemoteSpanContext({\n    traceId,\n    spanId: parentSpanId,\n    sampled,\n    dsc,\n  });\n\n  return trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nexport function continueTraceAsRemoteSpan<T>(\n  ctx: Context,\n  options: Parameters<typeof continueTrace>[0],\n  callback: () => T,\n): T {\n  const ctxWithSpanContext = ensureScopesOnContext(getContextWithRemoteActiveSpan(ctx, options));\n\n  return context.with(ctxWithSpanContext, callback);\n}\n\nfunction ensureScopesOnContext(ctx: Context): Context {\n  // If there are no scopes yet on the context, ensure we have them\n  const scopes = getScopesFromContext(ctx);\n  const newScopes = {\n    // If we have no scope here, this is most likely either the root context or a context manually derived from it\n    // In this case, we want to fork the current scope, to ensure we do not pollute the root scope\n    scope: scopes ? scopes.scope : getCurrentScope().clone(),\n    isolationScope: scopes ? scopes.isolationScope : getIsolationScope(),\n  };\n\n  return setScopesOnContext(ctx, newScopes);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier: unknown): string | undefined {\n  try {\n    const baggage = (carrier as Record<string, string | string[]>)[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span: Span): string | undefined {\n  const spanData = spanToJSON(span).data;\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const urlAttribute = spanData[SEMATTRS_HTTP_URL] || spanData[ATTR_URL_FULL];\n  if (typeof urlAttribute === 'string') {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = span.spanContext().traceState?.get(SENTRY_TRACE_STATE_URL);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction generateRemoteSpanContext({\n  spanId,\n  traceId,\n  sampled,\n  dsc,\n}: {\n  spanId: string;\n  traceId: string;\n  sampled: boolean | undefined;\n  dsc?: Partial<DynamicSamplingContext>;\n}): SpanContext {\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanContext: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  return spanContext;\n}\n","import type { Context, Span, SpanContext, SpanOptions, Tracer } from '@opentelemetry/api';\nimport { context, SpanStatusCode, trace, TraceFlags } from '@opentelemetry/api';\nimport { suppressTracing } from '@opentelemetry/core';\nimport type {\n  Client,\n  continueTrace as baseContinueTrace,\n  DynamicSamplingContext,\n  Scope,\n  Span as SentrySpan,\n  TraceContext,\n} from '@sentry/core';\nimport {\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromScope,\n  getDynamicSamplingContextFromSpan,\n  getRootSpan,\n  getTraceContextFromScope,\n  handleCallbackErrors,\n  SDK_VERSION,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  spanToJSON,\n  spanToTraceContext,\n} from '@sentry/core';\nimport { continueTraceAsRemoteSpan } from './propagator';\nimport type { OpenTelemetryClient, OpenTelemetrySpanContext } from './types';\nimport { getContextFromScope } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { makeTraceState } from './utils/makeTraceState';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpan<T>(options: OpenTelemetrySpanContext, callback: (span: Span) => T): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpanManual<T>(\n  options: OpenTelemetrySpanContext,\n  callback: (span: Span, finish: () => void) => T,\n): T {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<T>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      return handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (spanToJSON(span).status === undefined) {\n            span.setStatus({ code: SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startInactiveSpan(options: OpenTelemetrySpanContext): Span {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper<Span>(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span | null, callback: (scope: Scope) => T): T {\n  const newContextWithActiveSpan = span ? trace.setSpan(context.active(), span) : trace.deleteSpan(context.active());\n  return context.with(newContextWithActiveSpan, () => callback(getCurrentScope()));\n}\n\nfunction getTracer(): Tracer {\n  const client = getClient<Client & OpenTelemetryClient>();\n  return client?.tracer || trace.getTracer('@sentry/opentelemetry', SDK_VERSION);\n}\n\nfunction getSpanOptions(options: OpenTelemetrySpanContext): SpanOptions {\n  const { startTime, attributes, kind, op, links } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes: op\n      ? {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n          ...attributes,\n        }\n      : attributes,\n    kind,\n    links,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp: number): number {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope: Scope | undefined, forceTransaction: boolean | undefined): Context {\n  const ctx = getContextForScope(scope);\n  const parentSpan = trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we start a new trace\n  // Note that if we continue a trace, we'll always have a remote parent span here anyhow\n  if (!parentSpan) {\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = getRootSpan(parentSpan);\n  const dsc = getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    sampled,\n  });\n\n  const spanOptions: SpanContext = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? TraceFlags.SAMPLED : TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope?: Scope): Context {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nexport function continueTrace<T>(options: Parameters<typeof baseContinueTrace>[0], callback: () => T): T {\n  return continueTraceAsRemoteSpan(context.active(), options, callback);\n}\n\n/**\n * Get the trace context for a given scope.\n * We have a custom implementation here because we need an OTEL-specific way to get the span from a scope.\n */\nexport function getTraceContextForScope(\n  client: Client,\n  scope: Scope,\n): [dynamicSamplingContext: Partial<DynamicSamplingContext>, traceContext: TraceContext] {\n  const ctx = getContextFromScope(scope);\n  const span = ctx && trace.getSpan(ctx);\n\n  const traceContext = span ? spanToTraceContext(span) : getTraceContextFromScope(scope);\n\n  const dynamicSamplingContext = span\n    ? getDynamicSamplingContextFromSpan(span)\n    : getDynamicSamplingContextFromScope(client, scope);\n  return [dynamicSamplingContext, traceContext];\n}\n\nfunction getActiveSpanWrapper<T>(parentSpan: Span | SentrySpan | undefined | null): (callback: () => T) => T {\n  return parentSpan !== undefined\n    ? (callback: () => T) => {\n        return withActiveSpan(parentSpan, callback);\n      }\n    : (callback: () => T) => callback();\n}\n","import { context } from '@opentelemetry/api';\nimport { suppressTracing as suppressTracingImpl } from '@opentelemetry/core';\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nexport function suppressTracing<T>(callback: () => T): T {\n  const ctx = suppressTracingImpl(context.active());\n  return context.with(ctx, callback);\n}\n","import type { Client } from '@sentry/core';\nimport { getDynamicSamplingContextFromSpan, getRootSpan, spanToTraceContext } from '@sentry/core';\nimport { getActiveSpan } from './utils/getActiveSpan';\n\n/** Ensure the `trace` context is set on all events. */\nexport function setupEventContextTrace(client: Client): void {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: spanToTraceContext(span),\n      ...event.contexts,\n    };\n\n    const rootSpan = getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n","import * as api from '@opentelemetry/api';\nimport type { Client, Scope, SerializedTraceData, Span } from '@sentry/core';\nimport {\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  getCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { getInjectionData } from '../propagator';\nimport { getContextFromScope } from './contextData';\n\n/**\n * Otel-specific implementation of `getTraceData`.\n * @see `@sentry/core` version of `getTraceData` for more information\n */\nexport function getTraceData({\n  span,\n  scope,\n  client,\n}: { span?: Span; scope?: Scope; client?: Client } = {}): SerializedTraceData {\n  let ctx = (scope && getContextFromScope(scope)) ?? api.context.active();\n\n  if (span) {\n    const { scope } = getCapturedScopesOnSpan(span);\n    // fall back to current context if for whatever reason we can't find the one of the span\n    ctx = (scope && getContextFromScope(scope)) || api.trace.setSpan(api.context.active(), span);\n  }\n\n  const { traceId, spanId, sampled, dynamicSamplingContext } = getInjectionData(ctx, { scope, client });\n\n  return {\n    'sentry-trace': generateSentryTraceHeader(traceId, spanId, sampled),\n    baggage: dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext),\n  };\n}\n","import * as api from '@opentelemetry/api';\nimport type { Scope, withActiveSpan as defaultWithActiveSpan } from '@sentry/core';\nimport { getDefaultCurrentScope, getDefaultIsolationScope, setAsyncContextStrategy } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { continueTrace, startInactiveSpan, startSpan, startSpanManual, withActiveSpan } from './trace';\nimport type { CurrentScopes } from './types';\nimport { getContextFromScope, getScopesFromContext } from './utils/contextData';\nimport { getActiveSpan } from './utils/getActiveSpan';\nimport { getTraceData } from './utils/getTraceData';\nimport { suppressTracing } from './utils/suppressTracing';\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nexport function setOpenTelemetryContextAsyncContextStrategy(): void {\n  function getScopes(): CurrentScopes {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope<T>(callback: (scope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope<T>(scope: Scope, callback: (scope: Scope) => T): T {\n    const ctx = getContextFromScope(scope) || api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope<T>(isolationScope: Scope, callback: (isolationScope: Scope) => T): T {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope(): Scope {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope(): Scope {\n    return getScopes().isolationScope;\n  }\n\n  setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    suppressTracing,\n    getTraceData,\n    continueTrace,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan as typeof defaultWithActiveSpan,\n  });\n}\n","import type { Context, ContextManager } from '@opentelemetry/api';\nimport type { Scope } from '@sentry/core';\nimport { getCurrentScope, getIsolationScope } from '@sentry/core';\nimport {\n  SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY,\n  SENTRY_FORK_SET_SCOPE_CONTEXT_KEY,\n} from './constants';\nimport { getScopesFromContext, setContextOnScope, setScopesOnContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nexport function wrapContextManagerClass<ContextManagerInstance extends ContextManager>(\n  ContextManagerClass: new (...args: unknown[]) => ContextManagerInstance,\n): typeof ContextManagerClass {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n    public constructor(...args: unknown[]) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n    public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n      context: Context,\n      fn: F,\n      thisArg?: ThisParameterType<F>,\n      ...args: A\n    ): ReturnType<F> {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = currentScopes?.scope || getCurrentScope();\n      const currentIsolationScope = currentScopes?.isolationScope || getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) as Scope | undefined;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) as Scope | undefined;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager as unknown as typeof ContextManagerClass;\n}\n","import type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from '../semanticAttributes';\nimport { getParentSpanId } from './getParentSpanId';\n\nexport interface SpanNode {\n  id: string;\n  span?: ReadableSpan;\n  parentNode?: SpanNode | undefined;\n  children: SpanNode[];\n}\n\ntype SpanMap = Map<string, SpanNode>;\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nexport function groupSpansWithParents(spans: ReadableSpan[]): SpanNode[] {\n  const nodeMap: SpanMap = new Map<string, SpanNode>();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nexport function getLocalParentId(span: ReadableSpan): string | undefined {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? getParentSpanId(span) : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap: SpanMap, span: ReadableSpan): void {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap: SpanMap, id: string): SpanNode {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap: SpanMap, spanNode: SpanNode): SpanNode {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing?.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n","import { SpanStatusCode } from '@opentelemetry/api';\nimport {\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_RPC_GRPC_STATUS_CODE,\n} from '@opentelemetry/semantic-conventions';\nimport type { SpanAttributes, SpanStatus } from '@sentry/core';\nimport { getSpanStatusFromHttpCode, SPAN_STATUS_ERROR, SPAN_STATUS_OK } from '@sentry/core';\nimport type { AbstractSpan } from '../types';\nimport { spanHasAttributes, spanHasStatus } from './spanTypes';\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap: Record<string, SpanStatus['message']> = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} as const;\n\nconst isStatusErrorMessageValid = (message: string): boolean => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message as SpanStatus['message']);\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nexport function mapStatus(span: AbstractSpan): SpanStatus {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === SpanStatusCode.OK) {\n      return { code: SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: SPAN_STATUS_ERROR, message: 'internal_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status?.code === SpanStatusCode.UNSET) {\n    return { code: SPAN_STATUS_OK };\n  } else {\n    return { code: SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes: SpanAttributes): SpanStatus | undefined {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpCodeAttribute = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE] || attributes[SEMATTRS_HTTP_STATUS_CODE];\n  // eslint-disable-next-line deprecation/deprecation\n  const grpcCodeAttribute = attributes[SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n","/* eslint-disable max-lines */\nimport type { Span } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { ATTR_HTTP_RESPONSE_STATUS_CODE, SEMATTRS_HTTP_STATUS_CODE } from '@opentelemetry/semantic-conventions';\nimport type {\n  SpanAttributes,\n  SpanJSON,\n  SpanOrigin,\n  TraceContext,\n  TransactionEvent,\n  TransactionSource,\n} from '@sentry/core';\nimport {\n  captureEvent,\n  convertSpanLinksForEnvelope,\n  debounce,\n  debug,\n  getCapturedScopesOnSpan,\n  getDynamicSamplingContextFromSpan,\n  getStatusMessage,\n  SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanTimeInputToSeconds,\n  timedEventsToMeasurements,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { getParentSpanId } from './utils/getParentSpanId';\nimport { getRequestSpanData } from './utils/getRequestSpanData';\nimport type { SpanNode } from './utils/groupSpansWithParents';\nimport { getLocalParentId, groupSpansWithParents } from './utils/groupSpansWithParents';\nimport { mapStatus } from './utils/mapStatus';\nimport { parseSpanDescription } from './utils/parseSpanDescription';\n\ntype SpanNodeCompleted = SpanNode & { span: ReadableSpan };\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\ninterface FinishedSpanBucket {\n  timestampInS: number;\n  spans: Set<ReadableSpan>;\n}\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nexport class SentrySpanExporter {\n  /*\n   * A quick explanation on the buckets: We do bucketing of finished spans for efficiency. This span exporter is\n   * accumulating spans until a root span is encountered and then it flushes all the spans that are descendants of that\n   * root span. Because it is totally in the realm of possibilities that root spans are never finished, and we don't\n   * want to accumulate spans indefinitely in memory, we need to periodically evacuate spans. Naively we could simply\n   * store the spans in an array and each time a new span comes in we could iterate through the entire array and\n   * evacuate all spans that have an end-timestamp that is older than our limit. This could get quite expensive because\n   * we would have to iterate a potentially large number of spans every time we evacuate. We want to avoid these large\n   * bursts of computation.\n   *\n   * Instead we go for a bucketing approach and put spans into buckets, based on what second\n   * (modulo the time limit) the span was put into the exporter. With buckets, when we decide to evacuate, we can\n   * iterate through the bucket entries instead, which have an upper bound of items, making the evacuation much more\n   * efficient. Cleaning up also becomes much more efficient since it simply involves de-referencing a bucket within the\n   * bucket array, and letting garbage collection take care of the rest.\n   */\n  private _finishedSpanBuckets: (FinishedSpanBucket | undefined)[];\n  private _finishedSpanBucketSize: number;\n  private _spansToBucketEntry: WeakMap<ReadableSpan, FinishedSpanBucket>;\n  private _lastCleanupTimestampInS: number;\n  // Essentially a a set of span ids that are already sent. The values are expiration\n  // times in this cache so we don't hold onto them indefinitely.\n  private _sentSpans: Map<string, number>;\n  /* Internally, we use a debounced flush to give some wiggle room to the span processor to accumulate more spans. */\n  private _debouncedFlush: ReturnType<typeof debounce>;\n\n  public constructor(options?: {\n    /** Lower bound of time in seconds until spans that are buffered but have not been sent as part of a transaction get cleared from memory. */\n    timeout?: number;\n  }) {\n    this._finishedSpanBucketSize = options?.timeout || DEFAULT_TIMEOUT;\n    this._finishedSpanBuckets = new Array(this._finishedSpanBucketSize).fill(undefined);\n    this._lastCleanupTimestampInS = Math.floor(Date.now() / 1000);\n    this._spansToBucketEntry = new WeakMap();\n    this._sentSpans = new Map<string, number>();\n    this._debouncedFlush = debounce(this.flush.bind(this), 1, { maxWait: 100 });\n  }\n\n  /**\n   * Export a single span.\n   * This is called by the span processor whenever a span is ended.\n   */\n  public export(span: ReadableSpan): void {\n    const currentTimestampInS = Math.floor(Date.now() / 1000);\n\n    if (this._lastCleanupTimestampInS !== currentTimestampInS) {\n      let droppedSpanCount = 0;\n      this._finishedSpanBuckets.forEach((bucket, i) => {\n        if (bucket && bucket.timestampInS <= currentTimestampInS - this._finishedSpanBucketSize) {\n          droppedSpanCount += bucket.spans.size;\n          this._finishedSpanBuckets[i] = undefined;\n        }\n      });\n      if (droppedSpanCount > 0) {\n        DEBUG_BUILD &&\n          debug.log(\n            `SpanExporter dropped ${droppedSpanCount} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`,\n          );\n      }\n      this._lastCleanupTimestampInS = currentTimestampInS;\n    }\n\n    const currentBucketIndex = currentTimestampInS % this._finishedSpanBucketSize;\n    const currentBucket = this._finishedSpanBuckets[currentBucketIndex] || {\n      timestampInS: currentTimestampInS,\n      spans: new Set(),\n    };\n    this._finishedSpanBuckets[currentBucketIndex] = currentBucket;\n    currentBucket.spans.add(span);\n    this._spansToBucketEntry.set(span, currentBucket);\n\n    // If the span doesn't have a local parent ID (it's a root span), we're gonna flush all the ended spans\n    const localParentId = getLocalParentId(span);\n    if (!localParentId || this._sentSpans.has(localParentId)) {\n      this._debouncedFlush();\n    }\n  }\n\n  /**\n   * Try to flush any pending spans immediately.\n   * This is called internally by the exporter (via _debouncedFlush),\n   * but can also be triggered externally if we force-flush.\n   */\n  public flush(): void {\n    const finishedSpans = this._finishedSpanBuckets.flatMap(bucket => (bucket ? Array.from(bucket.spans) : []));\n\n    this._flushSentSpanCache();\n    const sentSpans = this._maybeSend(finishedSpans);\n\n    const sentSpanCount = sentSpans.size;\n    const remainingOpenSpanCount = finishedSpans.length - sentSpanCount;\n    DEBUG_BUILD &&\n      debug.log(\n        `SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} spans are waiting for their parent spans to finish`,\n      );\n\n    const expirationDate = Date.now() + DEFAULT_TIMEOUT * 1000;\n\n    for (const span of sentSpans) {\n      this._sentSpans.set(span.spanContext().spanId, expirationDate);\n      const bucketEntry = this._spansToBucketEntry.get(span);\n      if (bucketEntry) {\n        bucketEntry.spans.delete(span);\n      }\n    }\n    // Cancel a pending debounced flush, if there is one\n    // This can be relevant if we directly flush, circumventing the debounce\n    // in that case, we want to cancel any pending debounced flush\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Clear the exporter.\n   * This is called when the span processor is shut down.\n   */\n  public clear(): void {\n    this._finishedSpanBuckets = this._finishedSpanBuckets.fill(undefined);\n    this._sentSpans.clear();\n    this._debouncedFlush.cancel();\n  }\n\n  /**\n   * Send the given spans, but only if they are part of a finished transaction.\n   *\n   * Returns the sent spans.\n   * Spans remain unsent when their parent span is not yet finished.\n   * This will happen regularly, as child spans are generally finished before their parents.\n   * But it _could_ also happen because, for whatever reason, a parent span was lost.\n   * In this case, we'll eventually need to clean this up.\n   */\n  private _maybeSend(spans: ReadableSpan[]): Set<ReadableSpan> {\n    const grouped = groupSpansWithParents(spans);\n    const sentSpans = new Set<ReadableSpan>();\n\n    const rootNodes = this._getCompletedRootNodes(grouped);\n\n    for (const root of rootNodes) {\n      const span = root.span;\n      sentSpans.add(span);\n      const transactionEvent = createTransactionForOtelSpan(span);\n\n      // Add an attribute to the transaction event to indicate that this transaction is an orphaned transaction\n      if (root.parentNode && this._sentSpans.has(root.parentNode.id)) {\n        const traceData = transactionEvent.contexts?.trace?.data;\n        if (traceData) {\n          traceData['sentry.parent_span_already_sent'] = true;\n        }\n      }\n\n      // We'll recursively add all the child spans to this array\n      const spans = transactionEvent.spans || [];\n\n      for (const child of root.children) {\n        createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n      }\n\n      // spans.sort() mutates the array, but we do not use this anymore after this point\n      // so we can safely mutate it here\n      transactionEvent.spans =\n        spans.length > MAX_SPAN_COUNT\n          ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n          : spans;\n\n      const measurements = timedEventsToMeasurements(span.events);\n      if (measurements) {\n        transactionEvent.measurements = measurements;\n      }\n\n      captureEvent(transactionEvent);\n    }\n\n    return sentSpans;\n  }\n\n  /** Remove \"expired\" span id entries from the _sentSpans cache. */\n  private _flushSentSpanCache(): void {\n    const currentTimestamp = Date.now();\n    // Note, it is safe to delete items from the map as we go: https://stackoverflow.com/a/35943995/90297\n    for (const [spanId, expirationTime] of this._sentSpans.entries()) {\n      if (expirationTime <= currentTimestamp) {\n        this._sentSpans.delete(spanId);\n      }\n    }\n  }\n\n  /** Check if a node is a completed root node or a node whose parent has already been sent */\n  private _nodeIsCompletedRootNodeOrHasSentParent(node: SpanNode): node is SpanNodeCompleted {\n    return !!node.span && (!node.parentNode || this._sentSpans.has(node.parentNode.id));\n  }\n\n  /** Get all completed root nodes from a list of nodes */\n  private _getCompletedRootNodes(nodes: SpanNode[]): SpanNodeCompleted[] {\n    // TODO: We should be able to remove the explicit `node is SpanNodeCompleted` type guard\n    //       once we stop supporting TS < 5.5\n    return nodes.filter((node): node is SpanNodeCompleted => this._nodeIsCompletedRootNodeOrHasSentParent(node));\n  }\n}\n\nfunction parseSpan(span: ReadableSpan): { op?: string; origin?: SpanOrigin; source?: TransactionSource } {\n  const attributes = span.attributes;\n\n  const origin = attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] as SpanOrigin | undefined;\n  const op = attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] as string | undefined;\n  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] as TransactionSource | undefined;\n\n  return { origin, op, source };\n}\n\n/** Exported only for tests. */\nexport function createTransactionForOtelSpan(span: ReadableSpan): TransactionEvent {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = getCapturedScopesOnSpan(span as unknown as Span);\n\n  const sampleRate = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] as number | undefined;\n\n  const attributes: SpanAttributes = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  };\n\n  const { links } = span;\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take precedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id = getParentSpanId(span);\n\n  const status = mapStatus(span);\n\n  const traceContext: TraceContext = {\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  const statusCode = attributes[ATTR_HTTP_RESPONSE_STATUS_CODE];\n  const responseContext = typeof statusCode === 'number' ? { response: { status_code: statusCode } } : undefined;\n\n  const transactionEvent: TransactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n      ...responseContext,\n    },\n    spans: [],\n    start_timestamp: spanTimeInputToSeconds(span.startTime),\n    timestamp: spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      capturedSpanScope: capturedSpanScopes.scope,\n      capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n      sampleRate,\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span as unknown as Span),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node: SpanNode, spans: SpanJSON[], sentSpans: Set<ReadableSpan>): void {\n  const span = node.span;\n\n  if (span) {\n    sentSpans.add(span);\n  }\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n  const parentSpanId = getParentSpanId(span);\n\n  const { attributes, startTime, endTime, links } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = {\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  };\n\n  const status = mapStatus(span);\n\n  const spanJSON: SpanJSON = {\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: spanTimeInputToSeconds(endTime) || undefined,\n    status: getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    measurements: timedEventsToMeasurements(span.events),\n    links: convertSpanLinksForEnvelope(links),\n  };\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, sentSpans);\n  });\n}\n\nfunction getSpanData(span: ReadableSpan): {\n  data: Record<string, unknown>;\n  op?: string;\n  description: string;\n  source?: TransactionSource;\n  origin?: SpanOrigin;\n} {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attributes we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data: Record<string, unknown>): Record<string, unknown> {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span: ReadableSpan): Record<string, unknown> {\n  const attributes = span.attributes;\n  const data: Record<string, unknown> = {};\n\n  if (span.kind !== SpanKind.INTERNAL) {\n    data['otel.kind'] = SpanKind[span.kind];\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const maybeHttpStatusCodeAttribute = attributes[SEMATTRS_HTTP_STATUS_CODE];\n  if (maybeHttpStatusCodeAttribute) {\n    data[ATTR_HTTP_RESPONSE_STATUS_CODE] = maybeHttpStatusCodeAttribute as string;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n","import type { Context } from '@opentelemetry/api';\nimport { ROOT_CONTEXT, trace } from '@opentelemetry/api';\nimport type { ReadableSpan, Span, SpanProcessor as SpanProcessorInterface } from '@opentelemetry/sdk-trace-base';\nimport {\n  addChildSpanToSpan,\n  getClient,\n  getDefaultCurrentScope,\n  getDefaultIsolationScope,\n  logSpanEnd,\n  logSpanStart,\n  setCapturedScopesOnSpan,\n} from '@sentry/core';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE } from './semanticAttributes';\nimport { SentrySpanExporter } from './spanExporter';\nimport { getScopesFromContext } from './utils/contextData';\nimport { setIsSetup } from './utils/setupCheck';\n\nfunction onSpanStart(span: Span, parentContext: Context): void {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan?.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === ROOT_CONTEXT) {\n    scopes = {\n      scope: getDefaultCurrentScope(),\n      isolationScope: getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  logSpanStart(span);\n\n  const client = getClient();\n  client?.emit('spanStart', span);\n}\n\nfunction onSpanEnd(span: Span): void {\n  logSpanEnd(span);\n\n  const client = getClient();\n  client?.emit('spanEnd', span);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nexport class SentrySpanProcessor implements SpanProcessorInterface {\n  private _exporter: SentrySpanExporter;\n\n  public constructor(options?: { timeout?: number }) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async forceFlush(): Promise<void> {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async shutdown(): Promise<void> {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public onStart(span: Span, parentContext: Context): void {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n  public onEnd(span: Span & ReadableSpan): void {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n","/* eslint-disable complexity */\nimport type { Context, Span, TraceState as TraceStateInterface } from '@opentelemetry/api';\nimport { isSpanContextValid, SpanKind, trace } from '@opentelemetry/api';\nimport { TraceState } from '@opentelemetry/core';\nimport type { Sampler, SamplingResult } from '@opentelemetry/sdk-trace-base';\nimport { SamplingDecision } from '@opentelemetry/sdk-trace-base';\nimport {\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_URL_FULL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_URL,\n} from '@opentelemetry/semantic-conventions';\nimport type { Client, SpanAttributes } from '@sentry/core';\nimport {\n  baggageHeaderToDynamicSamplingContext,\n  debug,\n  hasSpansEnabled,\n  parseSampleRate,\n  sampleSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n} from '@sentry/core';\nimport {\n  SENTRY_TRACE_STATE_DSC,\n  SENTRY_TRACE_STATE_SAMPLE_RAND,\n  SENTRY_TRACE_STATE_SAMPLE_RATE,\n  SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING,\n  SENTRY_TRACE_STATE_URL,\n} from './constants';\nimport { DEBUG_BUILD } from './debug-build';\nimport { getScopesFromContext } from './utils/contextData';\nimport { getSamplingDecision } from './utils/getSamplingDecision';\nimport { inferSpanData } from './utils/parseSpanDescription';\nimport { setIsSetup } from './utils/setupCheck';\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nexport class SentrySampler implements Sampler {\n  private _client: Client;\n\n  public constructor(client: Client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n  public shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    spanAttributes: SpanAttributes,\n    _links: unknown,\n  ): SamplingResult {\n    const options = this._client.getOptions();\n\n    const parentSpan = getValidSpan(context);\n    const parentContext = parentSpan?.spanContext();\n\n    if (!hasSpansEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // `ATTR_HTTP_REQUEST_METHOD` is the new attribute, but we still support the old one, `SEMATTRS_HTTP_METHOD`, for now.\n    // eslint-disable-next-line deprecation/deprecation\n    const maybeSpanHttpMethod = spanAttributes[SEMATTRS_HTTP_METHOD] || spanAttributes[ATTR_HTTP_REQUEST_METHOD];\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (spanKind === SpanKind.CLIENT && maybeSpanHttpMethod && (!parentSpan || parentContext?.isRemote)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n    const isRootSpan = !parentSpan || parentContext?.isRemote;\n\n    // We only sample based on parameters (like tracesSampleRate or tracesSampler) for root spans (which is done in sampleSpan).\n    // Non-root-spans simply inherit the sampling decision from their parent.\n    if (!isRootSpan) {\n      return wrapSamplingDecision({\n        decision: parentSampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n      });\n    }\n\n    // We want to pass the inferred name & attributes to the sampler method\n    const {\n      description: inferredSpanName,\n      data: inferredAttributes,\n      op,\n    } = inferSpanData(spanName, spanAttributes, spanKind);\n\n    const mergedAttributes = {\n      ...inferredAttributes,\n      ...spanAttributes,\n    };\n\n    if (op) {\n      mergedAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = op;\n    }\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: mergedAttributes,\n        spanName: inferredSpanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const { isolationScope } = getScopesFromContext(context) ?? {};\n\n    const dscString = parentContext?.traceState ? parentContext.traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n    const dsc = dscString ? baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n    const sampleRand = parseSampleRate(dsc?.sample_rand) ?? Math.random();\n\n    const [sampled, sampleRate, localSampleRateWasApplied] = sampleSpan(\n      options,\n      {\n        name: inferredSpanName,\n        attributes: mergedAttributes,\n        normalizedRequest: isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,\n        parentSampled,\n        parentSampleRate: parseSampleRate(dsc?.sample_rate),\n      },\n      sampleRand,\n    );\n\n    const method = `${maybeSpanHttpMethod}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && debug.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return wrapSamplingDecision({\n        decision: SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: 0, // we don't want to sample anything in the downstream trace either\n      });\n    }\n\n    if (\n      !sampled &&\n      // We check for `parentSampled === undefined` because we only want to record client reports for spans that are trace roots (ie. when there was incoming trace)\n      parentSampled === undefined\n    ) {\n      DEBUG_BUILD && debug.log('[Tracing] Discarding root span because its trace was not chosen to be sampled.');\n      this._client.recordDroppedEvent('sample_rate', 'transaction');\n    }\n\n    return {\n      ...wrapSamplingDecision({\n        decision: sampled ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD,\n        context,\n        spanAttributes,\n        sampleRand,\n        downstreamTraceSampleRate: localSampleRateWasApplied ? sampleRate : undefined,\n      }),\n      attributes: {\n        // We set the sample rate on the span when a local sample rate was applied to better understand how traces were sampled in Sentry\n        [SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: localSampleRateWasApplied ? sampleRate : undefined,\n      },\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n  public toString(): string {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentSampled(parentSpan: Span, traceId: string, spanName: string): boolean | undefined {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getSamplingDecision(parentSpan.spanContext());\n      DEBUG_BUILD &&\n        debug.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && debug.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nexport function wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n  sampleRand,\n  downstreamTraceSampleRate,\n}: {\n  decision: SamplingDecision | undefined;\n  context: Context;\n  spanAttributes: SpanAttributes;\n  sampleRand?: number;\n  downstreamTraceSampleRate?: number;\n}): SamplingResult {\n  let traceState = getBaseTraceState(context, spanAttributes);\n\n  // We will override the propagated sample rate downstream when\n  // - the tracesSampleRate is applied\n  // - the tracesSampler is invoked\n  // Since unsampled OTEL spans (NonRecordingSpans) cannot hold attributes we need to store this on the (trace)context.\n  if (downstreamTraceSampleRate !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RATE, `${downstreamTraceSampleRate}`);\n  }\n\n  if (sampleRand !== undefined) {\n    traceState = traceState.set(SENTRY_TRACE_STATE_SAMPLE_RAND, `${sampleRand}`);\n  }\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context: Context, spanAttributes: SpanAttributes): TraceStateInterface {\n  const parentSpan = trace.getSpan(context);\n  const parentContext = parentSpan?.spanContext();\n\n  let traceState = parentContext?.traceState || new TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  // `ATTR_URL_FULL` is the new attribute, but we still support the old one, `ATTR_HTTP_URL`, for now.\n  // eslint-disable-next-line deprecation/deprecation\n  const url = spanAttributes[SEMATTRS_HTTP_URL] || spanAttributes[ATTR_URL_FULL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * If the active span is invalid, we want to ignore it as parent.\n * This aligns with how otel tracers and default samplers handle these cases.\n */\nfunction getValidSpan(context: Context): Span | undefined {\n  const span = trace.getSpan(context);\n  return span && isSpanContextValid(span.spanContext()) ? span : undefined;\n}\n"],"names":["ATTR_URL_FULL","SEMATTRS_HTTP_URL","ATTR_HTTP_REQUEST_METHOD","SEMATTRS_HTTP_METHOD","parseUrl","getSanitizedUrlString","SDK_VERSION","trace","SpanKind","createContextKey","addNonEnumerableProperty","isSentryRequestUrl","getClient","TraceFlags","baggageHeaderToDynamicSamplingContext","SEMATTRS_DB_SYSTEM","SEMANTIC_ATTRIBUTE_SENTRY_OP","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMATTRS_RPC_SERVICE","SEMATTRS_MESSAGING_SYSTEM","SEMATTRS_FAAS_TRIGGER","SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME","SEMATTRS_DB_STATEMENT","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMATTRS_HTTP_TARGET","ATTR_HTTP_ROUTE","stripUrlQueryAndFragment","spanToJSON","hasSpansEnabled","dynamicSamplingContextToSentryBaggageHeader","TraceState","W3CBaggagePropagator","LRUMap","isTracingSuppressed","debug","propagation","parseBaggageHeader","SENTRY_BAGGAGE_KEY_PREFIX","INVALID_TRACEID","generateSentryTraceHeader","stringMatchesSomePattern","getDynamicSamplingContextFromSpan","getCurrentScope","getDynamicSamplingContextFromScope","propagationContextFromHeaders","shouldContinueTrace","context","getIsolationScope","suppressTracing","handleCallbackErrors","SpanStatusCode","getRootSpan","spanToTraceContext","getTraceContextFromScope","suppressTracingImpl","getCapturedScopesOnSpan","getDefaultCurrentScope","getDefaultIsolationScope","setAsyncContextStrategy","SPAN_STATUS_OK","SPAN_STATUS_ERROR","ATTR_HTTP_RESPONSE_STATUS_CODE","SEMATTRS_HTTP_STATUS_CODE","SEMATTRS_RPC_GRPC_STATUS_CODE","getSpanStatusFromHttpCode","debounce","timedEventsToMeasurements","captureEvent","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","getStatusMessage","convertSpanLinksForEnvelope","spanTimeInputToSeconds","addChildSpanToSpan","ROOT_CONTEXT","setCapturedScopesOnSpan","logSpanStart","logSpanEnd","SamplingDecision","parseSampleRate","sampleSpan","isSpanContextValid"],"mappings":";;;;;;;;AAAA,0EAAA,GACO,MAAM,0CAAA,GAA6C,uBAAuB;AAEjF,0EAAA;AACO,MAAM,2CAAA,GAA8C;ACF3D;;;;CAIA,GACO,SAAS,eAAe,CAAC,IAAI,EAAoC;IACtE,IAAI,cAAA,IAAkB,IAAI,EAAE;QAC1B,OAAO,IAAI,CAAC,YAAA;IACd,OAAO,IAAI,mBAAA,IAAuB,IAAI,EAAE;QACtC,OAAO,AAAC,IAAI,CAAC,iBAAA,EAAuD,MAAM;IAC5E;IAEA,OAAO,SAAS;AAClB;ACVA;;;;CAIA,GACO,SAAS,iBAAiB,CAC/B,IAAI;IAEJ,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,CAAC,CAAC,QAAQ,CAAC,UAAA,IAAc,OAAO,QAAQ,CAAC,UAAA,KAAe,QAAQ;AACzE;AAEA;;;;CAIA,GACO,SAAS,WAAW,CAAgC,IAAI,EAAmD;IAChH,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,OAAO,QAAQ,CAAC,IAAA,KAAS,QAAQ;AAC1C;AAEA;;;;CAIA,GACO,SAAS,aAAa,CAC3B,IAAI;IAEJ,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,CAAC,CAAC,QAAQ,CAAC,MAAM;AAC1B;AAEA;;;;CAIA,GACO,SAAS,WAAW,CAAgC,IAAI,EAAiD;IAC9G,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI;AACxB;AAEA;;;;CAIA,GACO,SAAS,eAAe,CAC7B,IAAI;IAEJ,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC;AACpC;AAEA;;;;CAIA,GACO,SAAS,aAAa,CAC3B,IAAI;IAEJ,MAAM,QAAA,GAAW,IAAA;IACjB,OAAO,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC;AACvC;AC3DA;;CAEA,GACO,SAAS,kBAAkB,CAAC,IAAI,EAAsD;IAC7F,kFAAA;IACE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,CAAA,CAAE;IACX;IAEF,mDAAA;IACE,MAAM,iBAAA,GAAqB,IAAI,CAAC,UAAU,CAACA,oBAAAA,aAAa,CAAA,IAAK,IAAI,CAAC,UAAU,CAACC,oBAAAA,iBAAiB,CAAC;IAI/F,MAAM,IAAI,GAAkC;QAC1C,GAAG,EAAE,iBAAiB;QAC1B,mDAAA;QACI,aAAa,EAAG,IAAI,CAAC,UAAU,CAACC,oBAAAA,wBAAwB,CAAA,IAAK,IAAI,CAAC,UAAU,CAACC,oBAAAA,oBAAoB,CAAC;IAGtG,CAAG;IAEH,iDAAA;IACE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAA,IAAK,IAAI,CAAC,GAAG,EAAE;QACpC,IAAI,CAAC,aAAa,CAAA,GAAI,KAAK;IAC7B;IAEA,IAAI;QACF,IAAI,OAAO,iBAAA,KAAsB,QAAQ,EAAE;YACzC,MAAM,GAAA,GAAMC,KAAAA,QAAQ,CAAC,iBAAiB,CAAC;YAEvC,IAAI,CAAC,GAAA,GAAMC,KAAAA,qBAAqB,CAAC,GAAG,CAAC;YAErC,IAAI,GAAG,CAAC,MAAM,EAAE;gBACd,IAAI,CAAC,YAAY,CAAA,GAAI,GAAG,CAAC,MAAM;YACjC;YACA,IAAI,GAAG,CAAC,IAAI,EAAE;gBACZ,IAAI,CAAC,eAAe,CAAA,GAAI,GAAG,CAAC,IAAI;YAClC;QACF;IACF,EAAE,OAAM;IACV,SAAA;IACE;IAEA,OAAO,IAAI;AACb;AClDA,8EAAA;AACA,8FAAA;AACA,qDAAA,GAEA;;;;;;;CAOA,GACO,SAAS,gBAGd,WAAW,EAA6C;IAC1D,8HAAA;IACE,MAAM,mBAAA,SAA4B,WAAA,EAAoD;QAI7E,WAAW,CAAC,GAAG,IAAI,CAAS;YACjC,KAAK,CAAC,GAAG,IAAI,CAAC;QAChB;QAEJ,yBAAA,GACW,IAAI,MAAM,GAAW;YAC1B,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,OAAO,IAAI,CAAC,OAAO;YACrB;YAEA,MAAM,IAAA,GAAO,uBAAuB;YACpC,MAAM,OAAA,GAAUC,KAAAA,WAAW;YAC3B,MAAM,MAAA,GAASC,IAAAA,KAAK,CAAC,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC;YAC7C,IAAI,CAAC,OAAA,GAAU,MAAM;YAErB,OAAO,MAAM;QACf;QAEJ;;KAEA,GACW,MAAM,KAAK,CAAC,OAAO,EAA6B;YACrD,MAAM,QAAA,GAAW,IAAI,CAAC,aAAa;YACnC,MAAM,QAAQ,EAAE,UAAU,EAAE;YAC5B,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC;QAC7B;IACJ;IAEE,OAAO,mBAAA;AACT;AACA,oDAAA,GCtDA;;;;;CAKA,GACO,SAAS,WAAW,CAAC,IAAI,EAA0B;IACxD,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QACrB,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA,OAAOC,IAAAA,QAAQ,CAAC,QAAQ;AAC1B;ACdO,MAAM,mBAAA,GAAsB,cAAc;AAC1C,MAAM,qBAAA,GAAwB,SAAS;AAEvC,MAAM,sBAAA,GAAyB,YAAY;AAC3C,MAAM,wCAAA,GAA2C,8BAA8B;AAC/E,MAAM,sBAAA,GAAyB,YAAY;AAC3C,MAAM,8BAAA,GAAiC,oBAAoB;AAC3D,MAAM,8BAAA,GAAiC,oBAAoB;AAE3D,MAAM,yBAAA,GAA4BC,IAAAA,gBAAgB,CAAC,eAAe,CAAC;AAEnE,MAAM,uCAAA,GAA0CA,IAAAA,gBAAgB,CAAC,6BAA6B,CAAC;AAE/F,MAAM,iCAAA,GAAoCA,IAAAA,gBAAgB,CAAC,uBAAuB,CAAC;AAEnF,MAAM,2CAAA,GAA8CA,IAAAA,gBAAgB,CAAC,iCAAiC,CAAC;ACX9G,MAAM,mBAAA,GAAsB,eAAe;AAE3C;;;CAGA,GACO,SAAS,oBAAoB,CAAC,OAAO,EAAsC;IAChF,OAAO,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAAA;AACnD;AAEA;;;CAGA,GACO,SAAS,kBAAkB,CAAC,OAAO,EAAW,MAAM,EAA0B;IACnF,OAAO,OAAO,CAAC,QAAQ,CAAC,yBAAyB,EAAE,MAAM,CAAC;AAC5D;AAEA;;;CAGA,GACO,SAAS,iBAAiB,CAAC,KAAK,EAAS,OAAO,EAAiB;IACtEC,KAAAA,wBAAwB,CAAC,KAAK,EAAE,mBAAmB,EAAE,OAAO,CAAC;AAC/D;AAEA;;CAEA,GACO,SAAS,mBAAmB,CAAC,KAAK,EAA8B;IACrE,OAAO,AAAC,KAAA,CAA8C,mBAAmB,CAAC;AAC5E;AChCA;;;;CAIA,GACO,SAAS,mBAAmB,CAAC,IAAI,EAAyB;IAC/D,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,KAAK;IACd;IAEA,MAAM,EAAE,UAAA,EAAW,GAAI,IAAI;IAE7B,oGAAA;IACA,mDAAA;IACE,MAAM,OAAA,GAAU,UAAU,CAACT,oBAAAA,iBAAiB,CAAA,IAAK,UAAU,CAACD,oBAAAA,aAAa,CAAC;IAE1E,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,KAAK;IACd;IAEA,OAAOW,KAAAA,kBAAkB,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAEC,KAAAA,SAAS,EAAE,CAAC;AAC5D;ACrBA;;;;;;CAMA,GACO,SAAS,mBAAmB,CAAC,WAAW,EAAoC;IACjF,MAAM,EAAE,UAAU,EAAE,UAAA,EAAW,GAAI,WAAW;IAE9C,MAAM,mBAAA,GAAsB,UAAA,GAAa,UAAU,CAAC,GAAG,CAAC,wCAAwC,CAAA,KAAM,GAAA,GAAM,KAAK;IAEnH,2DAAA;IACA,6GAAA;IACA,qGAAA;IACA,0BAAA;IACE,IAAI,UAAA,KAAeC,IAAAA,UAAU,CAAC,OAAO,EAAE;QACrC,OAAO,IAAI;IACb;IAEA,IAAI,mBAAmB,EAAE;QACvB,OAAO,KAAK;IACd;IAEF,wEAAA;IACE,MAAM,SAAA,GAAY,UAAA,GAAa,UAAU,CAAC,GAAG,CAAC,sBAAsB,CAAA,GAAI,SAAS;IACjF,MAAM,GAAA,GAAM,SAAA,GAAYC,KAAAA,qCAAqC,CAAC,SAAS,CAAA,GAAI,SAAS;IAEpF,IAAI,GAAG,EAAE,OAAA,KAAY,MAAM,EAAE;QAC3B,OAAO,IAAI;IACb;IACA,IAAI,GAAG,EAAE,OAAA,KAAY,OAAO,EAAE;QAC5B,OAAO,KAAK;IACd;IAEA,OAAO,SAAS;AAClB;ACJA;;CAEA,GACO,SAAS,aAAa,CAAC,QAAQ,EAAU,UAAU,EAAkB,IAAI,EAA6B;IAC7G,sDAAA;IACA,mDAAA;IACE,MAAM,UAAA,GAAa,UAAU,CAACZ,oBAAAA,wBAAwB,CAAA,IAAK,UAAU,CAACC,oBAAAA,oBAAoB,CAAC;IAC3F,IAAI,UAAU,EAAE;QACd,OAAO,wBAAwB,CAAC;YAAE,UAAU;YAAE,IAAI,EAAE,QAAQ;YAAE,IAAA;QAAA,CAAM,EAAE,UAAU,CAAC;IACnF;IAEF,mDAAA;IACE,MAAM,QAAA,GAAW,UAAU,CAACY,oBAAAA,kBAAkB,CAAC;IAC/C,MAAM,SAAA,GACJ,OAAO,UAAU,CAACC,KAAAA,4BAA4B,CAAA,KAAM,QAAA,IACpD,UAAU,CAACA,KAAAA,4BAA4B,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC;IAEjE,sDAAA;IACA,iFAAA;IACE,IAAI,QAAA,IAAY,CAAC,SAAS,EAAE;QAC1B,OAAO,sBAAsB,CAAC;YAAE,UAAU;YAAE,IAAI,EAAE,QAAA;QAAA,CAAU,CAAC;IAC/D;IAEA,MAAM,mBAAA,GAAsB,UAAU,CAACC,KAAAA,gCAAgC,CAAA,KAAM,QAAA,GAAW,QAAA,GAAW,OAAO;IAE5G,sDAAA;IACA,mDAAA;IACE,MAAM,UAAA,GAAa,UAAU,CAACC,oBAAAA,oBAAoB,CAAC;IACnD,IAAI,UAAU,EAAE;QACd,OAAO;YACL,GAAG,2BAA2B,CAAC,QAAQ,EAAE,UAAU,EAAE,OAAO,CAAC;YAC7D,EAAE,EAAE,KAAK;QACf,CAAK;IACH;IAEF,mEAAA;IACA,mDAAA;IACE,MAAM,eAAA,GAAkB,UAAU,CAACC,oBAAAA,yBAAyB,CAAC;IAC7D,IAAI,eAAe,EAAE;QACnB,OAAO;YACL,GAAG,2BAA2B,CAAC,QAAQ,EAAE,UAAU,EAAE,mBAAmB,CAAC;YACzE,EAAE,EAAE,SAAS;QACnB,CAAK;IACH;IAEF,oEAAA;IACA,mDAAA;IACE,MAAM,WAAA,GAAc,UAAU,CAACC,oBAAAA,qBAAqB,CAAC;IACrD,IAAI,WAAW,EAAE;QACf,OAAO;YACL,GAAG,2BAA2B,CAAC,QAAQ,EAAE,UAAU,EAAE,mBAAmB,CAAC;YACzE,EAAE,EAAE,WAAW,CAAC,QAAQ,EAAE;QAChC,CAAK;IACH;IAEA,OAAO;QAAE,EAAE,EAAE,SAAS;QAAE,WAAW,EAAE,QAAQ;QAAE,MAAM,EAAE;IAAA,CAAU;AACnE;AAEA;;;;;;;;CAQA,GACO,SAAS,oBAAoB,CAAC,IAAI,EAAiC;IACxE,MAAM,UAAA,GAAa,iBAAiB,CAAC,IAAI,CAAA,GAAI,IAAI,CAAC,UAAA,GAAa,CAAA,CAAE;IACjE,MAAM,IAAA,GAAO,WAAW,CAAC,IAAI,CAAA,GAAI,IAAI,CAAC,IAAA,GAAO,WAAW;IACxD,MAAM,IAAA,GAAO,WAAW,CAAC,IAAI,CAAC;IAE9B,OAAO,aAAa,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC;AAC9C;AAEA,SAAS,sBAAsB,CAAC,EAAE,UAAU,EAAE,IAAA,EAAM,EAA6D;IACjH,8EAAA;IACE,MAAM,eAAA,GAAkB,UAAU,CAACC,KAAAA,0CAA0C,CAAC;IAC9E,IAAI,OAAO,eAAA,KAAoB,QAAQ,EAAE;QACvC,OAAO;YACL,EAAE,EAAE,IAAI;YACR,WAAW,EAAE,eAAe;YAC5B,MAAM,EAAE,AAAC,UAAU,CAACJ,KAAAA,gCAAgC,CAAA,IAA2B,QAAQ;QAC7F,CAAK;IACH;IAEF,2GAAA;IACE,IAAI,UAAU,CAACA,KAAAA,gCAAgC,CAAA,KAAM,QAAQ,EAAE;QAC7D,OAAO;YAAE,EAAE,EAAE,IAAI;YAAE,WAAW,EAAE,IAAI;YAAE,MAAM,EAAE;QAAA,CAAU;IAC1D;IAEF,0EAAA;IACA,mDAAA;IACE,MAAM,SAAA,GAAY,UAAU,CAACK,oBAAAA,qBAAqB,CAAC;IAEnD,MAAM,WAAA,GAAc,SAAA,GAAY,SAAS,CAAC,QAAQ,EAAC,GAAI,IAAI;IAE3D,OAAO;QAAE,EAAE,EAAE,IAAI;QAAE,WAAW;QAAE,MAAM,EAAE,MAAA;IAAA,CAAQ;AAClD;AAEA,6BAAA,GACO,SAAS,wBAAwB,CACtC,EAAE,IAAI,EAAE,IAAI,EAAE,UAAA,EAAY,EAC1B,UAAU;IAEV,MAAM,OAAA,GAAU;QAAC,MAAM;KAAC;IAExB,OAAQ,IAAI;QACV,KAAKd,IAAAA,QAAQ,CAAC,MAAM;YAClB,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;YACtB;QACF,KAAKA,IAAAA,QAAQ,CAAC,MAAM;YAClB,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;YACtB;IACN;IAEA,+GAAA;IACE,IAAI,UAAU,CAAC,sBAAsB,CAAC,EAAE;QACtC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;IAC1B;IAEA,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAA,EAAA,GAAa,eAAe,CAAC,UAAU,EAAE,IAAI,CAAC;IAErF,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO;YAAE,GAAG,2BAA2B,CAAC,IAAI,EAAE,UAAU,CAAC;YAAE,EAAE,EAAE,OAAO,CAAC,IAAI,CAAC,GAAG;QAAA,CAAG;IACpF;IAEA,MAAM,0BAAA,GAA6B,UAAU,CAAC,2CAA2C,CAAC;IAE5F,qBAAA;IACE,MAAM,eAAA,GAAkB,CAAC,EAAA,UAAA,CAAA,CAAA,EAAA,OAAA,CAAA,CAAA;IAEA,2EAAA;IACA,yCAAA;IACA,MAAA,mBAAA,GAAA,6BACA,CAAA,EAAA,eAAA,CAAA,EAAA,EAAA,qCAAA,CAAA,0BAAA,CAAA,CAAA,CAAA,CAAA,GACA,eAAA;IAEA,wFAAA;IACA,MAAA,cAAA,GAAA,QAAA,IAAA,OAAA,KAAA,GAAA,GAAA,OAAA,GAAA,KAAA;IAEA,MAAA,IAAA,GAAA,CAAA,CAAA;IAEA,IAAA,GAAA,EAAA;QACA,IAAA,CAAA,GAAA,GAAA,GAAA;IACA;IACA,IAAA,KAAA,EAAA;QACA,IAAA,CAAA,YAAA,CAAA,GAAA,KAAA;IACA;IACA,IAAA,QAAA,EAAA;QACA,IAAA,CAAA,eAAA,CAAA,GAAA,QAAA;IACA;IAEA,0EAAA;IACA,0GAAA;IACA,MAAA,oBAAA,GAAA,IAAA,KAAAA,IAAAA,QAAA,CAAA,MAAA,IAAA,IAAA,KAAAA,IAAAA,QAAA,CAAA,MAAA;IAEA,4EAAA;IACA,mCAAA;IACA,uFAAA;IACA,MAAA,MAAA,GAAA,UAAA,CAAAe,KAAAA,gCAAA,CAAA,IAAA,QAAA;IACA,MAAA,YAAA,GAAA,CAAA,CAAA,EAAA,MAAA,CAAA,CAAA,CAAA,UAAA,CAAA,MAAA,CAAA;IAEA,gGAAA;IACA,MAAA,sBAAA,GAAA,UAAA,CAAAN,KAAAA,gCAAA,CAAA,KAAA,QAAA;IACA,MAAA,cAAA,GAAA,UAAA,CAAAI,KAAAA,0CAAA,CAAA;IAEA,MAAA,sBAAA,GACA,CAAA,sBAAA,IAAA,cAAA,IAAA,IAAA,IAAA,CAAA,oBAAA,IAAA,CAAA,YAAA,CAAA;IAEA,MAAA,EAAA,WAAA,EAAA,MAAA,EAAA,GAAA,yBACA;QAAA,WAAA,EAAA,mBAAA;QAAA,MAAA,EAAA,cAAA;IAAA,IACA,2BAAA,CAAA,IAAA,EAAA,UAAA,CAAA;IAEA,OAAA;QACA,EAAA,EAAA,OAAA,CAAA,IAAA,CAAA,GAAA,CAAA;QACA,WAAA;QACA,MAAA;QACA,IAAA;IACA,CAAA;AACA;AAEA,SAAA,qCAAA,CAAA,IAAA,EAAA;IACA,IAAA,KAAA,CAAA,OAAA,CAAA,IAAA,CAAA,EAAA;QACA,MAAA,MAAA,GAAA,IAAA,CAAA,KAAA,EAAA,CAAA,IAAA,EAAA;QAEA,yCAAA;QACA,IAAA,MAAA,CAAA,MAAA,IAAA,CAAA,EAAA;YACA,OAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA;QACA,CAAA,MAAA;YACA,4DAAA;YACA,OAAA,CAAA,EAAA,MAAA,CAAA,KAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,CAAA,GAAA,EAAA,MAAA,CAAA,MAAA,GAAA,CAAA,CAAA,CAAA;QACA;IACA;IAEA,OAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AACA;AAEA,4BAAA,GACA,SAAA,eAAA,CACA,UAAA,EACA,IAAA;IAQA,kDAAA;IACA,mDAAA;IACA,MAAA,UAAA,GAAA,UAAA,CAAAG,oBAAAA,oBAAA,CAAA;IACA,iGAAA;IACA,mDAAA;IACA,MAAA,OAAA,GAAA,UAAA,CAAAvB,oBAAAA,iBAAA,CAAA,IAAA,UAAA,CAAAD,oBAAAA,aAAA,CAAA;IACA,mEAAA;IACA,MAAA,SAAA,GAAA,UAAA,CAAAyB,oBAAAA,eAAA,CAAA;IAEA,MAAA,SAAA,GAAA,OAAA,OAAA,KAAA,QAAA,GAAArB,KAAAA,QAAA,CAAA,OAAA,CAAA,GAAA,SAAA;IACA,MAAA,GAAA,GAAA,SAAA,GAAAC,KAAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,SAAA;IACA,MAAA,KAAA,GAAA,SAAA,EAAA,MAAA,IAAA,SAAA;IACA,MAAA,QAAA,GAAA,SAAA,EAAA,IAAA,IAAA,SAAA;IAEA,IAAA,OAAA,SAAA,KAAA,QAAA,EAAA;QACA,OAAA;YAAA,OAAA,EAAA,SAAA;YAAA,GAAA;YAAA,KAAA;YAAA,QAAA;YAAA,QAAA,EAAA,IAAA;QAAA,CAAA;IACA;IAEA,IAAA,IAAA,KAAAG,IAAAA,QAAA,CAAA,MAAA,IAAA,OAAA,UAAA,KAAA,QAAA,EAAA;QACA,OAAA;YAAA,OAAA,EAAAkB,KAAAA,wBAAA,CAAA,UAAA,CAAA;YAAA,GAAA;YAAA,KAAA;YAAA,QAAA;YAAA,QAAA,EAAA,KAAA;QAAA,CAAA;IACA;IAEA,IAAA,SAAA,EAAA;QACA,OAAA;YAAA,OAAA,EAAA,GAAA;YAAA,GAAA;YAAA,KAAA;YAAA,QAAA;YAAA,QAAA,EAAA,KAAA;QAAA,CAAA;IACA;IAEA,kEAAA;IACA,IAAA,OAAA,UAAA,KAAA,QAAA,EAAA;QACA,OAAA;YAAA,OAAA,EAAAA,KAAAA,wBAAA,CAAA,UAAA,CAAA;YAAA,GAAA;YAAA,KAAA;YAAA,QAAA;YAAA,QAAA,EAAA,KAAA;QAAA,CAAA;IACA;IAEA,OAAA;QAAA,OAAA,EAAA,SAAA;QAAA,GAAA;QAAA,KAAA;QAAA,QAAA;QAAA,QAAA,EAAA,KAAA;IAAA,CAAA;AACA;AAEA;;;;;;;;;;;CAWA,GACA,SAAA,2BAAA,CACA,YAAA,EACA,UAAA,EACA,cAAA,GAAA,QAAA;IAKA,MAAA,MAAA,GAAA,UAAA,CAAAT,KAAAA,gCAAA,CAAA,IAAA,cAAA;IACA,MAAA,WAAA,GAAA,UAAA,CAAAI,KAAAA,0CAAA,CAAA;IAEA,IAAA,WAAA,IAAA,OAAA,WAAA,KAAA,QAAA,EAAA;QACA,OAAA;YACA,WAAA;YACA,MAAA;QACA,CAAA;IACA;IAEA,OAAA;QAAA,WAAA,EAAA,YAAA;QAAA,MAAA;IAAA,CAAA;AACA;ACjT3B;;;CAGA,GACO,SAAS,uCAAuC,CAAC,MAAM,EAAgB;IAC5E,MAAM,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,QAAQ,KAAK;QACxC,IAAI,CAAC,QAAQ,EAAE;YACb;QACF;QAEJ,qFAAA;QACA,sFAAA;QACA,mEAAA;QACA,oFAAA;QACA,iCAAA;QAEI,MAAM,QAAA,GAAWM,KAAAA,UAAU,CAAC,QAAQ,CAAC;QACrC,MAAM,UAAA,GAAa,QAAQ,CAAC,IAAI;QAChC,MAAM,MAAA,GAAS,UAAU,CAACV,KAAAA,gCAAgC,CAAC;QAE3D,MAAM,EAAE,WAAA,EAAA,GAAgB,WAAW,CAAC,QAAQ,CAAA,GAAI,oBAAoB,CAAC,QAAQ,CAAA,GAAI;YAAE,WAAW,EAAE;QAAA,CAAW;QAC3G,IAAI,MAAA,KAAW,KAAA,IAAS,WAAW,EAAE;YACnC,GAAG,CAAC,WAAA,GAAc,WAAW;QAC/B;QAEJ,sDAAA;QACA,uEAAA;QACA,uHAAA;QACI,IAAIW,KAAAA,eAAe,EAAE,EAAE;YACrB,MAAM,OAAA,GAAU,mBAAmB,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAC3D,GAAG,CAAC,OAAA,GAAU,OAAA,IAAW,SAAA,GAAY,SAAA,GAAY,MAAM,CAAC,OAAO,CAAC;QAClE;IACF,CAAC,CAAC;AACJ;ACpCA;;CAEA,GACO,SAAS,aAAa,GAAqB;IAChD,OAAOrB,IAAAA,KAAK,CAAC,aAAa,EAAE;AAC9B;ACNA;;;;CAIA,GACO,MAAM,WAAA,GAAc,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA,CAAe;ACF1C;;CAEA,GACO,SAAS,cAAc,CAAC,EAC7B,GAAG,EACH,OAAO,EACT;IAIA,2DAAA;IACE,MAAM,SAAA,GAAY,GAAA,GAAMsB,KAAAA,2CAA2C,CAAC,GAAG,CAAA,GAAI,SAAS;IAEpF,MAAM,cAAA,GAAiB,IAAIC,OAAAA,UAAU,EAAE;IAEvC,MAAM,iBAAA,GAAoB,SAAA,GAAY,cAAc,CAAC,GAAG,CAAC,sBAAsB,EAAE,SAAS,CAAA,GAAI,cAAc;IAE9G,6EAAA;IACA,iDAAA;IACE,OAAO,OAAA,KAAY,KAAA,GAAQ,iBAAiB,CAAC,GAAG,CAAC,wCAAwC,EAAE,GAAG,CAAA,GAAI,iBAAiB;AACrH;ACvBA,MAAM,aAAA,GAAgB,IAAI,GAAG,EAAwB;AAErD,8DAAA,GACO,SAAS,uBAAuB,GAA2B;IAChE,OAAO,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC;AAClC;AAEA,4CAAA,GACO,SAAS,UAAU,CAAC,OAAO,EAA8B;IAC9D,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC;AAC5B;ACiBA;;CAEA,GACO,MAAM,gBAAA,SAAyBC,OAAAA,oBAAA,CAAqB;IAC3D,4FAAA,GAGS,WAAW,EAAG;QACnB,KAAK,EAAE;QACP,UAAU,CAAC,kBAAkB,CAAC;QAElC,6FAAA;QACI,IAAI,CAAC,qBAAA,GAAwB,IAAIC,KAAAA,MAAM,CAAkB,GAAG,CAAC;IAC/D;IAEF;;GAEA,GACS,MAAM,CAAC,OAAO,EAAW,OAAO,EAAW,MAAM,EAAuB;QAC7E,IAAIC,OAAAA,mBAAmB,CAAC,OAAO,CAAC,EAAE;YAChC,eAAeC,KAAAA,KAAK,CAAC,GAAG,CAAC,2EAA2E,CAAC;YACrG;QACF;QAEA,MAAM,aAAa3B,IAAAA,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC;QACzC,MAAM,MAAM,UAAA,IAAc,aAAa,CAAC,UAAU,CAAC;QAEnD,MAAM,uBAAA,GAA0BK,KAAAA,SAAS,EAAE,EAAE,UAAU,EAAE,EAAE,uBAAuB;QAClF,IAAI,CAAC,0BAA0B,CAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,CAAC,qBAAqB,CAAC,EAAE;YACzF,WAAA,IACEsB,KAAAA,KAAK,CAAC,GAAG,CAAC,+FAA+F,EAAE,GAAG,CAAC;YACjH;QACF;QAEA,MAAM,qBAAA,GAAwB,kBAAkB,CAAC,OAAO,CAAC;QACzD,IAAI,OAAA,GAAUC,IAAAA,WAAW,CAAC,UAAU,CAAC,OAAO,CAAA,IAAKA,IAAAA,WAAW,CAAC,aAAa,CAAC,CAAA,CAAE,CAAC;QAE9E,MAAM,EAAE,sBAAsB,EAAE,OAAO,EAAE,MAAM,EAAE,OAAA,EAAQ,GAAI,gBAAgB,CAAC,OAAO,CAAC;QAEtF,IAAI,qBAAqB,EAAE;YACzB,MAAM,cAAA,GAAiBC,KAAAA,kBAAkB,CAAC,qBAAqB,CAAC;YAEhE,IAAI,cAAc,EAAE;gBAClB,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK;oBACvD,OAAA,GAAU,OAAO,CAAC,QAAQ,CAAC,GAAG,EAAE;wBAAE,KAAA;oBAAA,CAAO,CAAC;gBAC5C,CAAC,CAAC;YACJ;QACF;QAEA,IAAI,sBAAsB,EAAE;YAC1B,OAAA,GAAU,MAAM,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC,MAAM,CAAU,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,KAAK;gBAC1F,IAAI,QAAQ,EAAE;oBACZ,OAAO,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAAC,KAAAA,yBAAA,CAAA,EAAA,MAAA,CAAA,CAAA,EAAA;wBAAA,KAAA,EAAA,QAAA;oBAAA,CAAA,CAAA;gBACA;gBACA,OAAA,CAAA;YACA,CAAA,EAAA,OAAA,CAAA;QACA;QAEA,8FAAA;QACA,IAAA,OAAA,IAAA,OAAA,KAAAC,IAAAA,eAAA,EAAA;YACA,MAAA,CAAA,GAAA,CAAA,OAAA,EAAA,mBAAA,EAAAC,KAAAA,yBAAA,CAAA,OAAA,EAAA,MAAA,EAAA,OAAA,CAAA,CAAA;QACA;QAEA,KAAA,CAAA,MAAA,CAAAJ,IAAAA,WAAA,CAAA,UAAA,CAAA,OAAA,EAAA,OAAA,CAAA,EAAA,OAAA,EAAA,MAAA,CAAA;IACA;IAEA;;GAEA,GACA,OAAA,CAAA,OAAA,EAAA,OAAA,EAAA,MAAA,EAAA;QACA,MAAA,sBAAA,GAAA,MAAA,CAAA,GAAA,CAAA,OAAA,EAAA,mBAAA,CAAA;QACA,MAAA,OAAA,GAAA,MAAA,CAAA,GAAA,CAAA,OAAA,EAAA,qBAAA,CAAA;QAEA,MAAA,WAAA,GAAA,yBACA,KAAA,CAAA,OAAA,CAAA,sBAAA,IACA,sBAAA,CAAA,CAAA,CAAA,GACA,yBACA,SAAA;QAEA,iCAAA;QACA,oEAAA;QACA,OAAA,qBAAA,CAAA,8BAAA,CAAA,OAAA,EAAA;YAAA,WAAA;YAAA,OAAA;QAAA,CAAA,CAAA,CAAA;IACA;IAEA;;GAEA,GACA,MAAA,GAAA;QACA,OAAA;YAAA,mBAAA;YAAA,qBAAA;SAAA;IACA;AACA;AAEA,MAAA,sBAAA,GACA,+FAAA;AAEA;;;;CAIA,GACA,SAAA,0BAAA,CACA,GAAA,EACA,uBAAA,EACA,WAAA;IAEA,IAAA,OAAA,GAAA,KAAA,QAAA,IAAA,CAAA,uBAAA,EAAA;QACA,OAAA,IAAA;IACA;IAEA,MAAA,cAAA,GAAA,WAAA,EAAA,GAAA,CAAA,GAAA,CAAA;IACA,IAAA,cAAA,KAAA,SAAA,EAAA;QACA,WAAA,IAAA,CAAA,cAAA,IAAAD,KAAAA,KAAA,CAAA,GAAA,CAAA,sBAAA,EAAA,GAAA,CAAA;QACA,OAAA,cAAA;IACA;IAEA,MAAA,QAAA,GAAAM,KAAAA,wBAAA,CAAA,GAAA,EAAA,uBAAA,CAAA;IACA,WAAA,EAAA,GAAA,CAAA,GAAA,EAAA,QAAA,CAAA;IAEA,WAAA,IAAA,CAAA,QAAA,IAAAN,KAAAA,KAAA,CAAA,GAAA,CAAA,sBAAA,EAAA,GAAA,CAAA;IACA,OAAA,QAAA;AACA;AAEA;;;CAGA,GACA,SAAA,gBAAA,CACA,OAAA,EACA,OAAA,GAAA,CAAA,CAAA;IAOA,MAAA,IAAA,GAAA3B,IAAAA,KAAA,CAAA,OAAA,CAAA,OAAA,CAAA;IAEA,mGAAA;IACA,+DAAA;IACA,IAAA,IAAA,EAAA,WAAA,EAAA,CAAA,QAAA,EAAA;QACA,MAAA,WAAA,GAAA,IAAA,CAAA,WAAA,EAAA;QACA,MAAA,sBAAA,GAAAkC,KAAAA,iCAAA,CAAA,IAAA,CAAA;QAEA,OAAA;YACA,sBAAA;YACA,OAAA,EAAA,WAAA,CAAA,OAAA;YACA,MAAA,EAAA,SAAA;YACA,OAAA,EAAA,mBAAA,CAAA,WAAA,CAAA;QACA,CAAA;IACA;IAEA,4CAAA;IACA,IAAA,IAAA,EAAA;QACA,MAAA,WAAA,GAAA,IAAA,CAAA,WAAA,EAAA;QACA,MAAA,sBAAA,GAAAA,KAAAA,iCAAA,CAAA,IAAA,CAAA;QAEA,OAAA;YACA,sBAAA;YACA,OAAA,EAAA,WAAA,CAAA,OAAA;YACA,MAAA,EAAA,WAAA,CAAA,MAAA;YACA,OAAA,EAAA,mBAAA,CAAA,WAAA,CAAA;QACA,CAAA;IACA;IAEA,4DAAA;IACA,mGAAA;IACA,MAAA,KAAA,GAAA,OAAA,CAAA,KAAA,IAAA,oBAAA,CAAA,OAAA,CAAA,EAAA,KAAA,IAAAC,KAAAA,eAAA,EAAA;IACA,MAAA,MAAA,GAAA,OAAA,CAAA,MAAA,IAAA9B,KAAAA,SAAA,EAAA;IAEA,MAAA,kBAAA,GAAA,KAAA,CAAA,qBAAA,EAAA;IACA,MAAA,sBAAA,GAAA,MAAA,GAAA+B,KAAAA,kCAAA,CAAA,MAAA,EAAA,KAAA,CAAA,GAAA,SAAA;IACA,OAAA;QACA,sBAAA;QACA,OAAA,EAAA,kBAAA,CAAA,OAAA;QACA,MAAA,EAAA,kBAAA,CAAA,iBAAA;QACA,OAAA,EAAA,kBAAA,CAAA,OAAA;IACA,CAAA;AACA;AAEA,SAAA,8BAAA,CACA,GAAA,EACA,EAAA,WAAA,EAAA,OAAA,EAAA;IAEA,MAAA,kBAAA,GAAAC,KAAAA,6BAAA,CAAA,WAAA,EAAA,OAAA,CAAA;IAEA,MAAA,EAAA,OAAA,EAAA,YAAA,EAAA,OAAA,EAAA,GAAA,EAAA,GAAA,kBAAA;IAEA,MAAA,MAAA,GAAAhC,KAAAA,SAAA,EAAA;IACA,MAAA,WAAA,GAAAE,KAAAA,qCAAA,CAAA,OAAA,CAAA;IAEA,6EAAA;IACA,iFAAA;IACA,IAAA,CAAA,YAAA,IAAA,MAAA,IAAA,CAAA+B,KAAAA,mBAAA,CAAA,MAAA,EAAA,WAAA,EAAA,MAAA,CAAA,CAAA,CAAA;QACA,OAAA,GAAA;IACA;IAEA,MAAA,WAAA,GAAA,yBAAA,CAAA;QACA,OAAA;QACA,MAAA,EAAA,YAAA;QACA,OAAA;QACA,GAAA;IACA,CAAA,CAAA;IAEA,OAAAtC,IAAAA,KAAA,CAAA,cAAA,CAAA,GAAA,EAAA,WAAA,CAAA;AACA;AAEA;;;CAGA,GACA,SAAA,yBAAA,CACA,GAAA,EACA,OAAA,EACA,QAAA;IAEA,MAAA,kBAAA,GAAA,qBAAA,CAAA,8BAAA,CAAA,GAAA,EAAA,OAAA,CAAA,CAAA;IAEA,OAAAuC,IAAAA,OAAA,CAAA,IAAA,CAAA,kBAAA,EAAA,QAAA,CAAA;AACA;AAEA,SAAA,qBAAA,CAAA,GAAA,EAAA;IACA,iEAAA;IACA,MAAA,MAAA,GAAA,oBAAA,CAAA,GAAA,CAAA;IACA,MAAA,SAAA,GAAA;QACA,8GAAA;QACA,8FAAA;QACA,KAAA,EAAA,MAAA,GAAA,MAAA,CAAA,KAAA,GAAAJ,KAAAA,eAAA,EAAA,CAAA,KAAA,EAAA;QACA,cAAA,EAAA,MAAA,GAAA,MAAA,CAAA,cAAA,GAAAK,KAAAA,iBAAA,EAAA;IACA,CAAA;IAEA,OAAA,kBAAA,CAAA,GAAA,EAAA,SAAA,CAAA;AACA;AAEA,oEAAA,GACA,SAAA,kBAAA,CAAA,OAAA,EAAA;IACA,IAAA;QACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;QACA,OAAA,KAAA,CAAA,OAAA,CAAA,OAAA,CAAA,GAAA,OAAA,CAAA,IAAA,CAAA,GAAA,CAAA,GAAA,OAAA;IACA,CAAA,CAAA,OAAA;QACA,OAAA,SAAA;IACA;AACA;AAEA;;;;;;;;CAQA,GACA,SAAA,aAAA,CAAA,IAAA,EAAA;IACA,MAAA,QAAA,GAAApB,KAAAA,UAAA,CAAA,IAAA,CAAA,CAAA,IAAA;IACA,wGAAA;IACA,mDAAA;IACA,MAAA,YAAA,GAAA,QAAA,CAAA1B,oBAAAA,iBAAA,CAAA,IAAA,QAAA,CAAAD,oBAAAA,aAAA,CAAA;IACA,IAAA,OAAA,YAAA,KAAA,QAAA,EAAA;QACA,OAAA,YAAA;IACA;IAEA,wFAAA;IACA,MAAA,aAAA,GAAA,IAAA,CAAA,WAAA,EAAA,CAAA,UAAA,EAAA,GAAA,CAAA,sBAAA,CAAA;IACA,IAAA,aAAA,EAAA;QACA,OAAA,aAAA;IACA;IAEA,OAAA,SAAA;AACA;AAEA,SAAA,yBAAA,CAAA,EACA,MAAA,EACA,OAAA,EACA,OAAA,EACA,GAAA,EACA;IAMA,2DAAA;IACA,MAAA,UAAA,GAAA,cAAA,CAAA;QACA,GAAA;QACA,OAAA;IACA,CAAA,CAAA;IAEA,MAAA,WAAA,GAAA;QACA,OAAA;QACA,MAAA;QACA,QAAA,EAAA,IAAA;QACA,UAAA,EAAA,OAAA,GAAAa,IAAAA,UAAA,CAAA,OAAA,GAAAA,IAAAA,UAAA,CAAA,IAAA;QACA,UAAA;IACA,CAAA;IAEA,OAAA,WAAA;AACA;ACvS7B;;;;;;;;;CASA,GACO,SAAS,SAAS,CAAI,OAAO,EAA4B,QAAQ,EAAwB;IAC9F,MAAM,MAAA,GAAS,SAAS,EAAE;IAE1B,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,gBAAA,EAAiB,GAAI,OAAO;IAExD,uFAAA;IACE,MAAM,OAAA,GAAU,oBAAoB,CAAI,gBAAgB,CAAC;IAEzD,OAAO,OAAO,CAAC,MAAM;QACnB,MAAM,SAAA,GAAY,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,gBAAgB,CAAC;QACrE,MAAM,cAAA,GAAiB,OAAO,CAAC,YAAA,IAAgB,CAACN,IAAAA,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;QACxE,MAAM,GAAA,GAAM,cAAA,GAAiByC,OAAAA,eAAe,CAAC,SAAS,CAAA,GAAI,SAAS;QAEnE,MAAM,WAAA,GAAc,cAAc,CAAC,OAAO,CAAC;QAE3C,OAAO,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,GAAE,IAAA,IAAQ;YAC5D,OAAOC,KAAAA,oBAAoB,CACzB,IAAM,QAAQ,CAAC,IAAI,CAAC,EACpB,MAAM;gBACd,6HAAA;gBACU,IAAItB,KAAAA,UAAU,CAAC,IAAI,CAAC,CAAC,MAAA,KAAW,SAAS,EAAE;oBACzC,IAAI,CAAC,SAAS,CAAC;wBAAE,IAAI,EAAEuB,IAAAA,cAAc,CAAC,KAAA;oBAAA,CAAO,CAAC;gBAChD;YACF,CAAC,EACD,IAAM,IAAI,CAAC,GAAG,EAAE;QAEpB,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ;AAEA;;;;;;;;;CASA,GACO,SAAS,eAAe,CAC7B,OAAO,EACP,QAAQ;IAER,MAAM,MAAA,GAAS,SAAS,EAAE;IAE1B,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,gBAAA,EAAiB,GAAI,OAAO;IAExD,uFAAA;IACE,MAAM,OAAA,GAAU,oBAAoB,CAAI,gBAAgB,CAAC;IAEzD,OAAO,OAAO,CAAC,MAAM;QACnB,MAAM,SAAA,GAAY,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,gBAAgB,CAAC;QACrE,MAAM,cAAA,GAAiB,OAAO,CAAC,YAAA,IAAgB,CAAC3C,IAAAA,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;QACxE,MAAM,GAAA,GAAM,cAAA,GAAiByC,OAAAA,eAAe,CAAC,SAAS,CAAA,GAAI,SAAS;QAEnE,MAAM,WAAA,GAAc,cAAc,CAAC,OAAO,CAAC;QAE3C,OAAO,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,GAAE,IAAA,IAAQ;YAC5D,OAAOC,KAAAA,oBAAoB,CACzB,IAAM,QAAQ,CAAC,IAAI,EAAE,IAAM,IAAI,CAAC,GAAG,EAAE,CAAC,EACtC,MAAM;gBACd,6HAAA;gBACU,IAAItB,KAAAA,UAAU,CAAC,IAAI,CAAC,CAAC,MAAA,KAAW,SAAS,EAAE;oBACzC,IAAI,CAAC,SAAS,CAAC;wBAAE,IAAI,EAAEuB,IAAAA,cAAc,CAAC,KAAA;oBAAA,CAAO,CAAC;gBAChD;YACF,CAAC;QAEL,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ;AAEA;;;;;;;;CAQA,GACO,SAAS,iBAAiB,CAAC,OAAO,EAAkC;IACzE,MAAM,MAAA,GAAS,SAAS,EAAE;IAE1B,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,gBAAA,EAAiB,GAAI,OAAO;IAExD,uFAAA;IACE,MAAM,OAAA,GAAU,oBAAoB,CAAO,gBAAgB,CAAC;IAE5D,OAAO,OAAO,CAAC,MAAM;QACnB,MAAM,SAAA,GAAY,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,gBAAgB,CAAC;QACrE,MAAM,cAAA,GAAiB,OAAO,CAAC,YAAA,IAAgB,CAAC3C,IAAAA,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;QACxE,MAAM,GAAA,GAAM,cAAA,GAAiByC,OAAAA,eAAe,CAAC,SAAS,CAAA,GAAI,SAAS;QAEnE,MAAM,WAAA,GAAc,cAAc,CAAC,OAAO,CAAC;QAE3C,MAAM,IAAA,GAAO,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,WAAW,EAAE,GAAG,CAAC;QAErD,OAAO,IAAI;IACb,CAAC,CAAC;AACJ;AAEA;;;;;;;;CAQA,GACO,SAAS,cAAc,CAAI,IAAI,EAAe,QAAQ,EAA0B;IACrF,MAAM,wBAAA,GAA2B,IAAA,GAAOzC,IAAAA,KAAK,CAAC,OAAO,CAACuC,IAAAA,OAAO,CAAC,MAAM,EAAE,EAAE,IAAI,CAAA,GAAIvC,IAAAA,KAAK,CAAC,UAAU,CAACuC,IAAAA,OAAO,CAAC,MAAM,EAAE,CAAC;IAClH,OAAOA,IAAAA,OAAO,CAAC,IAAI,CAAC,wBAAwB,EAAE,IAAM,QAAQ,CAACJ,KAAAA,eAAe,EAAE,CAAC,CAAC;AAClF;AAEA,SAAS,SAAS,GAAW;IAC3B,MAAM,MAAA,GAAS9B,KAAAA,SAAS,EAAgC;IACxD,OAAO,MAAM,EAAE,MAAA,IAAUL,IAAAA,KAAK,CAAC,SAAS,CAAC,uBAAuB,EAAED,KAAAA,WAAW,CAAC;AAChF;AAEA,SAAS,cAAc,CAAC,OAAO,EAAyC;IACtE,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,EAAE,EAAE,KAAA,EAAM,GAAI,OAAO;IAE5D,6CAAA;IACE,MAAM,cAAA,GAAiB,OAAO,SAAA,KAAc,QAAA,GAAW,6BAA6B,CAAC,SAAS,CAAA,GAAI,SAAS;IAE3G,OAAO;QACL,UAAU,EAAE,KACR;YACE,CAACU,KAAAA,4BAA4B,CAAA,EAAG,EAAE;YAClC,GAAG,UAAU;QACvB,IACQ,UAAU;QACd,IAAI;QACJ,KAAK;QACL,SAAS,EAAE,cAAc;IAC7B,CAAG;AACH;AAEA,SAAS,6BAA6B,CAAC,SAAS,EAAkB;IAChE,MAAM,IAAA,GAAO,SAAA,GAAY,UAAU;IACnC,OAAO,IAAA,GAAO,YAAY,IAAA,GAAO,SAAS;AAC5C;AAEA,SAAS,UAAU,CAAC,KAAK,EAAqB,gBAAgB,EAAgC;IAC5F,MAAM,GAAA,GAAM,kBAAkB,CAAC,KAAK,CAAC;IACrC,MAAM,aAAaT,IAAAA,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;IAEvC,gEAAA;IACA,uFAAA;IACE,IAAI,CAAC,UAAU,EAAE;QACf,OAAO,GAAG;IACZ;IAEF,sGAAA;IACE,IAAI,CAAC,gBAAgB,EAAE;QACrB,OAAO,GAAG;IACZ;IAEF,0GAAA;IAEA,kCAAA;IACA,6EAAA;IACA,uFAAA;IACE,MAAM,iBAAiBA,IAAAA,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC;IAE5C,MAAM,EAAE,MAAM,EAAE,OAAA,EAAQ,GAAI,UAAU,CAAC,WAAW,EAAE;IACpD,MAAM,OAAA,GAAU,mBAAmB,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC;IAE/D,2GAAA;IACA,sDAAA;IACE,MAAM,QAAA,GAAW4C,KAAAA,WAAW,CAAC,UAAU,CAAC;IACxC,MAAM,GAAA,GAAMV,KAAAA,iCAAiC,CAAC,QAAQ,CAAC;IAEvD,MAAM,UAAA,GAAa,cAAc,CAAC;QAChC,GAAG;QACH,OAAO;IACX,CAAG,CAAC;IAEF,MAAM,WAAW,GAAgB;QAC/B,OAAO;QACP,MAAM;QACN,QAAQ,EAAE,IAAI;QACd,UAAU,EAAE,OAAA,GAAU5B,IAAAA,UAAU,CAAC,OAAA,GAAUA,IAAAA,UAAU,CAAC,IAAI;QAC1D,UAAU;IACd,CAAG;IAED,MAAM,kBAAA,GAAqBN,IAAAA,KAAK,CAAC,cAAc,CAAC,cAAc,EAAE,WAAW,CAAC;IAE5E,OAAO,kBAAkB;AAC3B;AAEA,SAAS,kBAAkB,CAAC,KAAK,EAAmB;IAClD,IAAI,KAAK,EAAE;QACT,MAAM,GAAA,GAAM,mBAAmB,CAAC,KAAK,CAAC;QACtC,IAAI,GAAG,EAAE;YACP,OAAO,GAAG;QACZ;IACF;IAEA,OAAOuC,IAAAA,OAAO,CAAC,MAAM,EAAE;AACzB;AAEA;;;;;;;;;;CAUA,GACO,SAAS,aAAa,CAAI,OAAO,EAA2C,QAAQ,EAAc;IACvG,OAAO,yBAAyB,CAACA,IAAAA,OAAO,CAAC,MAAM,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC;AACvE;AAEA;;;CAGA,GACO,SAAS,uBAAuB,CACrC,MAAM,EACN,KAAK;IAEL,MAAM,GAAA,GAAM,mBAAmB,CAAC,KAAK,CAAC;IACtC,MAAM,IAAA,GAAO,GAAA,IAAOvC,IAAAA,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;IAEtC,MAAM,YAAA,GAAe,IAAA,GAAO6C,KAAAA,kBAAkB,CAAC,IAAI,CAAA,GAAIC,KAAAA,wBAAwB,CAAC,KAAK,CAAC;IAEtF,MAAM,yBAAyB,OAC3BZ,KAAAA,iCAAiC,CAAC,IAAI,IACtCE,KAAAA,kCAAkC,CAAC,MAAM,EAAE,KAAK,CAAC;IACrD,OAAO;QAAC,sBAAsB;QAAE,YAAY;KAAC;AAC/C;AAEA,SAAS,oBAAoB,CAAI,UAAU,EAAkE;IAC3G,OAAO,eAAe,YAClB,CAAC,QAAQ,KAAc;QACrB,OAAO,cAAc,CAAC,UAAU,EAAE,QAAQ,CAAC;IAC7C,IACA,CAAC,QAAQ,GAAc,QAAQ,EAAE;AACvC;ACzRA,0FAAA,GACO,SAAS,eAAe,CAAI,QAAQ,EAAc;IACvD,MAAM,GAAA,GAAMW,OAAAA,eAAmB,CAACR,IAAAA,OAAO,CAAC,MAAM,EAAE,CAAC;IACjD,OAAOA,IAAAA,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,QAAQ,CAAC;AACpC;ACHA,qDAAA,GACO,SAAS,sBAAsB,CAAC,MAAM,EAAgB;IAC3D,MAAM,CAAC,EAAE,CAAC,iBAAiB,GAAE,SAAS;QACpC,MAAM,IAAA,GAAO,aAAa,EAAE;QAChC,qDAAA;QACA,qFAAA;QACI,IAAI,CAAC,IAAA,IAAQ,KAAK,CAAC,IAAA,KAAS,aAAa,EAAE;YACzC;QACF;QAEJ,0DAAA;QACI,KAAK,CAAC,QAAA,GAAW;YACf,KAAK,EAAEM,KAAAA,kBAAkB,CAAC,IAAI,CAAC;YAC/B,GAAG,KAAK,CAAC,QAAQ;QACvB,CAAK;QAED,MAAM,QAAA,GAAWD,KAAAA,WAAW,CAAC,IAAI,CAAC;QAElC,KAAK,CAAC,qBAAA,GAAwB;YAC5B,sBAAsB,EAAEV,KAAAA,iCAAiC,CAAC,QAAQ,CAAC;YACnE,GAAG,KAAK,CAAC,qBAAqB;QACpC,CAAK;QAED,OAAO,KAAK;IACd,CAAC,CAAC;AACJ;ACnBA;;;CAGA,GACO,SAAS,YAAY,CAAC,EAC3B,IAAI,EACJ,KAAK,EACL,MAAM,EACP,GAAoD,CAAA,CAAE,EAAuB;IAC5E,IAAI,GAAA,GAAM,CAAC,KAAA,IAAS,mBAAmB,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;IAEvE,IAAI,IAAI,EAAE;QACR,MAAM,EAAE,KAAA,EAAM,GAAIc,KAAAA,uBAAuB,CAAC,IAAI,CAAC;QACnD,wFAAA;QACI,GAAA,GAAM,AAAC,KAAA,IAAS,mBAAmB,CAAC,KAAK,CAAC,IAAK,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC;IAC9F;IAEA,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,sBAAA,EAAuB,GAAI,gBAAgB,CAAC,GAAG,EAAE;QAAE,KAAK;QAAE,MAAA;IAAA,CAAQ,CAAC;IAErG,OAAO;QACL,cAAc,EAAEhB,KAAAA,yBAAyB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC;QACnE,OAAO,EAAEV,KAAAA,2CAA2C,CAAC,sBAAsB,CAAC;IAChF,CAAG;AACH;AClBA;;;CAGA,GACO,SAAS,2CAA2C,GAAS;IAClE,SAAS,SAAS,GAAkB;QAClC,MAAM,MAAM,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;QAChC,MAAM,MAAA,GAAS,oBAAoB,CAAC,GAAG,CAAC;QAExC,IAAI,MAAM,EAAE;YACV,OAAO,MAAM;QACf;QAEJ,qBAAA;QACA,iGAAA;QACI,OAAO;YACL,KAAK,EAAE2B,KAAAA,sBAAsB,EAAE;YAC/B,cAAc,EAAEC,KAAAA,wBAAwB,EAAE;QAChD,CAAK;IACH;IAEA,SAAS,SAAS,CAAI,QAAQ,EAA0B;QACtD,MAAM,MAAM,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;QAEpC,gEAAA;QACA,4FAAA;QACA,0FAAA;QACA,mCAAA;QACA,wFAAA;QACI,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM;YACjC,OAAO,QAAQ,CAAC,eAAe,EAAE,CAAC;QACpC,CAAC,CAAC;IACJ;IAEA,SAAS,YAAY,CAAI,KAAK,EAAS,QAAQ,EAA0B;QACvE,MAAM,GAAA,GAAM,mBAAmB,CAAC,KAAK,CAAA,IAAK,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;QAElE,gEAAA;QACA,sFAAA;QACA,2EAAA;QACI,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,iCAAiC,EAAE,KAAK,CAAC,EAAE,MAAM;YACpF,OAAO,QAAQ,CAAC,KAAK,CAAC;QACxB,CAAC,CAAC;IACJ;IAEA,SAAS,kBAAkB,CAAI,QAAQ,EAAmC;QACxE,MAAM,MAAM,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;QAEpC,gEAAA;QACA,4FAAA;QACA,0FAAA;QACA,mCAAA;QACI,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,uCAAuC,EAAE,IAAI,CAAC,EAAE,MAAM;YACzF,OAAO,QAAQ,CAAC,iBAAiB,EAAE,CAAC;QACtC,CAAC,CAAC;IACJ;IAEA,SAAS,qBAAqB,CAAI,cAAc,EAAS,QAAQ,EAAmC;QAClG,MAAM,MAAM,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE;QAEpC,gEAAA;QACA,4FAAA;QACA,0FAAA;QACA,mCAAA;QACI,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,2CAA2C,EAAE,cAAc,CAAC,EAAE,MAAM;YACvG,OAAO,QAAQ,CAAC,iBAAiB,EAAE,CAAC;QACtC,CAAC,CAAC;IACJ;IAEA,SAAS,eAAe,GAAU;QAChC,OAAO,SAAS,EAAE,CAAC,KAAK;IAC1B;IAEA,SAAS,iBAAiB,GAAU;QAClC,OAAO,SAAS,EAAE,CAAC,cAAc;IACnC;IAEAC,KAAAA,uBAAuB,CAAC;QACtB,SAAS;QACT,YAAY;QACZ,qBAAqB;QACrB,kBAAkB;QAClB,eAAe;QACf,iBAAiB;QACjB,SAAS;QACT,eAAe;QACf,iBAAiB;QACjB,aAAa;QACb,eAAe;QACf,YAAY;QACZ,aAAa;QACjB,4EAAA;QACA,kGAAA;QACI,cAAc,EAAE,cAAA;IACpB,CAAG,CAAC;AACJ;ACnGA;;;;;;;CAOA,GACO,SAAS,uBAAuB,CACrC,mBAAmB;IAErB;;;;;;GAMA,GAEA,mEAAA;IACE,MAAM,oBAAA,SAA6B,mBAAA,CAAoB;QAC9C,WAAW,CAAC,GAAG,IAAI,CAAa;YACrC,KAAK,CAAC,GAAG,IAAI,CAAC;YACd,UAAU,CAAC,sBAAsB,CAAC;QACpC;QACJ;;;KAGA,GACW,IAAI,CACT,OAAO,EACP,EAAE,EACF,OAAO,EACP,GAAG,IAAA,EACY;YACf,MAAM,aAAA,GAAgB,oBAAoB,CAAC,OAAO,CAAC;YACnD,MAAM,eAAe,aAAa,EAAE,KAAA,IAAShB,KAAAA,eAAe,EAAE;YAC9D,MAAM,wBAAwB,aAAa,EAAE,cAAA,IAAkBK,KAAAA,iBAAiB,EAAE;YAElF,MAAM,wBAAA,GAA2B,OAAO,CAAC,QAAQ,CAAC,uCAAuC,CAAA,KAAM,IAAI;YACnG,MAAM,QAAQ,OAAO,CAAC,QAAQ,CAAC,iCAAiC,CAAA;YAChE,MAAM,iBAAiB,OAAO,CAAC,QAAQ,CAAC,2CAA2C,CAAA;YAEnF,MAAM,kBAAkB,KAAA,IAAS,YAAY,CAAC,KAAK,EAAE;YACrD,MAAM,iBAAA,GACJ,cAAA,IAAA,CAAmB,wBAAA,GAA2B,qBAAqB,CAAC,KAAK,EAAC,GAAI,qBAAqB,CAAC;YACtG,MAAM,MAAA,GAAS;gBAAE,KAAK,EAAE,eAAe;gBAAE,cAAc,EAAE,iBAAA;YAAA,CAAmB;YAE5E,MAAM,OAAO,kBAAkB,CAAC,OAAO,EAAE,MAAM,CAAC;YAEtD,mCAAA;YACM,MAAM,OAAO,KACV,WAAW,CAAC,uCAAuC,EACnD,WAAW,CAAC,iCAAiC,EAC7C,WAAW,CAAC,2CAA2C,CAAC;YAE3D,iBAAiB,CAAC,eAAe,EAAE,IAAI,CAAC;YAExC,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QAC/C;IACJ;IAEE,OAAO,oBAAA;AACT;AC7DA;;;CAGA,GACO,SAAS,qBAAqB,CAAC,KAAK,EAA8B;IACvE,MAAM,OAAO,GAAY,IAAI,GAAG,EAAoB;IAEpD,KAAK,MAAM,IAAA,IAAQ,KAAK,CAAE;QACxB,6BAA6B,CAAC,OAAO,EAAE,IAAI,CAAC;IAC9C;IAEA,OAAO,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,SAAU,CAAC,GAAG,EAAE,QAAQ,CAAC,EAAE;QACpD,OAAO,QAAQ;IACjB,CAAC,CAAC;AACJ;AAEA;;CAEA,GACO,SAAS,gBAAgB,CAAC,IAAI,EAAoC;IACvE,MAAM,cAAA,GAAiB,IAAI,CAAC,UAAU,CAAC,0CAA0C,CAAA,KAAM,IAAI;IAC7F,oEAAA;IACA,iDAAA;IACE,OAAO,CAAC,cAAA,GAAiB,eAAe,CAAC,IAAI,CAAA,GAAI,SAAS;AAC5D;AAEA,SAAS,6BAA6B,CAAC,OAAO,EAAW,IAAI,EAAsB;IACjF,MAAM,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM;IACpC,MAAM,QAAA,GAAW,gBAAgB,CAAC,IAAI,CAAC;IAEvC,IAAI,CAAC,QAAQ,EAAE;QACb,kBAAkB,CAAC,OAAO,EAAE;YAAE,EAAE;YAAE,IAAI;YAAE,QAAQ,EAAE,EAAC;QAAA,CAAG,CAAC;QACvD;IACF;IAEF,+CAAA;IACA,2FAAA;IACE,MAAM,aAAa,qBAAqB,CAAC,OAAO,EAAE,QAAQ,CAAC;IAC3D,MAAM,IAAA,GAAO,kBAAkB,CAAC,OAAO,EAAE;QAAE,EAAE;QAAE,IAAI;QAAE,UAAU;QAAE,QAAQ,EAAE,EAAC;IAAA,CAAG,CAAC;IAChF,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;AAChC;AAEA,SAAS,qBAAqB,CAAC,OAAO,EAAW,EAAE,EAAoB;IACrE,MAAM,WAAW,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;IAEhC,IAAI,QAAQ,EAAE;QACZ,OAAO,QAAQ;IACjB;IAEA,OAAO,kBAAkB,CAAC,OAAO,EAAE;QAAE,EAAE;QAAE,QAAQ,EAAE,EAAC;IAAA,CAAG,CAAC;AAC1D;AAEA,SAAS,kBAAkB,CAAC,OAAO,EAAW,QAAQ,EAAsB;IAC1E,MAAM,QAAA,GAAW,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;IAE3C,6CAAA;IACE,IAAI,QAAQ,EAAE,IAAI,EAAE;QAClB,OAAO,QAAQ;IACjB;IAEF,qDAAA;IACE,IAAI,QAAA,IAAY,CAAC,QAAQ,CAAC,IAAI,EAAE;QAC9B,QAAQ,CAAC,IAAA,GAAO,QAAQ,CAAC,IAAI;QAC7B,QAAQ,CAAC,UAAA,GAAa,QAAQ,CAAC,UAAU;QACzC,OAAO,QAAQ;IACjB;IAEF,+BAAA;IACE,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC;IAClC,OAAO,QAAQ;AACjB;ACxEA,+GAAA;AACA,MAAM,0BAA0B,GAA0C;IACxE,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,eAAe;IACpB,GAAG,EAAE,kBAAkB;IACvB,GAAG,EAAE,mBAAmB;IACxB,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,gBAAgB;IACrB,GAAG,EAAE,mBAAmB;IACxB,GAAG,EAAE,oBAAoB;IACzB,GAAG,EAAE,qBAAqB;IAC1B,IAAI,EAAE,SAAS;IACf,IAAI,EAAE,cAAc;IACpB,IAAI,EAAE,eAAe;IACrB,IAAI,EAAE,gBAAgB;IACtB,IAAI,EAAE,aAAa;IACnB,IAAI,EAAE,WAAW;IACjB,IAAI,EAAE,iBAAiB;AACzB,CAAA;AAEA,MAAM,yBAAA,GAA4B,CAAC,OAAO,KAAsB;IAC9D,OAAO,MAAM,CAAC,MAAM,CAAC,0BAA0B,CAAC,CAAC,QAAQ,CAAC,OAAA,EAAiC;AAC7F,CAAC;AAED;;CAEA,GACO,SAAS,SAAS,CAAC,IAAI,EAA4B;IACxD,MAAM,UAAA,GAAa,iBAAiB,CAAC,IAAI,CAAA,GAAI,IAAI,CAAC,UAAA,GAAa,CAAA,CAAE;IACjE,MAAM,MAAA,GAAS,aAAa,CAAC,IAAI,CAAA,GAAI,IAAI,CAAC,MAAA,GAAS,SAAS;IAE5D,IAAI,MAAM,EAAE;QACd,sIAAA;QACI,IAAI,MAAM,CAAC,IAAA,KAASG,IAAAA,cAAc,CAAC,EAAE,EAAE;YACrC,OAAO;gBAAE,IAAI,EAAES,KAAAA,cAAAA;YAAAA,CAAgB;QACrC,yEAAA;QACI,CAAA,MAAO,IAAI,MAAM,CAAC,IAAA,KAAST,IAAAA,cAAc,CAAC,KAAK,EAAE;YAC/C,IAAI,OAAO,MAAM,CAAC,OAAA,KAAY,WAAW,EAAE;gBACzC,MAAM,cAAA,GAAiB,yBAAyB,CAAC,UAAU,CAAC;gBAC5D,IAAI,cAAc,EAAE;oBAClB,OAAO,cAAc;gBACvB;YACF;YAEA,IAAI,MAAM,CAAC,OAAA,IAAW,yBAAyB,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;gBAC/D,OAAO;oBAAE,IAAI,EAAEU,KAAAA,iBAAiB;oBAAE,OAAO,EAAE,MAAM,CAAC,OAAA;gBAAA,CAAS;YAC7D,OAAO;gBACL,OAAO;oBAAE,IAAI,EAAEA,KAAAA,iBAAiB;oBAAE,OAAO,EAAE,gBAAA;gBAAA,CAAkB;YAC/D;QACF;IACF;IAEF,kFAAA;IACE,MAAM,cAAA,GAAiB,yBAAyB,CAAC,UAAU,CAAC;IAE5D,IAAI,cAAc,EAAE;QAClB,OAAO,cAAc;IACvB;IAEF,gDAAA;IACE,IAAI,MAAM,EAAE,SAASV,IAAAA,cAAc,CAAC,KAAK,EAAE;QACzC,OAAO;YAAE,IAAI,EAAES,KAAAA,cAAAA;QAAAA,CAAgB;IACjC,OAAO;QACL,OAAO;YAAE,IAAI,EAAEC,KAAAA,iBAAiB;YAAE,OAAO,EAAE,eAAA;QAAA,CAAiB;IAC9D;AACF;AAEA,SAAS,yBAAyB,CAAC,UAAU,EAA0C;IACvF,kFAAA;IAEA,mDAAA;IACE,MAAM,iBAAA,GAAoB,UAAU,CAACC,oBAAAA,8BAA8B,CAAA,IAAK,UAAU,CAACC,oBAAAA,yBAAyB,CAAC;IAC/G,mDAAA;IACE,MAAM,iBAAA,GAAoB,UAAU,CAACC,oBAAAA,6BAA6B,CAAC;IAEnE,MAAM,cAAA,GACJ,OAAO,sBAAsB,WACzB,oBACA,OAAO,iBAAA,KAAsB,WAC3B,QAAQ,CAAC,iBAAiB,IAC1B,SAAS;IAEjB,IAAI,OAAO,cAAA,KAAmB,QAAQ,EAAE;QACtC,OAAOC,KAAAA,yBAAyB,CAAC,cAAc,CAAC;IAClD;IAEA,IAAI,OAAO,iBAAA,KAAsB,QAAQ,EAAE;QACzC,OAAO;YAAE,IAAI,EAAEJ,KAAAA,iBAAiB;YAAE,OAAO,EAAE,0BAA0B,CAAC,iBAAiB,CAAA,IAAK;QAAA,CAAiB;IAC/G;IAEA,OAAO,SAAS;AAClB;AC9DA,MAAM,cAAA,GAAiB,IAAI;AAC3B,MAAM,eAAA,GAAkB,GAAG,CAAA,CAAA,QAAA;AAO3B;;CAEA,GACO,MAAM,kBAAA,CAAmB;IAChC;;;;;;;;;;;;;;;GAeA,GAKA,mFAAA;IACA,+DAAA;IAEA,iHAAA,GAGS,WAAW,CAAC,OAAA,CAGhB;QACD,IAAI,CAAC,uBAAA,GAA0B,OAAO,EAAE,OAAA,IAAW,eAAe;QAClE,IAAI,CAAC,oBAAA,GAAuB,IAAI,KAAK,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC;QACnF,IAAI,CAAC,wBAAA,GAA2B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAC,GAAI,IAAI,CAAC;QAC7D,IAAI,CAAC,mBAAA,GAAsB,IAAI,OAAO,EAAE;QACxC,IAAI,CAAC,UAAA,GAAa,IAAI,GAAG,EAAkB;QAC3C,IAAI,CAAC,eAAA,GAAkBK,KAAAA,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;YAAE,OAAO,EAAE,GAAA;QAAA,CAAK,CAAC;IAC7E;IAEF;;;GAGA,GACS,MAAM,CAAC,IAAI,EAAsB;QACtC,MAAM,mBAAA,GAAsB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAC,GAAI,IAAI,CAAC;QAEzD,IAAI,IAAI,CAAC,wBAAA,KAA6B,mBAAmB,EAAE;YACzD,IAAI,gBAAA,GAAmB,CAAC;YACxB,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK;gBAC/C,IAAI,MAAA,IAAU,MAAM,CAAC,YAAA,IAAgB,mBAAA,GAAsB,IAAI,CAAC,uBAAuB,EAAE;oBACvF,oBAAoB,MAAM,CAAC,KAAK,CAAC,IAAI;oBACrC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAA,GAAI,SAAS;gBAC1C;YACF,CAAC,CAAC;YACF,IAAI,gBAAA,GAAmB,CAAC,EAAE;gBACxB,WAAA,IACE/B,KAAAA,KAAK,CAAC,GAAG,CACP,CAAC,qBAAqB,EAAE,gBAAgB,CAAC,+CAA+C,EAAE,IAAI,CAAC,uBAAuB,CAAC,SAAS,CAAC;YAEvI;YACA,IAAI,CAAC,wBAAA,GAA2B,mBAAmB;QACrD;QAEA,MAAM,kBAAA,GAAqB,sBAAsB,IAAI,CAAC,uBAAuB;QAC7E,MAAM,gBAAgB,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAA,IAAK;YACrE,YAAY,EAAE,mBAAmB;YACjC,KAAK,EAAE,IAAI,GAAG,EAAE;QACtB,CAAK;QACD,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAA,GAAI,aAAa;QAC7D,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC;QAC7B,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,aAAa,CAAC;QAErD,uGAAA;QACI,MAAM,aAAA,GAAgB,gBAAgB,CAAC,IAAI,CAAC;QAC5C,IAAI,CAAC,aAAA,IAAiB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE;YACxD,IAAI,CAAC,eAAe,EAAE;QACxB;IACF;IAEF;;;;GAIA,GACS,KAAK,GAAS;QACnB,MAAM,aAAA,GAAgB,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAC,MAAA,GAAW,MAAA,GAAS,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAA,GAAI,EAAE,CAAC,CAAC;QAE3G,IAAI,CAAC,mBAAmB,EAAE;QAC1B,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;QAEhD,MAAM,aAAA,GAAgB,SAAS,CAAC,IAAI;QACpC,MAAM,sBAAA,GAAyB,aAAa,CAAC,MAAA,GAAS,aAAa;QACnE,WAAA,IACEA,KAAAA,KAAK,CAAC,GAAG,CACP,CAAC,sBAAsB,EAAE,aAAa,CAAC,QAAQ,EAAE,sBAAsB,CAAC,mDAAmD,CAAC;QAGhI,MAAM,cAAA,GAAiB,IAAI,CAAC,GAAG,EAAC,GAAI,eAAA,GAAkB,IAAI;QAE1D,KAAK,MAAM,IAAA,IAAQ,SAAS,CAAE;YAC5B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM,EAAE,cAAc,CAAC;YAC9D,MAAM,WAAA,GAAc,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC;YACtD,IAAI,WAAW,EAAE;gBACf,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;YAChC;QACF;QACJ,oDAAA;QACA,wEAAA;QACA,8DAAA;QACI,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;IAC/B;IAEF;;;GAGA,GACS,KAAK,GAAS;QACnB,IAAI,CAAC,oBAAA,GAAuB,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC;QACrE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;QACvB,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;IAC/B;IAEF;;;;;;;;GAQA,GACU,UAAU,CAAC,KAAK,EAAqC;QAC3D,MAAM,OAAA,GAAU,qBAAqB,CAAC,KAAK,CAAC;QAC5C,MAAM,SAAA,GAAY,IAAI,GAAG,EAAgB;QAEzC,MAAM,YAAY,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;QAEtD,KAAK,MAAM,IAAA,IAAQ,SAAS,CAAE;YAC5B,MAAM,IAAA,GAAO,IAAI,CAAC,IAAI;YACtB,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC;YACnB,MAAM,gBAAA,GAAmB,4BAA4B,CAAC,IAAI,CAAC;YAEjE,yGAAA;YACM,IAAI,IAAI,CAAC,UAAA,IAAc,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;gBAC9D,MAAM,YAAY,gBAAgB,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI;gBACxD,IAAI,SAAS,EAAE;oBACb,SAAS,CAAC,iCAAiC,CAAA,GAAI,IAAI;gBACrD;YACF;YAEN,0DAAA;YACM,MAAM,QAAQ,gBAAgB,CAAC,KAAA,IAAS,EAAE;YAE1C,KAAK,MAAM,KAAA,IAAS,IAAI,CAAC,QAAQ,CAAE;gBACjC,8BAA8B,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC;YACzD;YAEN,kFAAA;YACA,kCAAA;YACM,gBAAgB,CAAC,KAAA,GACf,KAAK,CAAC,MAAA,GAAS,iBACX,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,GAAK,CAAC,CAAC,eAAA,GAAkB,CAAC,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,cAAc,IACnF,KAAK;YAEX,MAAM,eAAegC,KAAAA,yBAAyB,CAAC,IAAI,CAAC,MAAM,CAAC;YAC3D,IAAI,YAAY,EAAE;gBAChB,gBAAgB,CAAC,YAAA,GAAe,YAAY;YAC9C;YAEAC,KAAAA,YAAY,CAAC,gBAAgB,CAAC;QAChC;QAEA,OAAO,SAAS;IAClB;IAEF,gEAAA,GACU,mBAAmB,GAAS;QAClC,MAAM,gBAAA,GAAmB,IAAI,CAAC,GAAG,EAAE;QACvC,qGAAA;QACI,KAAK,MAAM,CAAC,MAAM,EAAE,cAAc,CAAA,IAAK,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAE;YAChE,IAAI,cAAA,IAAkB,gBAAgB,EAAE;gBACtC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC;YAChC;QACF;IACF;IAEF,0FAAA,GACU,uCAAuC,CAAC,IAAI,EAAuC;QACzF,OAAO,CAAC,CAAC,IAAI,CAAC,IAAA,IAAA,CAAS,CAAC,IAAI,CAAC,UAAA,IAAc,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACrF;IAEF,sDAAA,GACU,sBAAsB,CAAC,KAAK,EAAmC;QACzE,wFAAA;QACA,yCAAA;QACI,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,GAAgC,IAAI,CAAC,uCAAuC,CAAC,IAAI,CAAC,CAAC;IAC9G;AACF;AAEA,SAAS,SAAS,CAAC,IAAI,EAAkF;IACvG,MAAM,UAAA,GAAa,IAAI,CAAC,UAAU;IAElC,MAAM,MAAA,GAAS,UAAU,CAAC5C,KAAAA,gCAAgC,CAAA;IAC1D,MAAM,EAAA,GAAK,UAAU,CAACP,KAAAA,4BAA4B,CAAA;IAClD,MAAM,MAAA,GAAS,UAAU,CAACC,KAAAA,gCAAgC,CAAA;IAE1D,OAAO;QAAE,MAAM;QAAE,EAAE;QAAE;IAAA,CAAQ;AAC/B;AAEA,6BAAA,GACO,SAAS,4BAA4B,CAAC,IAAI,EAAkC;IACjF,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,MAAA,GAAS,QAAQ,EAAE,MAAA,EAAO,GAAI,WAAW,CAAC,IAAI,CAAC;IAC9E,MAAM,kBAAA,GAAqBsC,KAAAA,uBAAuB,CAAC,MAAwB;IAE3E,MAAM,aAAa,IAAI,CAAC,UAAU,CAACa,KAAAA,qCAAqC,CAAA;IAExE,MAAM,UAAU,GAAmB;QACjC,CAACnD,KAAAA,gCAAgC,CAAA,EAAG,MAAM;QAC1C,CAACmD,KAAAA,qCAAqC,CAAA,EAAG,UAAU;QACnD,CAACpD,KAAAA,4BAA4B,CAAA,EAAG,EAAE;QAClC,CAACO,KAAAA,gCAAgC,CAAA,EAAG,MAAM;QAC1C,GAAG,IAAI;QACP,GAAG,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC;IAC9C,CAAG;IAED,MAAM,EAAE,KAAA,EAAM,GAAI,IAAI;IACtB,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAA,EAAA,GAAY,IAAI,CAAC,WAAW,EAAE;IAEnE,iFAAA;IACA,8EAAA;IACA,qCAAA;IACA,kHAAA;IACA,gFAAA;IACE,MAAM,cAAA,GAAiB,eAAe,CAAC,IAAI,CAAC;IAE5C,MAAM,MAAA,GAAS,SAAS,CAAC,IAAI,CAAC;IAE9B,MAAM,YAAY,GAAiB;QACjC,cAAc;QACd,OAAO;QACP,QAAQ;QACR,IAAI,EAAE,UAAU;QAChB,MAAM;QACN,EAAE;QACF,MAAM,EAAE8C,KAAAA,gBAAgB,CAAC,MAAM,CAAC;QAChC,KAAK,EAAEC,KAAAA,2BAA2B,CAAC,KAAK,CAAC;IAC7C,CAAG;IAED,MAAM,UAAA,GAAa,UAAU,CAACT,oBAAAA,8BAA8B,CAAC;IAC7D,MAAM,eAAA,GAAkB,OAAO,UAAA,KAAe,WAAW;QAAE,QAAQ,EAAE;YAAE,WAAW,EAAE;QAAA,CAAW;IAAA,CAAE,GAAI,SAAS;IAE9G,MAAM,gBAAgB,GAAqB;QACzC,QAAQ,EAAE;YACR,KAAK,EAAE,YAAY;YACnB,IAAI,EAAE;gBACJ,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU;YAC1C,CAAO;YACD,GAAG,eAAe;QACxB,CAAK;QACD,KAAK,EAAE,EAAE;QACT,eAAe,EAAEU,KAAAA,sBAAsB,CAAC,IAAI,CAAC,SAAS,CAAC;QACvD,SAAS,EAAEA,KAAAA,sBAAsB,CAAC,IAAI,CAAC,OAAO,CAAC;QAC/C,WAAW,EAAE,WAAW;QACxB,IAAI,EAAE,aAAa;QACnB,qBAAqB,EAAE;YACrB,iBAAiB,EAAE,kBAAkB,CAAC,KAAK;YAC3C,0BAA0B,EAAE,kBAAkB,CAAC,cAAc;YAC7D,UAAU;YACV,sBAAsB,EAAE9B,KAAAA,iCAAiC,CAAC,MAAwB;QACxF,CAAK;QACD,GAAI,MAAA,IAAU;YACZ,gBAAgB,EAAE;gBAChB,MAAM;YACd,CAAO;QACP,CAAK,CAAC;IACN,CAAG;IAED,OAAO,gBAAgB;AACzB;AAEA,SAAS,8BAA8B,CAAC,IAAI,EAAY,KAAK,EAAc,SAAS,EAA2B;IAC7G,MAAM,IAAA,GAAO,IAAI,CAAC,IAAI;IAEtB,IAAI,IAAI,EAAE;QACR,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC;IACrB;IAEA,MAAM,UAAA,GAAa,CAAC,IAAI;IAE1B,yFAAA;IACE,IAAI,UAAU,EAAE;QACd,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAC,SAAS;YAC7B,8BAA8B,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC;QACzD,CAAC,CAAC;QACF;IACF;IAEA,MAAM,UAAU,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM;IACzC,MAAM,WAAW,IAAI,CAAC,WAAW,EAAE,CAAC,OAAO;IAC3C,MAAM,YAAA,GAAe,eAAe,CAAC,IAAI,CAAC;IAE1C,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,OAAO,EAAE,KAAA,EAAM,GAAI,IAAI;IAEtD,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,MAAA,GAAS,QAAA,EAAS,GAAI,WAAW,CAAC,IAAI,CAAC;IACtE,MAAM,UAAU;QACd,CAAClB,KAAAA,gCAAgC,CAAA,EAAG,MAAM;QAC1C,CAACP,KAAAA,4BAA4B,CAAA,EAAG,EAAE;QAClC,GAAG,sBAAsB,CAAC,UAAU,CAAC;QACrC,GAAG,IAAI;IACX,CAAG;IAED,MAAM,MAAA,GAAS,SAAS,CAAC,IAAI,CAAC;IAE9B,MAAM,QAAQ,GAAa;QACzB,OAAO;QACP,QAAQ;QACR,IAAI,EAAE,OAAO;QACb,WAAW;QACX,cAAc,EAAE,YAAY;QAC5B,eAAe,EAAEuD,KAAAA,sBAAsB,CAAC,SAAS,CAAC;QACtD,2FAAA;QACI,SAAS,EAAEA,KAAAA,sBAAsB,CAAC,OAAO,CAAA,IAAK,SAAS;QACvD,MAAM,EAAEF,KAAAA,gBAAgB,CAAC,MAAM,CAAC;QAChC,EAAE;QACF,MAAM;QACN,YAAY,EAAEH,KAAAA,yBAAyB,CAAC,IAAI,CAAC,MAAM,CAAC;QACpD,KAAK,EAAEI,KAAAA,2BAA2B,CAAC,KAAK,CAAC;IAC7C,CAAG;IAED,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;IAEpB,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAC,SAAS;QAC7B,8BAA8B,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC;IACzD,CAAC,CAAC;AACJ;AAEA,SAAS,WAAW,CAAC,IAAI;IAOvB,MAAM,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,aAAa,EAAE,MAAA,EAAO,GAAI,SAAS,CAAC,IAAI,CAAC;IACxE,MAAM,EAAE,EAAE,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,YAAA,EAAa,GAAI,oBAAoB,CAAC,IAAI,CAAC;IAE9G,MAAM,EAAA,GAAK,SAAA,IAAa,UAAU;IAClC,MAAM,MAAA,GAAS,aAAA,IAAiB,cAAc;IAE9C,MAAM,IAAA,GAAO;QAAE,GAAG,YAAY;QAAE,GAAG,OAAO,CAAC,IAAI,CAAA;IAAA,CAAG;IAElD,OAAO;QACL,EAAE;QACF,WAAW;QACX,MAAM;QACN,MAAM;QACN,IAAI;IACR,CAAG;AACH;AAEA;;;CAGA,GACA,SAAS,sBAAsB,CAAC,IAAI,EAAoD;IACtF,MAAM,WAAA,GAAc;QAAE,GAAG,IAAA;IAAA,CAAM;IAEjC,uDAAA,GACE,OAAO,WAAW,CAACF,KAAAA,qCAAqC,CAAC;IACzD,OAAO,WAAW,CAAC,0CAA0C,CAAC;IAC9D,OAAO,WAAW,CAAC/C,KAAAA,0CAA0C,CAAC;IAChE,sDAAA,GAEE,OAAO,WAAW;AACpB;AAEA,SAAS,OAAO,CAAC,IAAI,EAAyC;IAC5D,MAAM,UAAA,GAAa,IAAI,CAAC,UAAU;IAClC,MAAM,IAAI,GAA4B,CAAA,CAAE;IAExC,IAAI,IAAI,CAAC,IAAA,KAASb,IAAAA,QAAQ,CAAC,QAAQ,EAAE;QACnC,IAAI,CAAC,WAAW,CAAA,GAAIA,IAAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IACzC;IAEF,mDAAA;IACE,MAAM,4BAAA,GAA+B,UAAU,CAACsD,oBAAAA,yBAAyB,CAAC;IAC1E,IAAI,4BAA4B,EAAE;QAChC,IAAI,CAACD,oBAAAA,8BAA8B,CAAA,GAAI,4BAAA;IACzC;IAEA,MAAM,WAAA,GAAc,kBAAkB,CAAC,IAAI,CAAC;IAE5C,IAAI,WAAW,CAAC,GAAG,EAAE;QACnB,IAAI,CAAC,GAAA,GAAM,WAAW,CAAC,GAAG;IAC5B;IAEA,IAAI,WAAW,CAAC,YAAY,CAAC,EAAE;QAC7B,IAAI,CAAC,YAAY,CAAA,GAAI,WAAW,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IACzD;IACA,IAAI,WAAW,CAAC,eAAe,CAAC,EAAE;QAChC,IAAI,CAAC,eAAe,CAAA,GAAI,WAAW,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAC/D;IAEA,OAAO,IAAI;AACb;ACtbA,SAAS,WAAW,CAAC,IAAI,EAAQ,aAAa,EAAiB;IAC/D,uHAAA;IACE,MAAM,aAAatD,IAAAA,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC;IAE/C,IAAI,MAAA,GAAS,oBAAoB,CAAC,aAAa,CAAC;IAElD,iGAAA;IACE,IAAI,UAAA,IAAc,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,QAAQ,EAAE;QACpDiE,KAAAA,kBAAkB,CAAC,UAAU,EAAE,IAAI,CAAC;IACtC;IAEF,oCAAA;IACE,IAAI,UAAU,EAAE,WAAW,EAAE,CAAC,QAAQ,EAAE;QACtC,IAAI,CAAC,YAAY,CAAC,0CAA0C,EAAE,IAAI,CAAC;IACrE;IAEF,kFAAA;IACA,0CAAA;IACE,IAAI,aAAA,KAAkBC,IAAAA,YAAY,EAAE;QAClC,SAAS;YACP,KAAK,EAAEjB,KAAAA,sBAAsB,EAAE;YAC/B,cAAc,EAAEC,KAAAA,wBAAwB,EAAE;QAChD,CAAK;IACH;IAEF,yGAAA;IACE,IAAI,MAAM,EAAE;QACViB,KAAAA,uBAAuB,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,cAAc,CAAC;IACpE;IAEAC,KAAAA,YAAY,CAAC,IAAI,CAAC;IAElB,MAAM,MAAA,GAAS/D,KAAAA,SAAS,EAAE;IAC1B,MAAM,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC;AACjC;AAEA,SAAS,SAAS,CAAC,IAAI,EAAc;IACnCgE,KAAAA,UAAU,CAAC,IAAI,CAAC;IAEhB,MAAM,MAAA,GAAShE,KAAAA,SAAS,EAAE;IAC1B,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC;AAC/B;AAEA;;;CAGA,GACO,MAAM,qBAAsD;IAG1D,WAAW,CAAC,OAAO,CAAyB;QACjD,UAAU,CAAC,qBAAqB,CAAC;QACjC,IAAI,CAAC,SAAA,GAAY,IAAI,kBAAkB,CAAC,OAAO,CAAC;IAClD;IAEF;;GAEA,GACS,MAAM,UAAU,GAAkB;QACvC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;IACxB;IAEF;;GAEA,GACS,MAAM,QAAQ,GAAkB;QACrC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;IACxB;IAEF;;GAEA,GACS,OAAO,CAAC,IAAI,EAAQ,aAAa,EAAiB;QACvD,WAAW,CAAC,IAAI,EAAE,aAAa,CAAC;IAClC;IAEF,gBAAA,GACS,KAAK,CAAC,IAAI,EAA6B;QAC5C,SAAS,CAAC,IAAI,CAAC;QAEf,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC;IAC7B;AACF;AChEA;;CAEA,GACO,MAAM,eAAiC;IAGrC,WAAW,CAAC,MAAM,CAAU;QACjC,IAAI,CAAC,OAAA,GAAU,MAAM;QACrB,UAAU,CAAC,eAAe,CAAC;IAC7B;IAEF,gBAAA,GACS,YAAY,CACjB,OAAO,EACP,OAAO,EACP,QAAQ,EACR,QAAQ,EACR,cAAc,EACd,MAAM,EACU;QAChB,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;QAEzC,MAAM,UAAA,GAAa,YAAY,CAAC,OAAO,CAAC;QACxC,MAAM,aAAA,GAAgB,UAAU,EAAE,WAAW,EAAE;QAE/C,IAAI,CAACgB,KAAAA,eAAe,CAAC,OAAO,CAAC,EAAE;YAC7B,OAAO,oBAAoB,CAAC;gBAAE,QAAQ,EAAE,SAAS;gBAAE,OAAO;gBAAE,cAAA;YAAA,CAAgB,CAAC;QAC/E;QAEJ,sHAAA;QACA,mDAAA;QACI,MAAM,mBAAA,GAAsB,cAAc,CAACzB,oBAAAA,oBAAoB,CAAA,IAAK,cAAc,CAACD,oBAAAA,wBAAwB,CAAC;QAEhH,qFAAA;QACA,sEAAA;QACI,IAAI,QAAA,KAAaM,IAAAA,QAAQ,CAAC,MAAA,IAAU,mBAAA,IAAA,CAAwB,CAAC,UAAA,IAAc,aAAa,EAAE,QAAQ,CAAC,EAAE;YACnG,OAAO,oBAAoB,CAAC;gBAAE,QAAQ,EAAE,SAAS;gBAAE,OAAO;gBAAE,cAAA;YAAA,CAAgB,CAAC;QAC/E;QAEA,MAAM,aAAA,GAAgB,UAAA,GAAa,gBAAgB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAA,GAAI,SAAS;QAC9F,MAAM,aAAa,CAAC,cAAc,aAAa,EAAE,QAAQ;QAE7D,4HAAA;QACA,yEAAA;QACI,IAAI,CAAC,UAAU,EAAE;YACf,OAAO,oBAAoB,CAAC;gBAC1B,QAAQ,EAAE,aAAA,GAAgBqE,aAAAA,gBAAgB,CAAC,kBAAA,GAAqBA,aAAAA,gBAAgB,CAAC,UAAU;gBAC3F,OAAO;gBACP,cAAc;YACtB,CAAO,CAAC;QACJ;QAEJ,uEAAA;QACI,MAAM,EACJ,WAAW,EAAE,gBAAgB,EAC7B,IAAI,EAAE,kBAAkB,EACxB,EAAE,EACJ,GAAI,aAAa,CAAC,QAAQ,EAAE,cAAc,EAAE,QAAQ,CAAC;QAErD,MAAM,mBAAmB;YACvB,GAAG,kBAAkB;YACrB,GAAG,cAAc;QACvB,CAAK;QAED,IAAI,EAAE,EAAE;YACN,gBAAgB,CAAC7D,KAAAA,4BAA4B,CAAA,GAAI,EAAE;QACrD;QAEA,MAAM,uBAAA,GAA0B;YAAE,QAAQ,EAAE;QAAA,CAAM;QAClD,IAAI,CAAC,OAAO,CAAC,IAAI,CACf,gBAAgB,EAChB;YACE,cAAc,EAAE,gBAAgB;YAChC,QAAQ,EAAE,gBAAgB;YAC1B,aAAa,EAAE,aAAa;YAC5B,aAAa,EAAE,aAAa;QACpC,CAAO,EACD,uBAAuB;QAEzB,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE;YACrC,OAAO,oBAAoB,CAAC;gBAAE,QAAQ,EAAE,SAAS;gBAAE,OAAO;gBAAE,cAAA;YAAA,CAAgB,CAAC;QAC/E;QAEA,MAAM,EAAE,cAAA,EAAe,GAAI,oBAAoB,CAAC,OAAO,CAAA,IAAK,CAAA,CAAE;QAE9D,MAAM,SAAA,GAAY,aAAa,EAAE,aAAa,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,sBAAsB,CAAA,GAAI,SAAS;QAC9G,MAAM,GAAA,GAAM,SAAA,GAAYF,KAAAA,qCAAqC,CAAC,SAAS,CAAA,GAAI,SAAS;QAEpF,MAAM,UAAA,GAAagE,KAAAA,eAAe,CAAC,GAAG,EAAE,WAAW,CAAA,IAAK,IAAI,CAAC,MAAM,EAAE;QAErE,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,yBAAyB,CAAA,GAAIC,KAAAA,UAAU,CACjE,OAAO,EACP;YACE,IAAI,EAAE,gBAAgB;YACtB,UAAU,EAAE,gBAAgB;YAC5B,iBAAiB,EAAE,cAAc,EAAE,YAAY,EAAE,CAAC,qBAAqB,CAAC,iBAAiB;YACzF,aAAa;YACb,gBAAgB,EAAED,KAAAA,eAAe,CAAC,GAAG,EAAE,WAAW,CAAC;QAC3D,CAAO,EACD,UAAU;QAGZ,MAAM,MAAA,GAAS,CAAC,EAAA,mBAAA,CAAA,CAAA,CAAA,WAAA,EAAA;QACA,IAAA,MAAA,KAAA,SAAA,IAAA,MAAA,KAAA,MAAA,EAAA;YACA,WAAA,IAAA5C,KAAAA,KAAA,CAAA,GAAA,CAAA,CAAA,oDAAA,EAAA,MAAA,CAAA,MAAA,EAAA,QAAA,CAAA,CAAA,CAAA;YAEA,OAAA,oBAAA,CAAA;gBACA,QAAA,EAAA2C,aAAAA,gBAAA,CAAA,UAAA;gBACA,OAAA;gBACA,cAAA;gBACA,UAAA;gBACA,yBAAA,EAAA,CAAA;YACA,CAAA,CAAA;QACA;QAEA,IACA,CAAA,OAAA,IACA,8JAAA;QACA,aAAA,KAAA,WACA;YACA,WAAA,IAAA3C,KAAAA,KAAA,CAAA,GAAA,CAAA,gFAAA,CAAA;YACA,IAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,aAAA,EAAA,aAAA,CAAA;QACA;QAEA,OAAA;YACA,GAAA,oBAAA,CAAA;gBACA,QAAA,EAAA,OAAA,GAAA2C,aAAAA,gBAAA,CAAA,kBAAA,GAAAA,aAAAA,gBAAA,CAAA,UAAA;gBACA,OAAA;gBACA,cAAA;gBACA,UAAA;gBACA,yBAAA,EAAA,yBAAA,GAAA,UAAA,GAAA,SAAA;YACA,CAAA,CAAA;YACA,UAAA,EAAA;gBACA,iIAAA;gBACA,CAAAT,KAAAA,qCAAA,CAAA,EAAA,yBAAA,GAAA,UAAA,GAAA,SAAA;YACA,CAAA;QACA,CAAA;IACA;IAEA,0EAAA,GACA,QAAA,GAAA;QACA,OAAA,eAAA;IACA;AACA;AAEA,SAAA,gBAAA,CAAA,UAAA,EAAA,OAAA,EAAA,QAAA,EAAA;IACA,MAAA,aAAA,GAAA,UAAA,CAAA,WAAA,EAAA;IAEA,oDAAA;IACA,kHAAA;IACA,IAAAY,IAAAA,kBAAA,CAAA,aAAA,CAAA,IAAA,aAAA,CAAA,OAAA,KAAA,OAAA,EAAA;QACA,IAAA,aAAA,CAAA,QAAA,EAAA;YACA,MAAA,aAAA,GAAA,mBAAA,CAAA,UAAA,CAAA,WAAA,EAAA,CAAA;YACA,WAAA,IACA9C,KAAAA,KAAA,CAAA,GAAA,CAAA,CAAA,0DAAA,EAAA,QAAA,CAAA,EAAA,EAAA,aAAA,CAAA,CAAA,CAAA;YACA,OAAA,aAAA;QACA;QAEA,MAAA,aAAA,GAAA,mBAAA,CAAA,aAAA,CAAA;QACA,WAAA,IAAAA,KAAAA,KAAA,CAAA,GAAA,CAAA,CAAA,mDAAA,EAAA,QAAA,CAAA,EAAA,EAAA,aAAA,CAAA,CAAA,CAAA;QACA,OAAA,aAAA;IACA;IAEA,OAAA,SAAA;AACA;AAEA;;;;CAIA,GACA,SAAA,oBAAA,CAAA,EACA,QAAA,EACA,OAAA,EACA,cAAA,EACA,UAAA,EACA,yBAAA,EACA;IAOA,IAAA,UAAA,GAAA,iBAAA,CAAA,OAAA,EAAA,cAAA,CAAA;IAEA,8DAAA;IACA,oCAAA;IACA,iCAAA;IACA,qHAAA;IACA,IAAA,yBAAA,KAAA,SAAA,EAAA;QACA,UAAA,GAAA,UAAA,CAAA,GAAA,CAAA,8BAAA,EAAA,CAAA,EAAA,yBAAA,CAAA,CAAA,CAAA;IACA;IAEA,IAAA,UAAA,KAAA,SAAA,EAAA;QACA,UAAA,GAAA,UAAA,CAAA,GAAA,CAAA,8BAAA,EAAA,CAAA,EAAA,UAAA,CAAA,CAAA,CAAA;IACA;IAEA,sHAAA;IACA,qFAAA;IACA,IAAA,QAAA,IAAA,SAAA,EAAA;QACA,OAAA;YAAA,QAAA,EAAA2C,aAAAA,gBAAA,CAAA,UAAA;YAAA,UAAA;QAAA,CAAA;IACA;IAEA,IAAA,QAAA,KAAAA,aAAAA,gBAAA,CAAA,UAAA,EAAA;QACA,OAAA;YAAA,QAAA;YAAA,UAAA,EAAA,UAAA,CAAA,GAAA,CAAA,wCAAA,EAAA,GAAA,CAAA;QAAA,CAAA;IACA;IAEA,OAAA;QAAA,QAAA;QAAA,UAAA;IAAA,CAAA;AACA;AAEA,SAAA,iBAAA,CAAA,OAAA,EAAA,cAAA,EAAA;IACA,MAAA,UAAA,GAAAtE,IAAAA,KAAA,CAAA,OAAA,CAAA,OAAA,CAAA;IACA,MAAA,aAAA,GAAA,UAAA,EAAA,WAAA,EAAA;IAEA,IAAA,UAAA,GAAA,aAAA,EAAA,UAAA,IAAA,IAAAuB,OAAAA,UAAA,EAAA;IAEA,mFAAA;IACA,oGAAA;IACA,mDAAA;IACA,MAAA,GAAA,GAAA,cAAA,CAAA7B,oBAAAA,iBAAA,CAAA,IAAA,cAAA,CAAAD,oBAAAA,aAAA,CAAA;IACA,IAAA,GAAA,IAAA,OAAA,GAAA,KAAA,QAAA,EAAA;QACA,UAAA,GAAA,UAAA,CAAA,GAAA,CAAA,sBAAA,EAAA,GAAA,CAAA;IACA;IAEA,OAAA,UAAA;AACA;AAEA;;;CAGA,GACA,SAAA,YAAA,CAAA,OAAA,EAAA;IACA,MAAA,IAAA,GAAAO,IAAAA,KAAA,CAAA,OAAA,CAAA,OAAA,CAAA;IACA,OAAA,IAAA,IAAAyE,IAAAA,kBAAA,CAAA,IAAA,CAAA,WAAA,EAAA,CAAA,GAAA,IAAA,GAAA,SAAA;AACA"}},
    {"offset": {"line": 1898, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/brace-expansion/index.js"],"sourcesContent":["var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2061, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/assert-valid-pattern.ts"],"sourcesContent":["const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAE,CAAA;AAC7B,MAAM,kBAAkB,GAA2B,CACxD,OAAY,EACe,EAAE;IAC7B,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,MAAM,IAAI,SAAS,CAAC,iBAAiB,CAAC,CAAA;KACvC;IAED,IAAI,OAAO,CAAC,MAAM,GAAG,kBAAkB,EAAE;QACvC,MAAM,IAAI,SAAS,CAAC,qBAAqB,CAAC,CAAA;KAC3C;AACH,CAAC,CAAA;AAVY,QAAA,kBAAkB,GAAA,mBAU9B"}},
    {"offset": {"line": 2079, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/brace-expressions.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/brace-expressions.ts"],"sourcesContent":["// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2291, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/unescape.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/unescape.ts"],"sourcesContent":["import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n"],"names":[],"mappings":";;;;AACA;;;;;;;;;;;;;GAaG,CACI,MAAM,QAAQ,GAAG,CACtB,CAAS,EACT,EACE,oBAAoB,GAAG,KAAK,EAAA,GACsB,CAAA,CAAE,EACtD,EAAE;IACF,OAAO,oBAAoB,GACvB,CAAC,CAAC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC,GACjC,CAAC,CAAC,OAAO,CAAC,2BAA2B,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC,CAAA;AAChF,CAAC,CAAA;AATY,QAAA,QAAQ,GAAA,SASpB"}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/ast.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/ast.ts"],"sourcesContent":["// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2857, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/escape.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/escape.ts"],"sourcesContent":["import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n"],"names":[],"mappings":";;;;AACA;;;;;;;;GAQG,CACI,MAAM,MAAM,GAAG,CACpB,CAAS,EACT,EACE,oBAAoB,GAAG,KAAK,EAAA,GACsB,CAAA,CAAE,EACtD,EAAE;IACF,wDAAwD;IACxD,4DAA4D;IAC5D,sDAAsD;IACtD,OAAO,oBAAoB,GACvB,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE,MAAM,CAAC,GAC/B,CAAC,CAAC,OAAO,CAAC,cAAc,EAAE,MAAM,CAAC,CAAA;AACvC,CAAC,CAAA;AAZY,QAAA,MAAM,GAAA,OAYlB"}},
    {"offset": {"line": 2880, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/node/node_modules/minimatch/dist/commonjs/index.js","sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/node/node_modules/minimatch/src/index.ts"],"sourcesContent":["import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/homedir.js"],"sourcesContent":["'use strict';\n\nvar os = require('os');\n\n// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js\n\nmodule.exports = os.homedir || function homedir() {\n    var home = process.env.HOME;\n    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n\n    if (process.platform === 'win32') {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n    }\n\n    if (process.platform === 'darwin') {\n        return home || (user ? '/Users/' + user : null);\n    }\n\n    if (process.platform === 'linux') {\n        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens\n    }\n\n    return home || null;\n};\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,iHAAiH;AAEjH,OAAO,OAAO,GAAG,GAAG,OAAO,IAAI,SAAS;IACpC,IAAI,OAAO,QAAQ,GAAG,CAAC,IAAI;IAC3B,IAAI,OAAO,QAAQ,GAAG,CAAC,OAAO,IAAI,QAAQ,GAAG,CAAC,IAAI,IAAI,QAAQ,GAAG,CAAC,KAAK,IAAI,QAAQ,GAAG,CAAC,QAAQ;IAE/F;;IAIA,wCAAmC;QAC/B,OAAO,QAAQ,CAAC,OAAO,YAAY,OAAO,IAAI;IAClD;;;AAOJ","ignoreList":[0]}},
    {"offset": {"line": 3867, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/caller.js"],"sourcesContent":["module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG;IACb,gEAAgE;IAChE,IAAI,wBAAwB,MAAM,iBAAiB;IACnD,MAAM,iBAAiB,GAAG,SAAU,CAAC,EAAE,KAAK;QAAI,OAAO;IAAO;IAC9D,IAAI,QAAQ,AAAC,IAAI,QAAS,KAAK;IAC/B,MAAM,iBAAiB,GAAG;IAC1B,OAAO,KAAK,CAAC,EAAE,CAAC,WAAW;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 3880, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/node-modules-paths.js"],"sourcesContent":["var path = require('path');\nvar parse = path.parse || require('path-parse'); // eslint-disable-line global-require\n\nvar getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {\n    var prefix = '/';\n    if ((/^([A-Za-z]:)/).test(absoluteStart)) {\n        prefix = '';\n    } else if ((/^\\\\\\\\/).test(absoluteStart)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var paths = [absoluteStart];\n    var parsed = parse(absoluteStart);\n    while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n    }\n\n    return paths.reduce(function (dirs, aPath) {\n        return dirs.concat(modules.map(function (moduleDir) {\n            return path.resolve(prefix, aPath, moduleDir);\n        }));\n    }, []);\n};\n\nmodule.exports = function nodeModulesPaths(start, opts, request) {\n    var modules = opts && opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules'];\n\n    if (opts && typeof opts.paths === 'function') {\n        return opts.paths(\n            request,\n            start,\n            function () { return getNodeModulesDirs(start, modules); },\n            opts\n        );\n    }\n\n    var dirs = getNodeModulesDirs(start, modules);\n    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n};\n"],"names":[],"mappings":"AAAA,IAAI;AACJ,IAAI,QAAQ,KAAK,KAAK,oGAA2B,qCAAqC;AAEtF,IAAI,qBAAqB,SAAS,mBAAmB,aAAa,EAAE,OAAO;IACvE,IAAI,SAAS;IACb,IAAI,AAAC,eAAgB,IAAI,CAAC,gBAAgB;QACtC,SAAS;IACb,OAAO,IAAI,AAAC,QAAS,IAAI,CAAC,gBAAgB;QACtC,SAAS;IACb;IAEA,IAAI,QAAQ;QAAC;KAAc;IAC3B,IAAI,SAAS,MAAM;IACnB,MAAO,OAAO,GAAG,KAAK,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAE;QAC3C,MAAM,IAAI,CAAC,OAAO,GAAG;QACrB,SAAS,MAAM,OAAO,GAAG;IAC7B;IAEA,OAAO,MAAM,MAAM,CAAC,SAAU,IAAI,EAAE,KAAK;QACrC,OAAO,KAAK,MAAM,CAAC,QAAQ,GAAG,CAAC,SAAU,SAAS;YAC9C,OAAO,KAAK,OAAO,CAAC,QAAQ,OAAO;QACvC;IACJ,GAAG,EAAE;AACT;AAEA,OAAO,OAAO,GAAG,SAAS,iBAAiB,KAAK,EAAE,IAAI,EAAE,OAAO;IAC3D,IAAI,UAAU,QAAQ,KAAK,eAAe,GACpC,EAAE,CAAC,MAAM,CAAC,KAAK,eAAe,IAC9B;QAAC;KAAe;IAEtB,IAAI,QAAQ,OAAO,KAAK,KAAK,KAAK,YAAY;QAC1C,OAAO,KAAK,KAAK,CACb,SACA,OACA;YAAc,OAAO,mBAAmB,OAAO;QAAU,GACzD;IAER;IAEA,IAAI,OAAO,mBAAmB,OAAO;IACrC,OAAO,QAAQ,KAAK,KAAK,GAAG,KAAK,MAAM,CAAC,KAAK,KAAK,IAAI;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 3918, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/normalize-options.js"],"sourcesContent":["module.exports = function (x, opts) {\n    /**\n     * This file is purposefully a passthrough. It's expected that third-party\n     * environments will override it at runtime in order to inject special logic\n     * into `resolve` (by manipulating the options). One such example is the PnP\n     * code path in Yarn.\n     */\n\n    return opts || {};\n};\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG,SAAU,CAAC,EAAE,IAAI;IAC9B;;;;;KAKC,GAED,OAAO,QAAQ,CAAC;AACpB","ignoreList":[0]}},
    {"offset": {"line": 3929, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/async.js"],"sourcesContent":["var fs = require('fs');\nvar getHomedir = require('./homedir');\nvar path = require('path');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\nvar isCore = require('is-core-module');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file, cb) {\n    fs.stat(file, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultIsDir = function isDirectory(dir, cb) {\n    fs.stat(dir, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isDirectory());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultRealpath = function realpath(x, cb) {\n    realpathFS(x, function (realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);\n        else cb(null, realpathErr ? x : realPath);\n    });\n};\n\nvar maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {\n    if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n    } else {\n        cb(null, x);\n    }\n};\n\nvar defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {\n    readFile(pkgfile, function (readFileErr, body) {\n        if (readFileErr) cb(readFileErr);\n        else {\n            try {\n                var pkg = JSON.parse(body);\n                cb(null, pkg);\n            } catch (jsonErr) {\n                cb(null);\n            }\n        }\n    });\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolve(x, options, callback) {\n    var cb = callback;\n    var opts = options;\n    if (typeof options === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (typeof x !== 'string') {\n        var err = new TypeError('Path must be a string.');\n        return process.nextTick(function () {\n            cb(err);\n        });\n    }\n\n    opts = normalizeOptions(x, opts);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var readFile = opts.readFile || fs.readFile;\n    var realpath = opts.realpath || defaultRealpath;\n    var readPackage = opts.readPackage || defaultReadPackage;\n    if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');\n        return process.nextTick(function () {\n            cb(conflictErr);\n        });\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = path.resolve(basedir);\n\n    maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function (err, realStart) {\n            if (err) cb(err);\n            else init(realStart);\n        }\n    );\n\n    var res;\n    function init(basedir) {\n        if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n            res = path.resolve(basedir, x);\n            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n            if ((/\\/$/).test(x) && res === basedir) {\n                loadAsDirectory(res, opts.package, onfile);\n            } else loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n            return cb(null, x);\n        } else loadNodeModules(x, basedir, function (err, n, pkg) {\n            if (err) cb(err);\n            else if (n) {\n                return maybeRealpath(realpath, n, opts, function (err, realN) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realN, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function onfile(err, m, pkg) {\n        if (err) cb(err);\n        else if (m) cb(null, m, pkg);\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err);\n            else if (d) {\n                maybeRealpath(realpath, d, opts, function (err, realD) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realD, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function loadAsFile(x, thePackage, callback) {\n        var loadAsFilePackage = thePackage;\n        var cb = callback;\n        if (typeof loadAsFilePackage === 'function') {\n            cb = loadAsFilePackage;\n            loadAsFilePackage = undefined;\n        }\n\n        var exts = [''].concat(extensions);\n        load(exts, x, loadAsFilePackage);\n\n        function load(exts, x, loadPackage) {\n            if (exts.length === 0) return cb(null, undefined, loadPackage);\n            var file = x + exts[0];\n\n            var pkg = loadPackage;\n            if (pkg) onpkg(null, pkg);\n            else loadpkg(path.dirname(file), onpkg);\n\n            function onpkg(err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err);\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex(err, ex) {\n                if (err) return cb(err);\n                if (ex) return cb(null, file, pkg);\n                load(exts.slice(1), x, pkg);\n            }\n        }\n    }\n\n    function loadpkg(dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return cb(null);\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return cb(null);\n\n        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return loadpkg(path.dirname(dir), cb);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                // on err, ex is false\n                if (!ex) return loadpkg(path.dirname(dir), cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n                    cb(null, pkg, dir);\n                });\n            });\n        });\n    }\n\n    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n        var cb = callback;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n\n        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return cb(unwrapErr);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                if (err) return cb(err);\n                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) return cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n\n                    if (pkg && pkg.main) {\n                        if (typeof pkg.main !== 'string') {\n                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                            mainError.code = 'INVALID_PACKAGE_MAIN';\n                            return cb(mainError);\n                        }\n                        if (pkg.main === '.' || pkg.main === './') {\n                            pkg.main = 'index';\n                        }\n                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                            if (err) return cb(err);\n                            if (m) return cb(null, m, pkg);\n                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n\n                            var dir = path.resolve(x, pkg.main);\n                            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                                if (err) return cb(err);\n                                if (n) return cb(null, n, pkg);\n                                loadAsFile(path.join(x, 'index'), pkg, cb);\n                            });\n                        });\n                        return;\n                    }\n\n                    loadAsFile(path.join(x, '/index'), pkg, cb);\n                });\n            });\n        });\n    }\n\n    function processDirs(cb, dirs) {\n        if (dirs.length === 0) return cb(null, undefined);\n        var dir = dirs[0];\n\n        isDirectory(path.dirname(dir), isdir);\n\n        function isdir(err, isdir) {\n            if (err) return cb(err);\n            if (!isdir) return processDirs(cb, dirs.slice(1));\n            loadAsFile(dir, opts.package, onfile);\n        }\n\n        function onfile(err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            loadAsDirectory(dir, opts.package, ondir);\n        }\n\n        function ondir(err, n, pkg) {\n            if (err) return cb(err);\n            if (n) return cb(null, n, pkg);\n            processDirs(cb, dirs.slice(1));\n        }\n    }\n    function loadNodeModules(x, start, cb) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        processDirs(\n            cb,\n            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()\n        );\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4216, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/node_modules/@sentry/nextjs/node_modules/resolve/lib/core.json"],"sourcesContent":["{\"assert\":true,\"node:assert\":[\">= 14.18 && < 15\",\">= 16\"],\"assert/strict\":\">= 15\",\"node:assert/strict\":\">= 16\",\"async_hooks\":\">= 8\",\"node:async_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"buffer_ieee754\":\">= 0.5 && < 0.9.7\",\"buffer\":true,\"node:buffer\":[\">= 14.18 && < 15\",\">= 16\"],\"child_process\":true,\"node:child_process\":[\">= 14.18 && < 15\",\">= 16\"],\"cluster\":\">= 0.5\",\"node:cluster\":[\">= 14.18 && < 15\",\">= 16\"],\"console\":true,\"node:console\":[\">= 14.18 && < 15\",\">= 16\"],\"constants\":true,\"node:constants\":[\">= 14.18 && < 15\",\">= 16\"],\"crypto\":true,\"node:crypto\":[\">= 14.18 && < 15\",\">= 16\"],\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"node:dgram\":[\">= 14.18 && < 15\",\">= 16\"],\"diagnostics_channel\":[\">= 14.17 && < 15\",\">= 15.1\"],\"node:diagnostics_channel\":[\">= 14.18 && < 15\",\">= 16\"],\"dns\":true,\"node:dns\":[\">= 14.18 && < 15\",\">= 16\"],\"dns/promises\":\">= 15\",\"node:dns/promises\":\">= 16\",\"domain\":\">= 0.7.12\",\"node:domain\":[\">= 14.18 && < 15\",\">= 16\"],\"events\":true,\"node:events\":[\">= 14.18 && < 15\",\">= 16\"],\"freelist\":\"< 6\",\"fs\":true,\"node:fs\":[\">= 14.18 && < 15\",\">= 16\"],\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"node:fs/promises\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_agent\":\">= 0.11.1\",\"node:_http_agent\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_client\":\">= 0.11.1\",\"node:_http_client\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_common\":\">= 0.11.1\",\"node:_http_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_incoming\":\">= 0.11.1\",\"node:_http_incoming\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_outgoing\":\">= 0.11.1\",\"node:_http_outgoing\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_server\":\">= 0.11.1\",\"node:_http_server\":[\">= 14.18 && < 15\",\">= 16\"],\"http\":true,\"node:http\":[\">= 14.18 && < 15\",\">= 16\"],\"http2\":\">= 8.8\",\"node:http2\":[\">= 14.18 && < 15\",\">= 16\"],\"https\":true,\"node:https\":[\">= 14.18 && < 15\",\">= 16\"],\"inspector\":\">= 8\",\"node:inspector\":[\">= 14.18 && < 15\",\">= 16\"],\"inspector/promises\":[\">= 19\"],\"node:inspector/promises\":[\">= 19\"],\"_linklist\":\"< 8\",\"module\":true,\"node:module\":[\">= 14.18 && < 15\",\">= 16\"],\"net\":true,\"node:net\":[\">= 14.18 && < 15\",\">= 16\"],\"node-inspect/lib/_inspect\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6 && < 12\",\"os\":true,\"node:os\":[\">= 14.18 && < 15\",\">= 16\"],\"path\":true,\"node:path\":[\">= 14.18 && < 15\",\">= 16\"],\"path/posix\":\">= 15.3\",\"node:path/posix\":\">= 16\",\"path/win32\":\">= 15.3\",\"node:path/win32\":\">= 16\",\"perf_hooks\":\">= 8.5\",\"node:perf_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"process\":\">= 1\",\"node:process\":[\">= 14.18 && < 15\",\">= 16\"],\"punycode\":\">= 0.5\",\"node:punycode\":[\">= 14.18 && < 15\",\">= 16\"],\"querystring\":true,\"node:querystring\":[\">= 14.18 && < 15\",\">= 16\"],\"readline\":true,\"node:readline\":[\">= 14.18 && < 15\",\">= 16\"],\"readline/promises\":\">= 17\",\"node:readline/promises\":\">= 17\",\"repl\":true,\"node:repl\":[\">= 14.18 && < 15\",\">= 16\"],\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"node:_stream_duplex\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_transform\":\">= 0.9.4\",\"node:_stream_transform\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_wrap\":\">= 1.4.1\",\"node:_stream_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_passthrough\":\">= 0.9.4\",\"node:_stream_passthrough\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_readable\":\">= 0.9.4\",\"node:_stream_readable\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_writable\":\">= 0.9.4\",\"node:_stream_writable\":[\">= 14.18 && < 15\",\">= 16\"],\"stream\":true,\"node:stream\":[\">= 14.18 && < 15\",\">= 16\"],\"stream/consumers\":\">= 16.7\",\"node:stream/consumers\":\">= 16.7\",\"stream/promises\":\">= 15\",\"node:stream/promises\":\">= 16\",\"stream/web\":\">= 16.5\",\"node:stream/web\":\">= 16.5\",\"string_decoder\":true,\"node:string_decoder\":[\">= 14.18 && < 15\",\">= 16\"],\"sys\":[\">= 0.4 && < 0.7\",\">= 0.8\"],\"node:sys\":[\">= 14.18 && < 15\",\">= 16\"],\"test/reporters\":\">= 19.9 && < 20.2\",\"node:test/reporters\":[\">= 18.17 && < 19\",\">= 19.9\",\">= 20\"],\"node:test\":[\">= 16.17 && < 17\",\">= 18\"],\"timers\":true,\"node:timers\":[\">= 14.18 && < 15\",\">= 16\"],\"timers/promises\":\">= 15\",\"node:timers/promises\":\">= 16\",\"_tls_common\":\">= 0.11.13\",\"node:_tls_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"node:_tls_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"tls\":true,\"node:tls\":[\">= 14.18 && < 15\",\">= 16\"],\"trace_events\":\">= 10\",\"node:trace_events\":[\">= 14.18 && < 15\",\">= 16\"],\"tty\":true,\"node:tty\":[\">= 14.18 && < 15\",\">= 16\"],\"url\":true,\"node:url\":[\">= 14.18 && < 15\",\">= 16\"],\"util\":true,\"node:util\":[\">= 14.18 && < 15\",\">= 16\"],\"util/types\":\">= 15.3\",\"node:util/types\":\">= 16\",\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/consarray\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/logreader\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8\":\">= 1\",\"node:v8\":[\">= 14.18 && < 15\",\">= 16\"],\"vm\":true,\"node:vm\":[\">= 14.18 && < 15\",\">= 16\"],\"wasi\":[\">= 13.4 && < 13.5\",\">= 18.17 && < 19\",\">= 20\"],\"node:wasi\":[\">= 18.17 && < 19\",\">= 20\"],\"worker_threads\":\">= 11.7\",\"node:worker_threads\":[\">= 14.18 && < 15\",\">= 16\"],\"zlib\":\">= 0.5\",\"node:zlib\":[\">= 14.18 && < 15\",\">= 16\"]}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 4216, "column": 5254}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4220, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/core.js"],"sourcesContent":["'use strict';\n\nvar isCoreModule = require('is-core-module');\nvar data = require('./core.json');\n\nvar core = {};\nfor (var mod in data) { // eslint-disable-line no-restricted-syntax\n    if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = isCoreModule(mod);\n    }\n}\nmodule.exports = core;\n"],"names":[],"mappings":"AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI,OAAO,CAAC;AACZ,IAAK,IAAI,OAAO,KAAM;IAClB,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,MAAM;QACjD,IAAI,CAAC,IAAI,GAAG,aAAa;IAC7B;AACJ;AACA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 4232, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/is-core.js"],"sourcesContent":["var isCoreModule = require('is-core-module');\n\nmodule.exports = function isCore(x) {\n    return isCoreModule(x);\n};\n"],"names":[],"mappings":"AAAA,IAAI;AAEJ,OAAO,OAAO,GAAG,SAAS,OAAO,CAAC;IAC9B,OAAO,aAAa;AACxB","ignoreList":[0]}},
    {"offset": {"line": 4239, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/lib/sync.js"],"sourcesContent":["var isCore = require('is-core-module');\nvar fs = require('fs');\nvar path = require('path');\nvar getHomedir = require('./homedir');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file) {\n    try {\n        var stat = fs.statSync(file, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && (stat.isFile() || stat.isFIFO());\n};\n\nvar defaultIsDir = function isDirectory(dir) {\n    try {\n        var stat = fs.statSync(dir, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && stat.isDirectory();\n};\n\nvar defaultRealpathSync = function realpathSync(x) {\n    try {\n        return realpathFS(x);\n    } catch (realpathErr) {\n        if (realpathErr.code !== 'ENOENT') {\n            throw realpathErr;\n        }\n    }\n    return x;\n};\n\nvar maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {\n    if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n    }\n    return x;\n};\n\nvar defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {\n    var body = readFileSync(pkgfile);\n    try {\n        var pkg = JSON.parse(body);\n        return pkg;\n    } catch (jsonErr) {}\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolveSync(x, options) {\n    if (typeof x !== 'string') {\n        throw new TypeError('Path must be a string.');\n    }\n    var opts = normalizeOptions(x, options);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var realpathSync = opts.realpathSync || defaultRealpathSync;\n    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n    if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n\n    if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return maybeRealpathSync(realpathSync, m, opts);\n    } else if (includeCoreModules && isCore(x)) {\n        return x;\n    } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n) return maybeRealpathSync(realpathSync, n, opts);\n    }\n\n    var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n\n    function loadAsFileSync(x) {\n        var pkg = loadpkg(path.dirname(x));\n\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n            var rfile = path.relative(pkg.dir, x);\n            var r = opts.pathFilter(pkg.pkg, x, rfile);\n            if (r) {\n                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign\n            }\n        }\n\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadpkg(dir) {\n        if (dir === '' || dir === '/') return;\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return;\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return;\n\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');\n\n        if (!isFile(pkgfile)) {\n            return loadpkg(path.dirname(dir));\n        }\n\n        var pkg = readPackageSync(readFileSync, pkgfile);\n\n        if (pkg && opts.packageFilter) {\n            // v2 will pass pkgfile\n            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment\n        }\n\n        return { pkg: pkg, dir: dir };\n    }\n\n    function loadAsDirectorySync(x) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');\n        if (isFile(pkgfile)) {\n            try {\n                var pkg = readPackageSync(readFileSync, pkgfile);\n            } catch (e) {}\n\n            if (pkg && opts.packageFilter) {\n                // v2 will pass pkgfile\n                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment\n            }\n\n            if (pkg && pkg.main) {\n                if (typeof pkg.main !== 'string') {\n                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');\n                    mainError.code = 'INVALID_PACKAGE_MAIN';\n                    throw mainError;\n                }\n                if (pkg.main === '.' || pkg.main === './') {\n                    pkg.main = 'index';\n                }\n                try {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                } catch (e) {}\n            }\n        }\n\n        return loadAsFileSync(path.join(x, '/index'));\n    }\n\n    function loadNodeModulesSync(x, start) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();\n\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            if (isDirectory(path.dirname(dir))) {\n                var m = loadAsFileSync(dir);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir);\n                if (n) return n;\n            }\n        }\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4429, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/node_modules/%40sentry/nextjs/node_modules/resolve/index.js"],"sourcesContent":["var async = require('./lib/async');\nasync.core = require('./lib/core');\nasync.isCore = require('./lib/is-core');\nasync.sync = require('./lib/sync');\n\nmodule.exports = async;\n"],"names":[],"mappings":"AAAA,IAAI;AACJ,MAAM,IAAI;AACV,MAAM,MAAM;AACZ,MAAM,IAAI;AAEV,OAAO,OAAO,GAAG","ignoreList":[0]}}]
}