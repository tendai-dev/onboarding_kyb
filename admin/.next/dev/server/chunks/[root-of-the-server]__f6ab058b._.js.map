{
  "version": 3,
  "sources": [],
  "debugId": "584ee790-e636-e43e-0fa4-8417f428ccb1",
  "sections": [
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/lib/sentry.ts"],"sourcesContent":["/**\n * Sentry error reporting utilities\n * Use these functions instead of console.error/warn for proper error tracking\n */\n\nimport * as Sentry from \"@sentry/nextjs\";\n\n/**\n * Report an error to Sentry with optional context\n */\nexport function reportError(\n  error: Error | unknown,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n    level?: Sentry.SeverityLevel;\n    user?: {\n      id?: string;\n      email?: string;\n      username?: string;\n    };\n  }\n): void {\n  if (error instanceof Error) {\n    Sentry.captureException(error, {\n      tags: context?.tags,\n      extra: context?.extra,\n      level: context?.level || \"error\",\n      user: context?.user,\n    });\n  } else {\n    // For non-Error objects, create an Error from the value\n    const errorMessage = typeof error === \"string\" ? error : JSON.stringify(error);\n    Sentry.captureException(new Error(errorMessage), {\n      tags: context?.tags,\n      extra: { originalError: error, ...context?.extra },\n      level: context?.level || \"error\",\n      user: context?.user,\n    });\n  }\n}\n\n/**\n * Report a warning to Sentry\n */\nexport function reportWarning(\n  message: string,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): void {\n  Sentry.captureMessage(message, {\n    level: \"warning\",\n    tags: context?.tags,\n    extra: context?.extra,\n  });\n}\n\n/**\n * Report an API error with request context\n */\nexport function reportApiError(\n  error: Error | unknown,\n  apiContext: {\n    endpoint: string;\n    method?: string;\n    statusCode?: number;\n    responseBody?: string;\n    requestBody?: unknown;\n  },\n  additionalContext?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): void {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  \n  reportError(error, {\n    tags: {\n      error_type: \"api_error\",\n      api_endpoint: apiContext.endpoint,\n      api_method: apiContext.method || \"GET\",\n      ...additionalContext?.tags,\n    },\n    extra: {\n      api_endpoint: apiContext.endpoint,\n      api_method: apiContext.method,\n      status_code: apiContext.statusCode,\n      response_body: apiContext.responseBody,\n      request_body: apiContext.requestBody,\n      ...additionalContext?.extra,\n    },\n  });\n}\n\n/**\n * Set user context for Sentry\n */\nexport function setUserContext(user: {\n  id?: string;\n  email?: string;\n  username?: string;\n  name?: string;\n}): void {\n  Sentry.setUser({\n    id: user.id,\n    email: user.email,\n    username: user.username || user.name,\n  });\n}\n\n/**\n * Clear user context (e.g., on logout)\n */\nexport function clearUserContext(): void {\n  Sentry.setUser(null);\n}\n\n/**\n * Add breadcrumb for debugging\n */\nexport function addBreadcrumb(\n  message: string,\n  category?: string,\n  level?: Sentry.SeverityLevel,\n  data?: Record<string, unknown>\n): void {\n  Sentry.addBreadcrumb({\n    message,\n    category: category || \"default\",\n    level: level || \"info\",\n    data,\n  });\n}\n\n/**\n * Wrap an async function to automatically capture errors\n */\nexport function withErrorReporting<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): T {\n  return (async (...args: any[]) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      reportError(error, context);\n      throw error; // Re-throw to maintain original behavior\n    }\n  }) as T;\n}\n\n/**\n * Wrap a sync function to automatically capture errors\n */\nexport function withErrorReportingSync<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: {\n    tags?: Record<string, string>;\n    extra?: Record<string, unknown>;\n  }\n): T {\n  return ((...args: any[]) => {\n    try {\n      return fn(...args);\n    } catch (error) {\n      reportError(error, context);\n      throw error; // Re-throw to maintain original behavior\n    }\n  }) as T;\n}\n\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;AAED;;AAKO,SAAS,YACd,KAAsB,EACtB,OASC;IAED,IAAI,iBAAiB,OAAO;QAC1B,2LAAuB,CAAC,OAAO;YAC7B,MAAM,SAAS;YACf,OAAO,SAAS;YAChB,OAAO,SAAS,SAAS;YACzB,MAAM,SAAS;QACjB;IACF,OAAO;QACL,wDAAwD;QACxD,MAAM,eAAe,OAAO,UAAU,WAAW,QAAQ,KAAK,SAAS,CAAC;QACxE,2LAAuB,CAAC,IAAI,MAAM,eAAe;YAC/C,MAAM,SAAS;YACf,OAAO;gBAAE,eAAe;gBAAO,GAAG,SAAS,KAAK;YAAC;YACjD,OAAO,SAAS,SAAS;YACzB,MAAM,SAAS;QACjB;IACF;AACF;AAKO,SAAS,cACd,OAAe,EACf,OAGC;IAED,yLAAqB,CAAC,SAAS;QAC7B,OAAO;QACP,MAAM,SAAS;QACf,OAAO,SAAS;IAClB;AACF;AAKO,SAAS,eACd,KAAsB,EACtB,UAMC,EACD,iBAGC;IAED,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;IAErE,YAAY,OAAO;QACjB,MAAM;YACJ,YAAY;YACZ,cAAc,WAAW,QAAQ;YACjC,YAAY,WAAW,MAAM,IAAI;YACjC,GAAG,mBAAmB,IAAI;QAC5B;QACA,OAAO;YACL,cAAc,WAAW,QAAQ;YACjC,YAAY,WAAW,MAAM;YAC7B,aAAa,WAAW,UAAU;YAClC,eAAe,WAAW,YAAY;YACtC,cAAc,WAAW,WAAW;YACpC,GAAG,mBAAmB,KAAK;QAC7B;IACF;AACF;AAKO,SAAS,eAAe,IAK9B;IACC,kLAAc,CAAC;QACb,IAAI,KAAK,EAAE;QACX,OAAO,KAAK,KAAK;QACjB,UAAU,KAAK,QAAQ,IAAI,KAAK,IAAI;IACtC;AACF;AAKO,SAAS;IACd,kLAAc,CAAC;AACjB;AAKO,SAAS,cACd,OAAe,EACf,QAAiB,EACjB,KAA4B,EAC5B,IAA8B;IAE9B,wLAAoB,CAAC;QACnB;QACA,UAAU,YAAY;QACtB,OAAO,SAAS;QAChB;IACF;AACF;AAKO,SAAS,mBACd,EAAK,EACL,OAGC;IAED,OAAQ,OAAO,GAAG;QAChB,IAAI;YACF,OAAO,MAAM,MAAM;QACrB,EAAE,OAAO,OAAO;YACd,YAAY,OAAO;YACnB,MAAM,OAAO,yCAAyC;QACxD;IACF;AACF;AAKO,SAAS,uBACd,EAAK,EACL,OAGC;IAED,OAAQ,CAAC,GAAG;QACV,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAO;YACd,YAAY,OAAO;YACnB,MAAM,OAAO,yCAAyC;QACxD;IACF;AACF"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/lib/redis-session.ts"],"sourcesContent":["import { createClient } from 'redis';\nimport { reportError } from './sentry';\n\n// Redis client singleton\nlet redisClient: ReturnType<typeof createClient> | null = null;\n\nexport async function getRedisClient() {\n  if (redisClient && redisClient.isOpen) {\n    return redisClient;\n  }\n\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n  redisClient = createClient({ url: redisUrl });\n\n  redisClient.on('error', (err) => {\n    reportError(err, {\n      tags: { error_type: 'redis_connection', operation: 'redis_client_error' },\n      level: 'error',\n    });\n  });\n  redisClient.on('connect', () => {\n    // Only log in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Redis Client Connected');\n    }\n  });\n\n  if (!redisClient.isOpen) {\n    await redisClient.connect();\n  }\n\n  return redisClient;\n}\n\nexport interface TokenSession {\n  accessToken: string;\n  refreshToken: string;\n  accessTokenExpiryTime: number;\n  provider: 'azure-ad' | 'keycloak';\n  userEmail?: string;\n  userId?: string;\n}\n\nconst SESSION_PREFIX = 'session:';\nconst TTL_SECONDS = 7 * 24 * 60 * 60; // 7 days\n\n/**\n * Store IdP tokens in Redis, keyed by session ID\n */\nexport async function storeTokenSession(\n  sessionId: string,\n  tokens: TokenSession\n): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.setEx(key, TTL_SECONDS, JSON.stringify(tokens));\n}\n\n/**\n * Retrieve IdP tokens from Redis by session ID\n */\nexport async function getTokenSession(\n  sessionId: string\n): Promise<TokenSession | null> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  const data = await client.get(key);\n  if (!data) return null;\n  return JSON.parse(data) as TokenSession;\n}\n\n/**\n * Delete token session from Redis\n */\nexport async function deleteTokenSession(sessionId: string): Promise<void> {\n  const client = await getRedisClient();\n  const key = `${SESSION_PREFIX}${sessionId}`;\n  await client.del(key);\n}\n\n/**\n * Update access token (for refresh scenarios)\n */\nexport async function updateAccessToken(\n  sessionId: string,\n  accessToken: string,\n  accessTokenExpiryTime: number\n): Promise<void> {\n  const session = await getTokenSession(sessionId);\n  if (!session) {\n    throw new Error('Session not found');\n  }\n  await storeTokenSession(sessionId, {\n    ...session,\n    accessToken,\n    accessTokenExpiryTime,\n  });\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;;;AAEA,yBAAyB;AACzB,IAAI,cAAsD;AAEnD,eAAe;IACpB,IAAI,eAAe,YAAY,MAAM,EAAE;QACrC,OAAO;IACT;IAEA,MAAM,WAAW,QAAQ,GAAG,CAAC,SAAS,IAAI;IAC1C,cAAc,IAAA,mHAAY,EAAC;QAAE,KAAK;IAAS;IAE3C,YAAY,EAAE,CAAC,SAAS,CAAC;QACvB,2IAAY,KAAK;YACf,MAAM;gBAAE,YAAY;gBAAoB,WAAW;YAAqB;YACxE,OAAO;QACT;IACF;IACA,YAAY,EAAE,CAAC,WAAW;QACxB,0BAA0B;QAC1B,wCAA4C;YAC1C,QAAQ,GAAG,CAAC;QACd;IACF;IAEA,IAAI,CAAC,YAAY,MAAM,EAAE;QACvB,MAAM,YAAY,OAAO;IAC3B;IAEA,OAAO;AACT;AAWA,MAAM,iBAAiB;AACvB,MAAM,cAAc,IAAI,KAAK,KAAK,IAAI,SAAS;AAKxC,eAAe,kBACpB,SAAiB,EACjB,MAAoB;IAEpB,MAAM,SAAS,MAAM;IACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;IAC3C,MAAM,OAAO,KAAK,CAAC,KAAK,aAAa,KAAK,SAAS,CAAC;AACtD;AAKO,eAAe,gBACpB,SAAiB;IAEjB,MAAM,SAAS,MAAM;IACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;IAC3C,MAAM,OAAO,MAAM,OAAO,GAAG,CAAC;IAC9B,IAAI,CAAC,MAAM,OAAO;IAClB,OAAO,KAAK,KAAK,CAAC;AACpB;AAKO,eAAe,mBAAmB,SAAiB;IACxD,MAAM,SAAS,MAAM;IACrB,MAAM,MAAM,GAAG,iBAAiB,WAAW;IAC3C,MAAM,OAAO,GAAG,CAAC;AACnB;AAKO,eAAe,kBACpB,SAAiB,EACjB,WAAmB,EACnB,qBAA6B;IAE7B,MAAM,UAAU,MAAM,gBAAgB;IACtC,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,kBAAkB,WAAW;QACjC,GAAG,OAAO;QACV;QACA;IACF;AACF"}},
    {"offset": {"line": 444, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/lib/auth.ts"],"sourcesContent":["// @ts-ignore - NextAuth v5 beta compatibility\nimport type { NextAuthOptions } from 'next-auth';\nimport NextAuth from 'next-auth';\nimport AzureADProvider from 'next-auth/providers/azure-ad';\nimport { storeTokenSession, getTokenSession, updateAccessToken } from './redis-session';\nimport { reportError } from './sentry';\n\n// Helper function to refresh tokens\nconst refreshAccessToken = async (token: any, sessionId?: string) => {\n  try {\n    // Get refresh token from Redis if sessionId provided\n    let refreshToken = token.refreshToken;\n    if (sessionId) {\n      const session = await getTokenSession(sessionId);\n      if (session) {\n        refreshToken = session.refreshToken;\n      }\n    }\n\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    const issuer = process.env.NEXT_PUBLIC_AZURE_AD_ISSUER || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;\n    \n    const response = await fetch(`${issuer}/oauth2/v2.0/token`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        client_id: process.env.AZURE_AD_CLIENT_ID!,\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken,\n        client_secret: process.env.AZURE_AD_CLIENT_SECRET!,\n      }),\n    });\n\n    const refreshedTokens = await response.json();\n\n    if (!response.ok) {\n      throw refreshedTokens;\n    }\n\n    const newAccessToken = refreshedTokens.access_token;\n    const newRefreshToken = refreshedTokens.refresh_token ?? refreshToken;\n    const newExpiryTime = Date.now() + refreshedTokens.expires_in * 1000;\n\n    // Update Redis if sessionId provided\n    if (sessionId) {\n      await updateAccessToken(sessionId, newAccessToken, newExpiryTime);\n      if (newRefreshToken !== refreshToken) {\n        const session = await getTokenSession(sessionId);\n        if (session) {\n          await storeTokenSession(sessionId, {\n            ...session,\n            refreshToken: newRefreshToken,\n            accessToken: newAccessToken,\n            accessTokenExpiryTime: newExpiryTime,\n          });\n        }\n      }\n    }\n\n    return {\n      ...token,\n      accessToken: newAccessToken,\n      accessTokenExpiryTime: newExpiryTime,\n      refreshToken: newRefreshToken,\n    };\n  } catch (error) {\n    reportError(error, {\n      tags: { error_type: 'token_refresh', operation: 'refresh_access_token' },\n      extra: { sessionId, hasRefreshToken: !!token.refreshToken },\n      level: 'error',\n    });\n    return {\n      ...token,\n      error: 'RefreshAccessTokenError',\n    };\n  }\n};\n\n// Validate required environment variables\nconst requiredEnvVars = {\n  AZURE_AD_CLIENT_ID: process.env.AZURE_AD_CLIENT_ID,\n  AZURE_AD_CLIENT_SECRET: process.env.AZURE_AD_CLIENT_SECRET,\n  AZURE_AD_TENANT_ID: process.env.AZURE_AD_TENANT_ID,\n  NEXTAUTH_URL: process.env.NEXTAUTH_URL,\n  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,\n};\n\nconst missingVars = Object.entries(requiredEnvVars)\n  .filter(([_, value]) => !value)\n  .map(([key]) => key);\n\nif (missingVars.length > 0) {\n  console.error('[NextAuth] Missing required environment variables:', missingVars);\n}\n\n// Log Azure AD configuration for debugging\nif (process.env.NODE_ENV === 'development') {\n  const issuer = process.env.NEXT_PUBLIC_AZURE_AD_ISSUER || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`;\n  console.log('[NextAuth Config] Azure AD Configuration:', {\n    clientId: process.env.AZURE_AD_CLIENT_ID,\n    tenantId: process.env.AZURE_AD_TENANT_ID,\n    issuer,\n    nextAuthUrl: process.env.NEXTAUTH_URL,\n    expectedCallbackUrl: `${process.env.NEXTAUTH_URL}/api/auth/callback/azure-ad`,\n    hasClientSecret: !!process.env.AZURE_AD_CLIENT_SECRET,\n  });\n}\n\nexport const authOptions: NextAuthOptions = {\n  debug: process.env.NODE_ENV === 'development', // Enable debug logging in development\n  providers: [\n    AzureADProvider({\n      clientId: process.env.AZURE_AD_CLIENT_ID!,\n      clientSecret: process.env.AZURE_AD_CLIENT_SECRET!,\n      // @ts-ignore - tenantId is valid but not in types for v5 beta\n      tenantId: process.env.AZURE_AD_TENANT_ID!,\n      // Explicitly set issuer to ensure correct URL construction\n      issuer: process.env.NEXT_PUBLIC_AZURE_AD_ISSUER || `https://login.microsoftonline.com/${process.env.AZURE_AD_TENANT_ID}/v2.0`,\n      authorization: {\n        params: {\n          // Using only the absolute minimum permissions that don't require admin consent:\n          // - openid: Sign users in (Delegated, no admin consent)\n          // - email: View users' email address (Delegated, no admin consent)\n          // Note: Removed 'profile' and 'offline_access' as they may require admin consent\n          // depending on Azure AD app registration settings\n          scope: 'openid email',\n        },\n      },\n      profile(profile: any) {\n        return {\n          id: profile.sub || profile.oid || profile.id,\n          name: profile.name || profile.displayName || (profile.given_name && profile.family_name ? `${profile.given_name} ${profile.family_name}` : null) || profile.preferred_username || profile.email,\n          email: profile.email || profile.preferred_username || profile.upn,\n          image: profile.picture || undefined,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, account, user, trigger, session: sessionData }: any) {\n      try {\n        // Initial sign in - store tokens in Redis\n        if (account && user) {\n        const sessionId = (token.sub as string) || (token.jti as string) || `session-${Date.now()}-${Math.random()}`;\n        token.sessionId = sessionId;\n        token.accessTokenExpiryTime = account.expires_at ? account.expires_at * 1000 : Date.now() + 3600 * 1000;\n        \n        // Log user data from Azure AD for debugging\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[NextAuth] JWT callback - User data:', {\n            userId: user.id,\n            userName: user.name,\n            userEmail: user.email,\n            tokenSub: token.sub,\n            tokenName: token.name,\n            tokenEmail: token.email,\n          });\n        }\n        \n        // Preserve user data from Azure AD - ensure name is included\n        // Use user object first, then fall back to token claims\n        token.user = {\n          id: user.id || token.sub || undefined,\n          name: user.name || token.name || (token as any).given_name + ' ' + (token as any).family_name || undefined,\n          email: user.email || token.email || undefined,\n          image: user.image || token.picture || undefined,\n        };\n        \n        // Also store name and email directly on token for fallback\n        if (user.name) token.name = user.name;\n        else if (token.name) token.name = token.name as string;\n        else if ((token as any).given_name && (token as any).family_name) {\n          token.name = `${(token as any).given_name} ${(token as any).family_name}`;\n          token.user.name = token.name;\n        }\n        \n        if (user.email) token.email = user.email;\n        else if (token.email) token.email = token.email as string;\n        \n        // Store tokens in Redis (not in JWT)\n        try {\n          await storeTokenSession(sessionId, {\n            accessToken: account.access_token || '',\n            refreshToken: account.refresh_token || '',\n            accessTokenExpiryTime: token.accessTokenExpiryTime || Date.now() + 3600 * 1000,\n            provider: 'azure-ad',\n            userEmail: user.email || undefined,\n            userId: user.id || user.email || undefined,\n          });\n        } catch (error) {\n          reportError(error, {\n            tags: { error_type: 'redis_token_storage', operation: 'store_token_session' },\n            extra: { sessionId, userEmail: user.email },\n            level: 'error',\n          });\n          // Continue anyway - tokens will be in JWT as fallback (but shouldn't be exposed)\n        }\n        \n        // Automatically save user email to backend (fire and forget)\n        if (user?.email && account.access_token) {\n          try {\n            const entityConfigApiBaseUrl = process.env.NEXT_PUBLIC_ENTITY_CONFIG_API_BASE_URL || 'http://localhost:8003';\n            await fetch(`${entityConfigApiBaseUrl}/api/v1/users`, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${account.access_token}`,\n                'X-User-Email': user.email,\n              },\n              body: JSON.stringify({\n                email: user.email,\n                name: user.name || null,\n              }),\n            }).catch(err => {\n              // Silently fail - don't block login if user creation fails\n              reportError(err, {\n                tags: { error_type: 'user_registration', operation: 'register_user_on_login' },\n                extra: { userEmail: user.email },\n                level: 'warning',\n              });\n            });\n          } catch (err) {\n            // Silently fail - don't block login if user creation fails\n            reportError(err, {\n              tags: { error_type: 'user_registration', operation: 'register_user_on_login' },\n              extra: { userEmail: user.email },\n              level: 'warning',\n            });\n          }\n        }\n        \n        // DO NOT store accessToken/refreshToken in JWT - only in Redis\n        return token;\n      }\n\n      // Check if we need to refresh token\n      const sessionId = token.sessionId as string | undefined;\n      if (sessionId) {\n        const redisSession = await getTokenSession(sessionId);\n        if (redisSession) {\n          // Check if token needs refresh\n          if (redisSession.accessTokenExpiryTime && Date.now() < redisSession.accessTokenExpiryTime - 60 * 1000) {\n            // Token still valid\n            return token;\n          }\n          // Token expired, refresh it\n          return refreshAccessToken(token, sessionId);\n        }\n      }\n\n      // Fallback: if no Redis session, check JWT expiry (legacy support)\n      if (token.accessTokenExpiryTime && Date.now() < token.accessTokenExpiryTime - 60 * 1000) {\n        return token;\n      }\n\n      // Access token has expired, try to update it\n      return refreshAccessToken(token, sessionId);\n      } catch (error: any) {\n        console.error('[NextAuth] JWT callback error:', error);\n        console.error('[NextAuth] JWT callback error stack:', error?.stack);\n        reportError(error, {\n          tags: { error_type: 'jwt_callback', operation: 'jwt_callback' },\n          extra: { \n            hasAccount: !!account,\n            hasUser: !!user,\n            tokenSub: token?.sub,\n            trigger,\n          },\n          level: 'error',\n        });\n        // Return token anyway to prevent complete failure\n        return token;\n      }\n    },\n    async session({ session, token }: any) {\n      try {\n        // DO NOT expose accessToken or sessionId to frontend - BFF pattern\n        // sessionId is stored in httpOnly JWT cookie only, never exposed to client-side JS\n        \n        // Set user data from token - prioritize token.user, then token fields\n        if (token.user) {\n          session.user = {\n            id: token.user.id || token.sub || undefined,\n            name: token.user.name || token.name ? (token.name as string) : undefined,\n            email: token.user.email || token.email ? (token.email as string) : undefined,\n            image: token.user.image || token.picture ? (token.picture as string) : undefined,\n          };\n        } else if (token.name || token.email) {\n          // Use token fields directly if user object not available\n          session.user = {\n            id: token.sub || undefined,\n            name: token.name ? (token.name as string) : undefined,\n            email: token.email ? (token.email as string) : undefined,\n            image: token.picture ? (token.picture as string) : undefined,\n          };\n        }\n        \n        // Log session for debugging\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[NextAuth] Session callback:', {\n            hasUser: !!session.user,\n            userName: session.user?.name,\n            userEmail: session.user?.email,\n            tokenHasUser: !!token.user,\n            tokenName: token.name,\n            tokenEmail: token.email,\n          });\n        }\n        \n        session.error = token.error as string | undefined;\n      \n      // Update user last login (fire and forget) - use proxy endpoint instead\n      if (session.user?.email) {\n        try {\n          // This will go through proxy which will inject token from Redis\n          const entityConfigApiBaseUrl = process.env.NEXT_PUBLIC_ENTITY_CONFIG_API_BASE_URL || 'http://localhost:8003';\n          // Use relative path to go through proxy\n          fetch('/api/proxy/api/v1/users', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'X-User-Email': session.user.email,\n            },\n            body: JSON.stringify({\n              email: session.user.email,\n              name: session.user.name || null,\n            }),\n          }).catch(err => {\n            // Silently fail - don't block session if update fails\n            reportError(err, {\n              tags: { error_type: 'user_update', operation: 'update_user_last_login' },\n              extra: { userEmail: session.user?.email },\n              level: 'warning',\n            });\n          });\n        } catch (err) {\n          // Silently fail - don't block session if update fails\n          reportError(err, {\n            tags: { error_type: 'user_update', operation: 'update_user_last_login' },\n            extra: { userEmail: session.user?.email },\n            level: 'warning',\n          });\n        }\n      }\n      \n      return session;\n      } catch (error: any) {\n        console.error('[NextAuth] Session callback error:', error);\n        console.error('[NextAuth] Session callback error stack:', error?.stack);\n        reportError(error, {\n          tags: { error_type: 'session_callback', operation: 'session_callback' },\n          extra: { \n            hasToken: !!token,\n            tokenSub: token?.sub,\n          },\n          level: 'error',\n        });\n        // Return session anyway to prevent complete failure\n        return session;\n      }\n    },\n    async redirect({ url, baseUrl }: any) {\n      // Handle redirect after successful authentication\n      console.log('NextAuth redirect callback:', { url, baseUrl });\n      \n      // If url is the sign-in page, redirect to dashboard instead\n      if (url === `${baseUrl}/` || url === baseUrl || url === '/') {\n        console.log('Redirecting from sign-in page to dashboard');\n        return `${baseUrl}/dashboard`;\n      }\n      \n      // If url is a relative path, prepend baseUrl\n      if (url.startsWith('/')) {\n        return `${baseUrl}${url}`;\n      }\n      \n      // If url is on the same origin, allow it\n      try {\n      if (new URL(url).origin === baseUrl) {\n        return url;\n        }\n      } catch (e) {\n        // URL parsing failed, fall through to default\n      }\n      \n      // Default to dashboard\n      return `${baseUrl}/dashboard`;\n    },\n  },\n  pages: {\n    signIn: '/',\n    error: '/', // Redirect errors back to sign-in page\n  },\n  events: {\n    async signIn({ user, account, profile }: any) {\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[NextAuth] Sign in event:', {\n          userId: user?.id,\n          userEmail: user?.email,\n          provider: account?.provider,\n        });\n      }\n      return true;\n    },\n    async signOut({ session, token }: any) {\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[NextAuth] Sign out event');\n      }\n    },\n    async error({ error, message }: any) {\n      console.error('[NextAuth] Error event:', {\n        error: error?.message || error,\n        message,\n        errorType: error?.type,\n        errorStack: error?.stack,\n      });\n      reportError(error || new Error(message), {\n        tags: { error_type: 'nextauth_error', operation: 'nextauth_error_event' },\n        extra: { message, errorType: error?.type },\n        level: 'error',\n      });\n    },\n  },\n  session: {\n    strategy: 'jwt',\n  },\n  // Ensure proper base URL for callbacks\n  trustHost: true, // Trust the host header (useful for development)\n};\n\n// Export auth function for NextAuth v5 beta\n// This replaces getServerSession from v4\nexport const { auth } = NextAuth(authOptions);\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///Users/mukurusystemsadministrator/Desktop/onboarding_kyc%20copy/admin/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// NextAuth v5 beta - handler returns route handlers\nconst { handlers } = NextAuth(authOptions);\n\n// Wrap handlers with error logging\nconst GET = async (req: NextRequest) => {\n  try {\n    return await handlers.GET(req);\n  } catch (error: any) {\n    console.error('[NextAuth] GET handler error:', error);\n    console.error('[NextAuth] Error details:', {\n      message: error?.message,\n      stack: error?.stack,\n      url: req.url,\n    });\n    // Re-throw to let NextAuth handle the error response\n    throw error;\n  }\n};\n\nconst POST = async (req: NextRequest) => {\n  try {\n    return await handlers.POST(req);\n  } catch (error: any) {\n    console.error('[NextAuth] POST handler error:', error);\n    console.error('[NextAuth] Error details:', {\n      message: error?.message,\n      stack: error?.stack,\n      url: req.url,\n    });\n    // Re-throw to let NextAuth handle the error response\n    throw error;\n  }\n};\n\nexport { GET, POST };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGA,oDAAoD;AACpD,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,kKAAQ,EAAC,mIAAW;AAEzC,mCAAmC;AACnC,MAAM,MAAM,OAAO;IACjB,IAAI;QACF,OAAO,MAAM,SAAS,GAAG,CAAC;IAC5B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,QAAQ,KAAK,CAAC,6BAA6B;YACzC,SAAS,OAAO;YAChB,OAAO,OAAO;YACd,KAAK,IAAI,GAAG;QACd;QACA,qDAAqD;QACrD,MAAM;IACR;AACF;AAEA,MAAM,OAAO,OAAO;IAClB,IAAI;QACF,OAAO,MAAM,SAAS,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,QAAQ,KAAK,CAAC,6BAA6B;YACzC,SAAS,OAAO;YAChB,OAAO,OAAO;YACd,KAAK,IAAI,GAAG;QACd;QACA,qDAAqD;QACrD,MAAM;IACR;AACF"}}]
}