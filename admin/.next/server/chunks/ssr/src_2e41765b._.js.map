{
  "version": 3,
  "sources": [],
  "debugId": "47b0d3f5-1c81-4896-9dc5-c5767dbebba4",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/logger.ts","../../../../src/services/mappers/workQueueMapper.ts","../../../../src/services/api/applicationsApi.ts","../../../../src/services/api/dashboardApi.ts","../../../../src/services/api/workQueueApi.ts","../../../../src/services/mappers/applicationMapper.ts","../../../../src/services/index.ts","../../../../src/services/use-cases/applicationUseCases.ts","../../../../src/services/use-cases/dashboardUseCases.ts","../../../../src/services/use-cases/workQueueUseCases.ts"],"sourcesContent":["/**\n * Centralized logging utility\n * Replaces console.log/warn/error with proper logging that can be controlled\n * and integrated with Sentry in production\n */\n\nimport * as Sentry from '@sentry/nextjs';\nimport { reportError, reportWarning, addBreadcrumb } from './sentry';\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogOptions {\n  tags?: Record<string, string>;\n  extra?: Record<string, unknown>;\n  level?: LogLevel;\n}\n\nclass Logger {\n  private isDevelopment = process.env.NODE_ENV === 'development';\n  private isProduction = process.env.NODE_ENV === 'production';\n\n  /**\n   * Log debug messages (only in development)\n   */\n  debug(message: string, ...args: unknown[]): void {\n    if (this.isDevelopment) {\n      // eslint-disable-next-line no-console\n      console.debug(`[DEBUG] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Log info messages\n   */\n  info(message: string, ...args: unknown[]): void {\n    if (this.isDevelopment) {\n      // eslint-disable-next-line no-console\n      console.info(`[INFO] ${message}`, ...args);\n    }\n    // Add breadcrumb in production for debugging\n    if (this.isProduction) {\n      addBreadcrumb(message, 'info', 'info' as Sentry.SeverityLevel, { args });\n    }\n  }\n\n  /**\n   * Log warning messages\n   */\n  warn(message: string, options?: LogOptions): void {\n    // eslint-disable-next-line no-console\n    console.warn(`[WARN] ${message}`);\n    \n    // Report to Sentry in production\n    if (this.isProduction) {\n      reportWarning(message, {\n        tags: options?.tags,\n        extra: options?.extra,\n      });\n    }\n  }\n\n  /**\n   * Log error messages\n   */\n  error(error: Error | unknown, message?: string, options?: LogOptions): void {\n    const errorMessage = message || (error instanceof Error ? error.message : String(error));\n    \n    // eslint-disable-next-line no-console\n    console.error(`[ERROR] ${errorMessage}`, error);\n    \n    // Map LogLevel to Sentry.SeverityLevel\n    const sentryLevel: Sentry.SeverityLevel = \n      options?.level === 'warn' ? 'warning' : \n      options?.level === 'error' ? 'error' : \n      options?.level === 'info' ? 'info' : \n      'error';\n    \n    // Report to Sentry\n    reportError(error, {\n      tags: options?.tags,\n      extra: options?.extra,\n      level: sentryLevel,\n    });\n  }\n\n  /**\n   * Log with context (replaces console.log with structured logging)\n   */\n  log(message: string, context?: Record<string, unknown>, level: LogLevel = 'info'): void {\n    if (this.isDevelopment) {\n      // eslint-disable-next-line no-console\n      console.log(`[${level.toUpperCase()}] ${message}`, context || '');\n    }\n    \n    // Add breadcrumb in production\n    if (this.isProduction && level !== 'debug') {\n      const sentryLevel: Sentry.SeverityLevel = \n        level === 'warn' ? 'warning' : level === 'error' ? 'error' : 'info';\n      addBreadcrumb(message, 'log', sentryLevel, context);\n    }\n  }\n}\n\n// Export singleton instance\nexport const logger = new Logger();\n\n// Export class for testing\nexport { Logger };\n\n","/**\n * WorkQueue Mappers\n * Transformations between backend DTOs and frontend domain models\n */\n\nimport { WorkItemDto, Application } from '../dtos/workQueue.dto';\n\n/**\n * Map backend status to frontend status\n */\nfunction mapBackendStatusToFrontend(backendStatus: string): Application['status'] {\n  const statusMap: Record<string, Application['status']> = {\n    'New': 'SUBMITTED',\n    'Assigned': 'IN PROGRESS',\n    'InProgress': 'IN PROGRESS',\n    'PendingApproval': 'RISK REVIEW',\n    'Approved': 'COMPLETE',\n    'Completed': 'COMPLETE',\n    'Declined': 'DECLINED',\n    'Cancelled': 'DECLINED',\n    'DueForRefresh': 'IN PROGRESS',\n  };\n  \n  return statusMap[backendStatus] || 'IN PROGRESS';\n}\n\n/**\n * Map risk level to score\n */\nfunction mapRiskLevelToScore(riskLevel: string): number {\n  const riskMap: Record<string, number> = {\n    'Low': 25,\n    'Medium': 50,\n    'High': 75,\n    'Critical': 95,\n  };\n  \n  return riskMap[riskLevel] || 50;\n}\n\n/**\n * Map WorkItemDto to Application (frontend domain model)\n */\nexport function mapWorkItemToApplication(workItem: WorkItemDto): Application {\n  return {\n    id: workItem.workItemNumber || workItem.id, // Use workItemNumber for display\n    workItemId: workItem.id, // Actual GUID\n    legalName: workItem.applicantName,\n    entityType: workItem.entityType,\n    country: workItem.country,\n    status: mapBackendStatusToFrontend(workItem.status),\n    backendStatus: workItem.status,\n    created: workItem.createdAt,\n    updated: workItem.updatedAt || workItem.createdAt,\n    submittedBy: workItem.assignedToName || workItem.assignedTo || 'Unknown',\n    riskScore: mapRiskLevelToScore(workItem.riskLevel),\n    workItemNumber: workItem.workItemNumber,\n    applicationId: workItem.applicationId,\n    priority: workItem.priority,\n    riskLevel: workItem.riskLevel,\n    assignedTo: workItem.assignedTo,\n    assignedToName: workItem.assignedToName,\n    assignedAt: workItem.assignedAt,\n    requiresApproval: workItem.requiresApproval,\n    approvedBy: workItem.approvedBy,\n    approvedByName: workItem.approvedByName,\n    approvedAt: workItem.approvedAt,\n    rejectionReason: workItem.rejectionReason,\n    dueDate: workItem.dueDate,\n    isOverdue: workItem.isOverdue,\n    nextRefreshDate: workItem.nextRefreshDate,\n    lastRefreshedAt: workItem.lastRefreshedAt,\n    refreshCount: workItem.refreshCount,\n  };\n}\n\n/**\n * Map array of WorkItemDto to Application array\n */\nexport function mapWorkItemsToApplications(workItems: WorkItemDto[]): Application[] {\n  return workItems.map(mapWorkItemToApplication);\n}\n\n","/**\n * Applications API Client\n * Thin HTTP client for applications endpoints\n * All business logic and mapping should be in use-cases layer\n */\n\nimport { OnboardingCaseProjection, PagedResult } from '../dtos/application.dto';\n\nconst API_BASE_URL = typeof window !== 'undefined' ? '' : 'http://localhost:3001';\n\n/**\n * Get applications from projections API\n */\nexport async function getApplications(\n  page: number = 1,\n  pageSize: number = 20,\n  searchTerm?: string,\n  status?: string\n): Promise<PagedResult<OnboardingCaseProjection>> {\n  const params = new URLSearchParams({\n    page: page.toString(),\n    pageSize: pageSize.toString(),\n  });\n  \n  if (searchTerm) {\n    params.append('searchTerm', searchTerm);\n  }\n  \n  if (status) {\n    params.append('status', status);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/applications?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch applications: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  \n  // Transform response to match PagedResult interface\n  return {\n    items: data.items || data.data || [],\n    totalCount: data.total_count || data.totalCount || data.total || 0,\n    page: data.page || page,\n    pageSize: data.page_size || data.pageSize || pageSize,\n  };\n}\n\n/**\n * Get application by ID\n */\nexport async function getApplicationById(id: string): Promise<OnboardingCaseProjection> {\n  const response = await fetch(`${API_BASE_URL}/api/applications/${id}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch application: ${response.status} ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n/**\n * Update application status\n */\nexport async function updateApplicationStatus(\n  id: string,\n  status: string,\n  notes?: string\n): Promise<void> {\n  const response = await fetch(`${API_BASE_URL}/api/applications/${id}/status`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ status, notes }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to update application status: ${response.status} ${response.statusText}`);\n  }\n}\n\n","/**\n * Dashboard API Client\n * Thin HTTP client for dashboard endpoints\n */\n\nimport { DashboardStats, EntityTypeDistribution, DailyTrend, DashboardProjection } from '../dtos/dashboard.dto';\n\nconst API_BASE_URL = typeof window !== 'undefined' ? '' : 'http://localhost:3001';\n\n/**\n * Get dashboard statistics\n */\nexport async function getDashboardStats(partnerId?: string): Promise<DashboardStats> {\n  const params = new URLSearchParams();\n  if (partnerId) {\n    params.append('partnerId', partnerId);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/dashboard?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch dashboard stats: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Get entity type distribution\n */\nexport async function getEntityTypeDistribution(partnerId?: string): Promise<Array<{ name: string; value: number }>> {\n  const params = new URLSearchParams();\n  if (partnerId) {\n    params.append('partnerId', partnerId);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/entity-type-distribution?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch entity type distribution: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return Array.isArray(data) ? data : data.items || data.data || [];\n}\n\n/**\n * Get daily trends\n */\nexport async function getDailyTrends(partnerId?: string): Promise<DailyTrend[]> {\n  const params = new URLSearchParams();\n  if (partnerId) {\n    params.append('partnerId', partnerId);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/trends?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch daily trends: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return Array.isArray(data) ? data : data.items || data.data || [];\n}\n\n/**\n * Get application trends\n */\nexport async function getApplicationTrends(days: number = 7, partnerId?: string): Promise<DailyTrend[]> {\n  const params = new URLSearchParams({\n    days: days.toString(),\n  });\n  if (partnerId) {\n    params.append('partnerId', partnerId);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/trends?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch application trends: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return Array.isArray(data) ? data : data.items || data.data || [];\n}\n\n/**\n * Get dashboard projection (full dashboard data)\n */\nexport async function getDashboardProjection(partnerId?: string): Promise<DashboardProjection> {\n  const params = new URLSearchParams();\n  if (partnerId) {\n    params.append('partnerId', partnerId);\n  }\n\n  const response = await fetch(`${API_BASE_URL}/api/dashboard?${params.toString()}`, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    cache: 'no-store',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch dashboard projection: ${response.status} ${response.statusText}`);\n  }\n\n  return response.json();\n}\n\n","/**\n * WorkQueue API Client\n * Thin HTTP client for work queue endpoints\n * All business logic and mapping should be in use-cases layer\n */\n\nimport { WorkItemDto, PagedResult } from '../dtos/workQueue.dto';\n\nconst API_BASE_URL = typeof window !== 'undefined' ? '' : 'http://localhost:3001';\n\n/**\n * Get auth headers for API requests\n */\nasync function getAuthHeaders(): Promise<HeadersInit> {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n  };\n\n  // DO NOT send accessToken - API proxy will inject it from Redis\n  // Only add user identification headers for backend\n  if (typeof window !== 'undefined') {\n    try {\n      const response = await fetch('/api/auth/session');\n      const session = await response.json();\n      \n      if (session?.user?.email) {\n        headers['X-User-Email'] = session.user.email;\n      }\n      if (session?.user?.name) {\n        headers['X-User-Name'] = session.user.name;\n      }\n      if (session?.user?.role) {\n        headers['X-User-Role'] = session.user.role;\n      }\n    } catch (error) {\n      // Silently fail - proxy will handle auth\n    }\n  }\n\n  return headers;\n}\n\n/**\n * Make API request\n */\nasync function request<T>(endpoint: string, options?: RequestInit): Promise<T> {\n  let cleanEndpoint = endpoint;\n  if (endpoint.startsWith('?')) {\n    cleanEndpoint = endpoint;\n  } else if (!endpoint.startsWith('/')) {\n    cleanEndpoint = `/${endpoint}`;\n  }\n  \n  const url = `${API_BASE_URL}/api/workqueue${cleanEndpoint}`;\n  const headers = await getAuthHeaders();\n\n  const response = await fetch(url, {\n    ...options,\n    headers: {\n      ...headers,\n      ...options?.headers,\n    },\n  });\n\n  if (!response.ok) {\n    let errorMessage = `Work Queue API request failed: ${response.status} ${response.statusText}`;\n    \n    try {\n      const errorData = await response.json();\n      errorMessage = errorData.message || errorData.error || errorMessage;\n    } catch {\n      // If JSON parsing fails, use status text\n    }\n    \n    throw new Error(errorMessage);\n  }\n\n  // Handle empty responses\n  const text = await response.text();\n  if (!text || text.trim() === '') {\n    return null as T;\n  }\n  \n  return JSON.parse(text) as T;\n}\n\n/**\n * Get work items (returns raw DTOs)\n */\nexport async function getWorkItems(filters?: {\n  status?: string;\n  searchTerm?: string;\n  country?: string;\n  riskLevel?: string;\n  page?: number;\n  pageSize?: number;\n}): Promise<PagedResult<WorkItemDto>> {\n  const params = new URLSearchParams();\n  \n  if (filters?.status && filters.status !== 'ALL') {\n    params.append('status', filters.status);\n  }\n  if (filters?.searchTerm) {\n    params.append('searchTerm', filters.searchTerm);\n  }\n  if (filters?.country) {\n    params.append('country', filters.country);\n  }\n  if (filters?.riskLevel) {\n    params.append('riskLevel', filters.riskLevel);\n  }\n  \n  const page = filters?.page || 1;\n  const pageSize = filters?.pageSize || 100;\n  params.append('page', page.toString());\n  params.append('pageSize', pageSize.toString());\n  \n  const result = await request<any>(`?${params.toString()}`);\n  \n  // Handle both camelCase and snake_case response formats\n  const items = result.items || result.data || [];\n  const totalCount = result.totalCount || result.total_count || 0;\n  \n  return {\n    items,\n    totalCount,\n    page,\n    pageSize,\n  };\n}\n\n/**\n * Get work item by ID\n */\nexport async function getWorkItemById(id: string): Promise<WorkItemDto | null> {\n  try {\n    return await request<WorkItemDto>(`/${id}`);\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('404')) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get my assigned work items\n */\nexport async function getMyWorkItems(page: number = 1, pageSize: number = 20): Promise<PagedResult<WorkItemDto>> {\n  const params = new URLSearchParams({\n    page: page.toString(),\n    pageSize: pageSize.toString(),\n  });\n  \n  const result = await request<any>(`/my-items?${params.toString()}`);\n  \n  const items = result.items || result.data || [];\n  const totalCount = result.totalCount || result.total_count || 0;\n  \n  return {\n    items,\n    totalCount,\n    page,\n    pageSize,\n  };\n}\n\n/**\n * Get pending approvals\n */\nexport async function getPendingApprovals(page: number = 1, pageSize: number = 20): Promise<PagedResult<WorkItemDto>> {\n  const params = new URLSearchParams({\n    page: page.toString(),\n    pageSize: pageSize.toString(),\n  });\n  \n  const result = await request<any>(`/pending-approvals?${params.toString()}`);\n  \n  const items = result.items || result.data || [];\n  const totalCount = result.totalCount || result.total_count || 0;\n  \n  return {\n    items,\n    totalCount,\n    page,\n    pageSize,\n  };\n}\n\n/**\n * Get items due for refresh\n */\nexport async function getItemsDueForRefresh(page: number = 1, pageSize: number = 100, asOfDate?: Date): Promise<PagedResult<WorkItemDto>> {\n  const params = new URLSearchParams({\n    page: page.toString(),\n    pageSize: pageSize.toString(),\n  });\n  if (asOfDate) {\n    params.append('asOfDate', asOfDate.toISOString());\n  }\n  \n  return await request<PagedResult<WorkItemDto>>(`/due-for-refresh?${params.toString()}`);\n}\n\n/**\n * Assign work item to a user\n */\nexport async function assignWorkItem(id: string, assignedToUserId: string, assignedToUserName: string): Promise<void> {\n  // Generate GUID if needed (for backwards compatibility)\n  let userIdGuid: string;\n  if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(assignedToUserId)) {\n    userIdGuid = assignedToUserId;\n  } else {\n    // Simple hash to generate consistent GUID\n    let hash = 0;\n    for (let i = 0; i < assignedToUserId.length; i++) {\n      const char = assignedToUserId.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    const hex = Math.abs(hash).toString(16).padStart(32, '0');\n    userIdGuid = `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}`;\n  }\n  \n  await request(`/${id}/assign`, {\n    method: 'POST',\n    body: JSON.stringify({\n      AssignedToUserId: userIdGuid,\n      AssignedToUserName: assignedToUserName,\n    }),\n  });\n}\n\n/**\n * Unassign work item\n */\nexport async function unassignWorkItem(id: string): Promise<void> {\n  await request(`/${id}/unassign`, {\n    method: 'POST',\n  });\n}\n\n/**\n * Start review on work item\n */\nexport async function startReview(id: string): Promise<void> {\n  await request(`/${id}/start-review`, {\n    method: 'POST',\n  });\n}\n\n/**\n * Submit work item for approval\n */\nexport async function submitForApproval(id: string, notes?: string): Promise<void> {\n  await request(`/${id}/submit-for-approval`, {\n    method: 'POST',\n    body: JSON.stringify({ notes: notes || '' }),\n  });\n}\n\n/**\n * Approve work item\n */\nexport async function approveWorkItem(id: string, notes?: string): Promise<void> {\n  await request(`/${id}/approve`, {\n    method: 'POST',\n    body: JSON.stringify({ notes: notes || '' }),\n  });\n}\n\n/**\n * Decline work item\n */\nexport async function declineWorkItem(id: string, reason: string): Promise<void> {\n  await request(`/${id}/decline`, {\n    method: 'POST',\n    body: JSON.stringify({ reason }),\n  });\n}\n\n/**\n * Complete work item\n */\nexport async function completeWorkItem(id: string, notes?: string): Promise<void> {\n  await request(`/${id}/complete`, {\n    method: 'POST',\n    body: JSON.stringify({ notes: notes || '' }),\n  });\n}\n\n/**\n * Mark work item for refresh\n */\nexport async function markForRefresh(id: string): Promise<void> {\n  await request(`/${id}/mark-for-refresh`, {\n    method: 'POST',\n  });\n}\n\n/**\n * Add comment to work item\n */\nexport async function addComment(id: string, text: string): Promise<void> {\n  await request(`/${id}/comments`, {\n    method: 'POST',\n    body: JSON.stringify({ text }),\n  });\n}\n\n/**\n * Get work item comments\n */\nexport async function getWorkItemComments(id: string): Promise<any[]> {\n  return await request<any[]>(`/${id}/comments`);\n}\n\n/**\n * Get work item history\n */\nexport async function getWorkItemHistory(id: string): Promise<any[]> {\n  return await request<any[]>(`/${id}/history`);\n}\n\n","/**\n * Application Mappers\n * Functions to transform between backend DTOs and frontend domain models\n */\n\nimport { OnboardingCaseProjection, Application } from '../dtos/application.dto';\n\n// Status mapping from backend to frontend\nfunction mapBackendStatusToFrontend(backendStatus: string): Application['status'] {\n  const statusMap: Record<string, Application['status']> = {\n    'Draft': 'IN_PROGRESS',\n    'InProgress': 'IN_PROGRESS',\n    'PendingReview': 'RISK_REVIEW',\n    'Submitted': 'SUBMITTED',\n    'Approved': 'COMPLETE',\n    'Rejected': 'DECLINED',\n    'Cancelled': 'DECLINED',\n  };\n  \n  return statusMap[backendStatus] || 'IN_PROGRESS';\n}\n\n// Risk level mapping from backend to frontend\nfunction mapBackendRiskLevelToFrontend(riskLevel: string): Application['riskLevel'] {\n  const riskMap: Record<string, Application['riskLevel']> = {\n    'Low': 'LOW',\n    'MediumLow': 'LOW',\n    'Medium': 'MEDIUM',\n    'MediumHigh': 'HIGH',\n    'High': 'HIGH',\n  };\n  \n  return riskMap[riskLevel] || 'MEDIUM';\n}\n\n/**\n * Map OnboardingCaseProjection (backend DTO) to Application (frontend model)\n */\nexport function mapProjectionToApplication(projection: OnboardingCaseProjection): Application {\n  // Determine company name - use business legal name if available, otherwise use applicant name\n  const companyName = projection.businessLegalName || \n                     `${projection.applicantFirstName} ${projection.applicantLastName}`.trim() ||\n                     'Unknown';\n  \n  // Determine country - use business country if available, otherwise use applicant country\n  const country = projection.businessCountryOfRegistration || \n                 projection.applicantCountry || \n                 'Unknown';\n  \n  // Determine entity type - use type from projection, or derive from business info\n  const entityType = projection.type || \n                    (projection.businessLegalName ? 'Business' : 'Individual') ||\n                    'Unknown';\n  \n  // Get assigned to name or fallback\n  const assignedTo = projection.assignedToName || \n                    projection.assignedTo || \n                    'Unassigned';\n  \n  // Get submitted date or created date\n  const submittedDate = projection.submittedAt || \n                       projection.createdAt;\n  \n  // Get progress percentage (round to integer)\n  const progress = Math.round(projection.progressPercentage || 0);\n\n  return {\n    id: projection.caseId || projection.id,\n    companyName,\n    entityType,\n    status: mapBackendStatusToFrontend(projection.status),\n    submittedDate,\n    assignedTo,\n    riskLevel: mapBackendRiskLevelToFrontend(projection.riskLevel),\n    country,\n    progress,\n  };\n}\n\n/**\n * Map array of projections to applications\n */\nexport function mapProjectionsToApplications(projections: OnboardingCaseProjection[]): Application[] {\n  return projections.map(mapProjectionToApplication);\n}\n\n","/**\n * Services Index\n * Central export point for all service modules\n * \n * Usage:\n *   import { fetchApplications, fetchDashboardStats } from '@/services';\n *   import { Application, DashboardStats } from '@/services/dtos/application.dto';\n */\n\n// API Clients\nexport * from './api/applicationsApi';\nexport * from './api/dashboardApi';\nexport * from './api/workQueueApi';\n\n// DTOs\nexport * from './dtos/application.dto';\nexport * from './dtos/dashboard.dto';\n// WorkQueue exports - use explicit exports to avoid conflicts\nexport type {\n  WorkItemDto,\n  Application as WorkItemApplication,\n  PagedResult as WorkQueuePagedResult,\n  WorkItemFilters,\n} from './dtos/workQueue.dto';\n\n// Mappers\nexport * from './mappers/applicationMapper';\nexport * from './mappers/workQueueMapper';\n\n// Use Cases\nexport * from './use-cases/applicationUseCases';\nexport * from './use-cases/dashboardUseCases';\nexport * from './use-cases/workQueueUseCases';\n\n// Re-export fetchApplicationTrends for convenience\nexport { fetchApplicationTrends } from './use-cases/dashboardUseCases';\n\n// Re-export getWorkItems for direct API access (when DTOs are needed)\nexport { getWorkItems } from './api/workQueueApi';\n\n// Re-export export functions\nexport { exportApplications } from './use-cases/applicationUseCases';\nexport { exportWorkItems } from './use-cases/workQueueUseCases';\n\n","/**\n * Application Use Cases\n * Business logic and orchestration for application operations\n * This layer coordinates between API clients, mappers, and domain logic\n */\n\nimport { getApplications, getApplicationById, updateApplicationStatus } from '../api/applicationsApi';\nimport { mapProjectionToApplication, mapProjectionsToApplications } from '../mappers/applicationMapper';\nimport { Application, OnboardingCaseProjection, PagedResult } from '../dtos/application.dto';\n\n/**\n * Get applications with frontend domain model\n */\nexport async function fetchApplications(\n  page: number = 1,\n  pageSize: number = 20,\n  searchTerm?: string,\n  status?: string\n): Promise<PagedResult<Application>> {\n  // Call API to get backend DTOs\n  const backendResult = await getApplications(page, pageSize, searchTerm, status);\n  \n  // Map backend DTOs to frontend domain models\n  const applications = mapProjectionsToApplications(backendResult.items);\n  \n  // Return with frontend domain models\n  return {\n    items: applications,\n    totalCount: backendResult.totalCount,\n    page: backendResult.page,\n    pageSize: backendResult.pageSize,\n  };\n}\n\n/**\n * Get application by ID with frontend domain model\n */\nexport async function fetchApplicationById(id: string): Promise<Application> {\n  // Call API to get backend DTO\n  const projection = await getApplicationById(id);\n  \n  // Map to frontend domain model\n  return mapProjectionToApplication(projection);\n}\n\n/**\n * Update application status (business logic layer)\n */\nexport async function updateApplicationStatusUseCase(\n  id: string,\n  status: string,\n  notes?: string\n): Promise<void> {\n  // Validate status transition (business logic)\n  const validStatuses = ['SUBMITTED', 'IN_PROGRESS', 'RISK_REVIEW', 'COMPLETE', 'DECLINED'];\n  if (!validStatuses.includes(status)) {\n    throw new Error(`Invalid status: ${status}. Must be one of: ${validStatuses.join(', ')}`);\n  }\n  \n  // Call API\n  await updateApplicationStatus(id, status, notes);\n}\n\n/**\n * Get application with full details (includes related data)\n */\nexport async function fetchApplicationWithDetails(id: string): Promise<{\n  application: Application;\n  projection: OnboardingCaseProjection;\n}> {\n  const projection = await getApplicationById(id);\n  const application = mapProjectionToApplication(projection);\n  \n  return {\n    application,\n    projection,\n  };\n}\n\n/**\n * Export applications as CSV\n */\nexport async function exportApplications(filters?: {\n  status?: string;\n  search?: string;\n  riskLevel?: string;\n}): Promise<Blob> {\n  // Get all items for export (no pagination)\n  const result = await fetchApplications(\n    1,\n    10000, // Get all items\n    filters?.search,\n    filters?.status\n  );\n  \n  // Convert to CSV\n  const { escapeCsvField, createCsvBlob } = await import('../utils/csvExport');\n  \n  const headers = [\n    'Application ID',\n    'Company Name',\n    'Entity Type',\n    'Country',\n    'Status',\n    'Risk Level',\n    'Assigned To',\n    'Progress',\n    'Submitted Date'\n  ];\n  \n  const rows = result.items.map(app => [\n    escapeCsvField(app.id),\n    escapeCsvField(app.companyName),\n    escapeCsvField(app.entityType),\n    escapeCsvField(app.country),\n    escapeCsvField(app.status),\n    escapeCsvField(app.riskLevel),\n    escapeCsvField(app.assignedTo),\n    escapeCsvField(`${app.progress}%`),\n    escapeCsvField(new Date(app.submittedDate).toLocaleDateString()),\n  ]);\n  \n  return createCsvBlob(headers, rows);\n}\n","/**\n * Dashboard Use Cases\n * Business logic and orchestration for dashboard operations\n */\n\nimport { getDashboardStats, getEntityTypeDistribution, getApplicationTrends, getDashboardProjection } from '../api/dashboardApi';\nimport { DashboardStats, EntityTypeDistribution, DailyTrend, DashboardProjection } from '../dtos/dashboard.dto';\n\n/**\n * Get dashboard statistics\n * Maps from DashboardProjection to DashboardStats\n */\nexport async function fetchDashboardStats(partnerId?: string): Promise<DashboardStats> {\n  // The old API mapped from DashboardProjection, but our new API client already does this\n  // If we need the mapping, we should do it here in the use case layer\n  const dashboard = await getDashboardProjection(partnerId);\n  \n  // Map backend data to frontend format\n  return {\n    totalApplications: dashboard.cases.totalCases,\n    pendingReview: dashboard.cases.pendingReviewCases,\n    riskReview: dashboard.risk.casesRequiringManualReview,\n    completed: dashboard.cases.completedCases,\n    incomplete: dashboard.cases.activeCases - dashboard.cases.pendingReviewCases,\n    declined: dashboard.cases.rejectedCases,\n    avgProcessingTime: Number(dashboard.performance.averageCompletionTimeHours / 24), // Convert hours to days\n    successRate: Number(dashboard.performance.completionRate),\n  };\n}\n\n/**\n * Get entity type distribution\n * Maps from backend format { name, value } to frontend format { type, count }\n */\nexport async function fetchEntityTypeDistribution(partnerId?: string): Promise<EntityTypeDistribution[]> {\n  const result = await getEntityTypeDistribution(partnerId);\n  // Map backend format { name, value } to frontend format { type, count }\n  return result.map(item => ({\n    type: item.name,\n    count: item.value\n  }));\n}\n\n/**\n * Get application trends\n */\nexport async function fetchApplicationTrends(days: number = 7, partnerId?: string): Promise<DailyTrend[]> {\n  return getApplicationTrends(days, partnerId);\n}\n\n/**\n * Get daily trends (alias for fetchApplicationTrends)\n */\nexport async function fetchDailyTrends(partnerId?: string): Promise<DailyTrend[]> {\n  return getApplicationTrends(7, partnerId);\n}\n\n/**\n * Get full dashboard projection\n */\nexport async function fetchDashboardProjection(partnerId?: string): Promise<DashboardProjection> {\n  return getDashboardProjection(partnerId);\n}\n\n","/**\n * WorkQueue Use Cases\n * Business logic and orchestration for work queue operations\n */\n\nimport {\n  getWorkItems,\n  getWorkItemById,\n  getMyWorkItems,\n  getPendingApprovals,\n  getItemsDueForRefresh,\n  assignWorkItem,\n  unassignWorkItem,\n  startReview,\n  submitForApproval,\n  approveWorkItem,\n  declineWorkItem,\n  completeWorkItem,\n  markForRefresh,\n  addComment,\n  getWorkItemComments,\n  getWorkItemHistory,\n} from '../api/workQueueApi';\nimport { mapWorkItemToApplication, mapWorkItemsToApplications } from '../mappers/workQueueMapper';\nimport { WorkItemDto, Application, PagedResult, WorkItemFilters } from '../dtos/workQueue.dto';\n\n/**\n * Map frontend status to backend status\n */\nfunction mapFrontendStatusToBackend(status: string): string {\n  const statusMap: Record<string, string> = {\n    'SUBMITTED': 'New',\n    'IN PROGRESS': 'InProgress',\n    'RISK REVIEW': 'PendingApproval',\n    'COMPLETE': 'Completed',\n    'DECLINED': 'Declined',\n  };\n  return statusMap[status] || status;\n}\n\n/**\n * Get work items with frontend domain model\n */\nexport async function fetchWorkItems(filters?: WorkItemFilters): Promise<PagedResult<Application>> {\n  // Map frontend status to backend if needed\n  const backendFilters = filters ? {\n    ...filters,\n    status: filters.status && filters.status !== 'ALL' ? mapFrontendStatusToBackend(filters.status) : undefined,\n  } : undefined;\n  \n  const result = await getWorkItems(backendFilters);\n  const applications = mapWorkItemsToApplications(result.items);\n  \n  return {\n    items: applications,\n    totalCount: result.totalCount,\n    page: result.page,\n    pageSize: result.pageSize,\n  };\n}\n\n/**\n * Get work item by ID with frontend domain model\n */\nexport async function fetchWorkItemById(id: string): Promise<Application | null> {\n  const workItem = await getWorkItemById(id);\n  if (!workItem) {\n    return null;\n  }\n  return mapWorkItemToApplication(workItem);\n}\n\n/**\n * Get my assigned work items\n */\nexport async function fetchMyWorkItems(page: number = 1, pageSize: number = 20): Promise<PagedResult<Application>> {\n  const result = await getMyWorkItems(page, pageSize);\n  const applications = mapWorkItemsToApplications(result.items);\n  \n  return {\n    items: applications,\n    totalCount: result.totalCount,\n    page: result.page,\n    pageSize: result.pageSize,\n  };\n}\n\n/**\n * Get pending approvals\n */\nexport async function fetchPendingApprovals(page: number = 1, pageSize: number = 20): Promise<PagedResult<WorkItemDto>> {\n  return getPendingApprovals(page, pageSize);\n}\n\n/**\n * Get items due for refresh\n */\nexport async function fetchItemsDueForRefresh(page: number = 1, pageSize: number = 100, asOfDate?: Date): Promise<PagedResult<WorkItemDto>> {\n  return getItemsDueForRefresh(page, pageSize, asOfDate);\n}\n\n/**\n * Assign work item (business logic layer)\n */\nexport async function assignWorkItemUseCase(id: string, assignedToUserId: string, assignedToUserName: string): Promise<void> {\n  // Validate inputs\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  if (!assignedToUserId) {\n    throw new Error('User ID is required');\n  }\n  if (!assignedToUserName) {\n    throw new Error('User name is required');\n  }\n  \n  await assignWorkItem(id, assignedToUserId, assignedToUserName);\n}\n\n/**\n * Unassign work item\n */\nexport async function unassignWorkItemUseCase(id: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await unassignWorkItem(id);\n}\n\n/**\n * Start review\n */\nexport async function startReviewUseCase(id: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await startReview(id);\n}\n\n/**\n * Submit for approval\n */\nexport async function submitForApprovalUseCase(id: string, notes?: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await submitForApproval(id, notes);\n}\n\n/**\n * Approve work item\n */\nexport async function approveWorkItemUseCase(id: string, notes?: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await approveWorkItem(id, notes);\n}\n\n/**\n * Decline work item\n */\nexport async function declineWorkItemUseCase(id: string, reason: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  if (!reason || reason.trim().length === 0) {\n    throw new Error('Rejection reason is required');\n  }\n  await declineWorkItem(id, reason);\n}\n\n/**\n * Complete work item\n */\nexport async function completeWorkItemUseCase(id: string, notes?: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await completeWorkItem(id, notes);\n}\n\n/**\n * Mark for refresh\n */\nexport async function markForRefreshUseCase(id: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  await markForRefresh(id);\n}\n\n/**\n * Add comment\n */\nexport async function addCommentUseCase(id: string, text: string): Promise<void> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  if (!text || text.trim().length === 0) {\n    throw new Error('Comment text is required');\n  }\n  await addComment(id, text);\n}\n\n/**\n * Get work item comments\n */\nexport async function fetchWorkItemComments(id: string): Promise<any[]> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  return getWorkItemComments(id);\n}\n\n/**\n * Get work item history\n */\nexport async function fetchWorkItemHistory(id: string): Promise<any[]> {\n  if (!id) {\n    throw new Error('Work item ID is required');\n  }\n  return getWorkItemHistory(id);\n}\n\n/**\n * Export work items as CSV\n */\nexport async function exportWorkItems(filters?: {\n  status?: string;\n  searchTerm?: string;\n  country?: string;\n}): Promise<Blob> {\n  // Map frontend status to backend if needed\n  const backendFilters = filters ? {\n    ...filters,\n    status: filters.status && filters.status !== 'ALL' ? mapFrontendStatusToBackend(filters.status) : undefined,\n  } : undefined;\n  \n  // Get all items for export (no pagination)\n  const result = await getWorkItems({\n    ...backendFilters,\n    page: 1,\n    pageSize: 10000,\n  });\n  \n  // Convert to CSV\n  const { escapeCsvField, createCsvBlob } = await import('../utils/csvExport');\n  const { mapWorkItemToApplication } = await import('../mappers/workQueueMapper');\n  \n  const headers = [\n    'Application ID',\n    'Work Item Number',\n    'Legal Name',\n    'Entity Type',\n    'Country',\n    'Status',\n    'Priority',\n    'Risk Level',\n    'Assigned To',\n    'Created Date',\n    'Updated Date'\n  ];\n  \n  const rows = result.items.map(workItem => {\n    const app = mapWorkItemToApplication(workItem);\n    return [\n      escapeCsvField(app.id),\n      escapeCsvField(workItem.workItemNumber),\n      escapeCsvField(app.legalName),\n      escapeCsvField(app.entityType),\n      escapeCsvField(app.country),\n      escapeCsvField(app.status),\n      escapeCsvField(workItem.priority),\n      escapeCsvField(workItem.riskLevel),\n      escapeCsvField(workItem.assignedToName || workItem.assignedTo),\n      escapeCsvField(new Date(app.created).toLocaleDateString()),\n      escapeCsvField(new Date(app.updated).toLocaleDateString()),\n    ];\n  });\n  \n  return createCsvBlob(headers, rows);\n}\n\n"],"names":[],"mappings":"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"}}]
}