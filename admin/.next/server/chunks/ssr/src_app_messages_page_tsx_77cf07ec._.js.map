{
  "version": 3,
  "sources": [],
  "debugId": "67af6edb-9620-a148-5ea3-3e493eaf5c3d",
  "sections": [
    {"offset": {"line": 1, "column": 0}, "map": {"version":3,"sources":["../../../../src/lib/messagingApi.ts","../../../../src/app/messages/page.tsx","../../../../node_modules/%40microsoft/signalr/src/pkg-version.ts","../../../../src/lib/signalRService.ts","../../../../node_modules/%40microsoft/signalr/src/HeaderNames.ts","../../../../node_modules/%40microsoft/signalr/src/IHubProtocol.ts","../../../../node_modules/%40microsoft/signalr/src/DefaultReconnectPolicy.ts","../../../../node_modules/%40microsoft/signalr/src/ITransport.ts","../../../../node_modules/%40microsoft/signalr/src/AbortController.ts","../../../../node_modules/%40microsoft/signalr/src/HttpClient.ts","../../../../node_modules/%40microsoft/signalr/src/TextMessageFormat.ts","../../../../node_modules/%40microsoft/signalr/src/Subject.ts","../../../../src/lib/pushNotifications.ts","../../../../node_modules/%40microsoft/signalr/src/FetchHttpClient.ts","../../../../node_modules/%40microsoft/signalr/src/LongPollingTransport.ts","../../../../node_modules/%40microsoft/signalr/src/XhrHttpClient.ts","../../../../node_modules/%40microsoft/signalr/src/DefaultHttpClient.ts","../../../../node_modules/%40microsoft/signalr/src/ServerSentEventsTransport.ts","../../../../node_modules/%40microsoft/signalr/src/Utils.ts","../../../../node_modules/%40microsoft/signalr/src/HubConnectionBuilder.ts","../../../../node_modules/%40microsoft/signalr/src/HubConnection.ts","../../../../node_modules/%40microsoft/signalr/src/JsonHubProtocol.ts","../../../../node_modules/%40microsoft/signalr/src/WebSocketTransport.ts","../../../../node_modules/%40microsoft/signalr/src/HttpConnection.ts","../../../../node_modules/%40microsoft/signalr/src/Loggers.ts","../../../../node_modules/%40microsoft/signalr/src/HandshakeProtocol.ts","../../../../node_modules/%40microsoft/signalr/src/AccessTokenHttpClient.ts","../../../../node_modules/%40microsoft/signalr/src/MessageBuffer.ts","../../../../node_modules/%40microsoft/signalr/src/ILogger.ts","../../../../node_modules/%40microsoft/signalr/src/Errors.ts","../../../../src/lib/documentUpload.ts"],"sourcesContent":["// Messaging API service for connecting to backend messaging service via Next.js proxy\n\nconst API_BASE = typeof window !== 'undefined' ? '' : 'http://localhost:3001'; // Use relative path in browser, absolute in SSR\nconst MESSAGING_PREFIX = '/api/proxy/messaging';\n\n// Generate a deterministic GUID from email (matching backend's approach)\n// Uses a simple hash-based approach that produces consistent GUIDs\nfunction generateGuidFromEmailSync(email: string, namespaceGuid: string): string {\n  const emailLower = email.toLowerCase();\n  // Simple hash-based approach for immediate use\n  let hash = 0;\n  for (let i = 0; i < emailLower.length; i++) {\n    const char = emailLower.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash;\n  }\n  const hashStr = Math.abs(hash).toString(16).padStart(8, '0');\n  // Format as GUID\n  return `${hashStr.substring(0, 8)}-${hashStr.substring(0, 4)}-5000-8000-${hashStr.padEnd(12, '0')}`;\n}\n\nfunction parseGuidToBytes(guid: string): Uint8Array {\n  const cleaned = guid.replace(/-/g, '');\n  const bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; i++) {\n    bytes[i] = parseInt(cleaned.substring(i * 2, i * 2 + 2), 16);\n  }\n  return bytes;\n}\n\nfunction bytesToGuid(bytes: Uint8Array): string {\n  const hex = Array.from(bytes)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n  return `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}`;\n}\n\n// Backend DTO types\nexport type MessageDto = {\n  id: string;\n  threadId: string;\n  senderId: string;\n  senderName: string;\n  senderRole: string;\n  receiverId?: string | null;\n  receiverName?: string | null;\n  content: string;\n  type?: string;\n  status: string;\n  sentAt: string;\n  readAt?: string | null;\n  isRead: boolean;\n  replyToMessageId?: string | null;\n  attachments?: MessageAttachmentDto[];\n  isStarred?: boolean;\n};\n\nexport type MessageAttachmentDto = {\n  id: string;\n  messageId: string;\n  fileName: string;\n  contentType: string;\n  fileSizeBytes: number;\n  storageKey: string;\n  storageUrl: string;\n  documentId?: string | null;\n  description?: string | null;\n  uploadedAt: string;\n};\n\nexport type MessageThreadDto = {\n  id: string;\n  applicationId: string;\n  applicationReference?: string;\n  applicantId: string;\n  applicantName: string;\n  assignedAdminId?: string | null;\n  assignedAdminName?: string | null;\n  isActive: boolean;\n  isArchived?: boolean;\n  isStarred?: boolean;\n  createdAt: string;\n  lastMessageAt: string;\n  messageCount: number;\n  unreadCount: number;\n  lastMessage?: MessageDto | null;\n};\n\nexport type PagedResult<T> = {\n  items: T[];\n  totalCount: number;\n  page: number;\n  pageSize: number;\n  totalPages?: number;\n  hasNextPage?: boolean;\n  hasPreviousPage?: boolean;\n};\n\nasync function getAuthHeaders(): Promise<HeadersInit> {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n  };\n\n  // DO NOT send accessToken - API proxy will inject it from Redis\n  // Only add user identification headers for backend\n  if (typeof window !== 'undefined') {\n    try {\n      const response = await fetch('/api/auth/session');\n      const session = await response.json();\n      \n      // Add user identification headers for backend\n      if (session?.user?.email) {\n        headers['X-User-Email'] = session.user.email;\n      }\n      if (session?.user?.name) {\n        headers['X-User-Name'] = session.user.name;\n      }\n      if (session?.user?.role || session?.user?.roles) {\n        const role = session.user.role || session.user.roles?.[0] || 'Admin';\n        headers['X-User-Role'] = role;\n      }\n    } catch (error) {\n      console.warn('Failed to get session:', error);\n    }\n  }\n\n  return headers;\n}\n\nasync function request<T>(endpoint: string, options?: RequestInit): Promise<T> {\n  // Use Next.js API proxy to avoid CORS issues and handle authentication\n  const url = `${API_BASE}${MESSAGING_PREFIX}${endpoint}`;\n  const headers = await getAuthHeaders();\n  \n  // Log request for debugging (in development)\n  if (process.env.NODE_ENV === 'development') {\n    console.log(`[Messaging API] ${options?.method || 'GET'} ${url}`);\n  }\n  \n  // Add user identification headers for backend services\n  // These will be forwarded by the proxy to the backend\n  if (typeof window !== 'undefined') {\n    try {\n      const response = await fetch('/api/auth/session');\n      const session = await response.json();\n      if (session?.user?.email) {\n        (headers as any)['X-User-Email'] = session.user.email;\n      }\n      if (session?.user?.name) {\n        (headers as any)['X-User-Name'] = session.user.name;\n      }\n      if (session?.user?.role || session?.user?.roles) {\n        const role = session.user.role || session.user.roles?.[0] || 'Administrator';\n        (headers as any)['X-User-Role'] = role;\n        // Generate a consistent GUID from email (matching backend's UUID v5 algorithm)\n        if (session?.user?.email) {\n          const email = session.user.email;\n          // Use the same namespace GUID as the backend (DNS namespace)\n          const namespaceGuid = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n          // Generate GUID synchronously for immediate use\n          const guid = generateGuidFromEmailSync(email, namespaceGuid);\n          (headers as any)['X-User-Id'] = guid;\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to get session for user headers:', error);\n      // Fallback to development headers\n      if (process.env.NODE_ENV === 'development') {\n        const namespaceGuid = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n        const adminGuid = generateGuidFromEmailSync('admin@mukuru.com', namespaceGuid);\n        (headers as any)['X-User-Id'] = adminGuid;\n        (headers as any)['X-User-Email'] = 'admin@mukuru.com';\n        (headers as any)['X-User-Name'] = 'Admin User';\n        (headers as any)['X-User-Role'] = 'Administrator';\n      }\n    }\n  } else {\n    // Server-side: use development headers\n    if (process.env.NODE_ENV === 'development') {\n      const namespaceGuid = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\n      const adminGuid = generateGuidFromEmailSync('admin@mukuru.com', namespaceGuid);\n      (headers as any)['X-User-Id'] = adminGuid;\n      (headers as any)['X-User-Email'] = 'admin@mukuru.com';\n      (headers as any)['X-User-Name'] = 'Admin User';\n      (headers as any)['X-User-Role'] = 'Administrator';\n    }\n  }\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        headers: {\n          ...headers,\n          ...options?.headers,\n        },\n        credentials: 'include',\n      });\n\n      // Log response for debugging (in development)\n      if (process.env.NODE_ENV === 'development') {\n        console.log(`[Messaging API] Response: ${response.status} ${response.statusText}`);\n      }\n\n      // Get response text for debugging before parsing (can only read once)\n      const responseText = await response.text();\n      \n      if (!response.ok) {\n      let errorMessage = `Messaging API request failed: ${response.status} ${response.statusText}`;\n      \n      try {\n        const errorJson = JSON.parse(responseText);\n        if (errorJson.message) {\n          errorMessage = errorJson.message;\n        } else if (errorJson.details) {\n          errorMessage = errorJson.details;\n        } else if (errorJson.error) {\n          errorMessage = errorJson.error;\n        }\n      } catch {\n        if (responseText && responseText.trim().length > 0) {\n          errorMessage = responseText.length > 200 ? responseText.substring(0, 200) + '...' : responseText;\n        }\n      }\n      \n      // Provide helpful error message for service unavailable\n      if (response.status === 503) {\n        errorMessage = 'Backend messaging service is unavailable. Please ensure the messaging service is running.';\n      }\n      \n      throw new Error(errorMessage);\n    }\n      \n      if (process.env.NODE_ENV === 'development' && endpoint.includes('threads/my')) {\n        console.log(`[Messaging API] Response body (first 500 chars):`, responseText.substring(0, 500));\n      }\n\n      // Handle responses\n      const contentType = response.headers.get('content-type');\n      const text = responseText; // Use the text we already read\n      \n      if (contentType && contentType.includes('application/json')) {\n        if (!text || text.trim() === '') {\n          console.warn('[Messaging API] Empty response body for:', endpoint);\n          return {} as T;\n        }\n        try {\n          const parsed = JSON.parse(text) as T;\n          if (process.env.NODE_ENV === 'development' && endpoint.includes('threads/my')) {\n            // Check both camelCase and PascalCase\n            const data = parsed as any;\n            console.log('[Messaging API] Parsed response (full):', JSON.stringify(data, null, 2));\n            console.log('[Messaging API] Parsed response (summary):', {\n              totalCount: data.totalCount || data.TotalCount || 0,\n              itemsCount: (data.items || data.Items || []).length,\n              page: data.page || data.Page || 0,\n              pageSize: data.pageSize || data.PageSize || 0,\n              hasItems: !!(data.items || data.Items),\n              itemsPreview: (data.items || data.Items || []).slice(0, 2)\n            });\n          }\n          return parsed;\n        } catch (parseError) {\n          console.error('[Messaging API] JSON parse error:', parseError, 'Response text:', text);\n          throw new Error('Invalid JSON response from server');\n        }\n      }\n\n      // For non-JSON responses\n      if (text && text.trim().length > 0) {\n        console.warn('[Messaging API] Non-JSON response received:', text.substring(0, 200));\n      }\n\n      return {} as T;\n  } catch (error) {\n    if (error instanceof TypeError && error.message.includes('Failed to fetch')) {\n      throw new Error(`Cannot connect to Messaging API. Please ensure the backend services are running.`);\n    }\n    throw error;\n  }\n}\n\nexport const messagingApi = {\n  /**\n   * Get my message threads\n   */\n  async getMyThreads(page = 1, pageSize = 20): Promise<PagedResult<MessageThreadDto>> {\n    const qs = new URLSearchParams({ \n      page: String(page), \n      pageSize: String(pageSize) \n    }).toString();\n    const result = await request<any>(`/api/v1/messages/threads/my?${qs}`);\n    \n    // Normalize response - handle both camelCase and PascalCase from backend\n    return {\n      items: result.items || result.Items || [],\n      totalCount: result.totalCount ?? result.TotalCount ?? 0,\n      page: result.page ?? result.Page ?? page,\n      pageSize: result.pageSize ?? result.PageSize ?? pageSize,\n      totalPages: result.totalPages ?? result.TotalPages ?? 0,\n      hasNextPage: result.hasNextPage ?? result.HasNextPage ?? false,\n      hasPreviousPage: result.hasPreviousPage ?? result.HasPreviousPage ?? false\n    } as PagedResult<MessageThreadDto>;\n  },\n\n  /**\n   * Get all message threads (admin only)\n   */\n  async getAllThreads(page = 1, pageSize = 20): Promise<PagedResult<MessageThreadDto>> {\n    const qs = new URLSearchParams({ \n      page: String(page), \n      pageSize: String(pageSize) \n    }).toString();\n    const result = await request<any>(`/api/v1/messages/threads/all?${qs}`);\n    \n    // Normalize response - handle both camelCase and PascalCase from backend\n    return {\n      items: result.items || result.Items || [],\n      totalCount: result.totalCount ?? result.TotalCount ?? 0,\n      page: result.page ?? result.Page ?? page,\n      pageSize: result.pageSize ?? result.PageSize ?? pageSize,\n      totalPages: result.totalPages ?? result.TotalPages ?? 0,\n      hasNextPage: result.hasNextPage ?? result.HasNextPage ?? false,\n      hasPreviousPage: result.hasPreviousPage ?? result.HasPreviousPage ?? false\n    } as PagedResult<MessageThreadDto>;\n  },\n\n  /**\n   * Get message thread by application ID\n   */\n  async getThreadByApplication(applicationId: string): Promise<MessageThreadDto> {\n    return request<MessageThreadDto>(`/api/v1/messages/threads/application/${encodeURIComponent(applicationId)}`);\n  },\n\n  /**\n   * Get messages in a thread\n   */\n  async getThreadMessages(threadId: string, page = 1, pageSize = 50): Promise<PagedResult<MessageDto>> {\n    const qs = new URLSearchParams({ \n      page: String(page), \n      pageSize: String(pageSize) \n    }).toString();\n    return request<PagedResult<MessageDto>>(`/api/v1/messages/threads/${encodeURIComponent(threadId)}/messages?${qs}`);\n  },\n\n  /**\n   * Send a message\n   */\n  async sendMessage(\n    applicationId: string, \n    content: string, \n    receiverId?: string,\n    replyToMessageId?: string,\n    attachments?: Array<{ fileName: string; contentType: string; fileSizeBytes: number; storageKey: string; storageUrl: string; documentId?: string; description?: string }>\n  ): Promise<{ success: boolean; messageId?: string; threadId?: string; errorMessage?: string }> {\n    try {\n      // Check if applicationId is a GUID or a case ID (case number)\n      const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n      let applicationGuid = applicationId;\n      \n      // If it's not a GUID, it's likely a case ID (case number), so fetch the GUID from the projections API\n      if (!guidRegex.test(applicationId)) {\n        try {\n          // Use the applications API to fetch case data\n          const { applicationsApi } = await import('./applicationsApi');\n          const caseData = await applicationsApi.getApplicationById(applicationId);\n          \n          if (caseData?.id) {\n            applicationGuid = caseData.id;\n          } else {\n            throw new Error(`Could not find application GUID for case ID: ${applicationId}`);\n          }\n        } catch (error) {\n          console.error('Failed to fetch application GUID from case ID:', error);\n          throw new Error(`Invalid application ID: ${applicationId}. Could not resolve to GUID.`);\n        }\n      }\n\n      const requestBody: any = {\n        ApplicationId: applicationGuid,\n        Content: content,\n      };\n\n      // Only include ReceiverId if provided\n      if (receiverId) {\n        requestBody.ReceiverId = receiverId;\n      }\n      \n      // Include reply-to if provided\n      if (replyToMessageId) {\n        requestBody.ReplyToMessageId = replyToMessageId;\n      }\n      \n      // Include attachments if provided\n      if (attachments && attachments.length > 0) {\n        requestBody.Attachments = attachments.map(a => ({\n          FileName: a.fileName,\n          ContentType: a.contentType,\n          FileSizeBytes: a.fileSizeBytes,\n          StorageKey: a.storageKey,\n          StorageUrl: a.storageUrl,\n          DocumentId: a.documentId,\n          Description: a.description\n        }));\n      }\n\n      const response = await request<{ \n        Success?: boolean; \n        success?: boolean;\n        MessageId?: string; \n        messageId?: string;\n        ThreadId?: string; \n        threadId?: string;\n        ErrorMessage?: string;\n        errorMessage?: string;\n      }>(`/api/v1/messages`, {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n      });\n      \n      // Map backend response format (handles both PascalCase and camelCase)\n      const success = response.Success ?? response.success ?? false;\n      const messageId = response.MessageId ?? response.messageId;\n      const threadId = response.ThreadId ?? response.threadId;\n      const errorMessage = response.ErrorMessage ?? response.errorMessage;\n\n      if (!success && errorMessage) {\n        throw new Error(errorMessage);\n      }\n\n      return {\n        success,\n        messageId,\n        threadId,\n        errorMessage,\n      };\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get unread message count\n   */\n  async getUnreadCount(): Promise<{ count: number }> {\n    try {\n      return await request<{ count: number }>(`/api/v1/messages/unread/count`);\n    } catch (error) {\n      // If endpoint doesn't exist, calculate from threads\n      const threads = await this.getMyThreads(1, 1000);\n      const totalUnread = threads.items.reduce((sum, thread) => sum + (thread.unreadCount || 0), 0);\n      return { count: totalUnread };\n    }\n  },\n\n  /**\n   * Mark message as read\n   */\n  async markMessageRead(messageId: string): Promise<void> {\n    await request(`/api/v1/messages/${encodeURIComponent(messageId)}/read`, {\n      method: 'PUT',\n    });\n  },\n\n  /**\n   * Delete a message\n   */\n  async deleteMessage(messageId: string): Promise<{ success: boolean; errorMessage?: string }> {\n    try {\n      await request(`/api/v1/messages/${encodeURIComponent(messageId)}`, {\n        method: 'DELETE',\n      });\n      return { success: true };\n    } catch (error) {\n      return { \n        success: false, \n        errorMessage: error instanceof Error ? error.message : 'Failed to delete message' \n      };\n    }\n  },\n\n  /**\n   * Star or unstar a message\n   */\n  async starMessage(messageId: string): Promise<{ success: boolean; isStarred: boolean; errorMessage?: string }> {\n    try {\n      const response = await request<{ Success?: boolean; IsStarred?: boolean; success?: boolean; isStarred?: boolean; ErrorMessage?: string }>(`/api/v1/messages/${encodeURIComponent(messageId)}/star`, {\n        method: 'PUT',\n      });\n      return {\n        success: response.Success ?? response.success ?? false,\n        isStarred: response.IsStarred ?? response.isStarred ?? false,\n        errorMessage: response.ErrorMessage\n      };\n    } catch (error) {\n      return {\n        success: false,\n        isStarred: false,\n        errorMessage: error instanceof Error ? error.message : 'Failed to star message'\n      };\n    }\n  },\n\n  /**\n   * Archive or unarchive a thread\n   */\n  async archiveThread(threadId: string, archive: boolean = true): Promise<{ success: boolean; isArchived: boolean; errorMessage?: string }> {\n    try {\n      const response = await request<{ Success?: boolean; IsArchived?: boolean; success?: boolean; isArchived?: boolean; ErrorMessage?: string }>(`/api/v1/messages/threads/${encodeURIComponent(threadId)}/archive`, {\n        method: 'PUT',\n        body: JSON.stringify({ Archive: archive })\n      });\n      return {\n        success: response.Success ?? response.success ?? false,\n        isArchived: response.IsArchived ?? response.isArchived ?? false,\n        errorMessage: response.ErrorMessage\n      };\n    } catch (error) {\n      return {\n        success: false,\n        isArchived: false,\n        errorMessage: error instanceof Error ? error.message : 'Failed to archive thread'\n      };\n    }\n  },\n\n  /**\n   * Forward a message\n   */\n  async forwardMessage(\n    messageId: string, \n    toApplicationId: string, \n    toReceiverId?: string, \n    additionalContent?: string\n  ): Promise<{ success: boolean; newMessageId?: string; newThreadId?: string; errorMessage?: string }> {\n    try {\n      const response = await request<{ \n        Success?: boolean; \n        NewMessageId?: string; \n        NewThreadId?: string;\n        success?: boolean;\n        newMessageId?: string;\n        newThreadId?: string;\n        ErrorMessage?: string;\n      }>(`/api/v1/messages/${encodeURIComponent(messageId)}/forward`, {\n        method: 'POST',\n        body: JSON.stringify({\n          ToApplicationId: toApplicationId,\n          ToReceiverId: toReceiverId,\n          AdditionalContent: additionalContent\n        })\n      });\n      return {\n        success: response.Success ?? response.success ?? false,\n        newMessageId: response.NewMessageId ?? response.newMessageId,\n        newThreadId: response.NewThreadId ?? response.newThreadId,\n        errorMessage: response.ErrorMessage\n      };\n    } catch (error) {\n      return {\n        success: false,\n        errorMessage: error instanceof Error ? error.message : 'Failed to forward message'\n      };\n    }\n  },\n};\n\nexport default messagingApi;\n","\"use client\";\n\nimport { \n  Box, \n  Container, \n  VStack, \n  HStack,\n  Textarea,\n  Icon,\n  Flex,\n  Spinner,\n  Avatar,\n} from \"@chakra-ui/react\";\nimport { Search, Typography, Button, Tag, IconWrapper, Modal, ModalHeader, ModalBody, ModalFooter, Input } from \"@/lib/mukuruImports\";\nimport { \n  FiSend, \n  FiPaperclip, \n  FiClock,\n  FiUser,\n  FiMessageSquare,\n  FiAlertCircle,\n  FiSearch,\n  FiFilter,\n  FiRefreshCw,\n  FiPlus,\n  FiCheck,\n  FiCheckCircle,\n  FiStar,\n  FiX,\n  FiTrash2,\n  FiCornerUpRight,\n  FiShare2,\n  FiArchive,\n  FiDownload,\n  FiFileText\n} from \"react-icons/fi\";\nimport { SweetAlert } from \"../../utils/sweetAlert\";\nimport { useState, useEffect, useRef } from \"react\";\nimport AdminSidebar from \"../../components/AdminSidebar\";\nimport { messagingApi, MessageDto, MessageThreadDto } from \"../../lib/messagingApi\";\nimport { signalRService } from \"../../lib/signalRService\";\nimport { pushNotificationService } from \"../../lib/pushNotifications\";\nimport { messageTemplatesService } from \"../../lib/messageTemplates\";\nimport { messageExportService } from \"../../lib/messageExport\";\nimport { uploadFileToDocumentService } from \"../../lib/documentUpload\";\nimport { logger } from \"../../lib/logger\";\nimport Link from \"next/link\";\n\ninterface DisplayMessage {\n  id: string;\n  sender: string;\n  senderType: 'ADMIN' | 'PARTNER' | 'CUSTOMER';\n  recipient?: string;\n  subject: string;\n  content: string;\n  timestamp: string;\n  applicationId: string;\n  attachments?: Array<{\n    id: string;\n    fileName: string;\n    contentType: string;\n    fileSizeBytes: number;\n    storageKey: string;\n    storageUrl: string;\n    documentId?: string;\n    description?: string;\n  }>;\n  isRead: boolean;\n  isStarred?: boolean;\n  priority: 'LOW' | 'MEDIUM' | 'HIGH';\n  threadId: string;\n  replyToMessageId?: string;\n}\n\nexport default function MessagesPage() {\n  const [threads, setThreads] = useState<MessageThreadDto[]>([]);\n  const [selectedThread, setSelectedThread] = useState<MessageThreadDto | null>(null);\n  const [messages, setMessages] = useState<DisplayMessage[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [loadingMessages, setLoadingMessages] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [filterType, setFilterType] = useState<string>(\"ALL\");\n  const [filterPriority, setFilterPriority] = useState<string>(\"ALL\");\n  const [filterArchived, setFilterArchived] = useState<boolean>(false);\n  const [filterStarred, setFilterStarred] = useState<boolean>(false);\n  const [messageSearchTerm, setMessageSearchTerm] = useState(\"\");\n  const [showCompose, setShowCompose] = useState(false);\n  const [newMessage, setNewMessage] = useState({\n    applicationId: \"\",\n    content: \"\",\n    receiverId: \"\"\n  });\n  const [sending, setSending] = useState(false);\n  const [sendSuccess, setSendSuccess] = useState(false);\n  const [isTyping, setIsTyping] = useState<{ [threadId: string]: { userName: string } }>({});\n  const [signalRConnected, setSignalRConnected] = useState(false);\n  const [replyingTo, setReplyingTo] = useState<DisplayMessage | null>(null);\n  const [forwardingMessage, setForwardingMessage] = useState<DisplayMessage | null>(null);\n  const [selectedAttachments, setSelectedAttachments] = useState<File[]>([]);\n  const [uploadingAttachments, setUploadingAttachments] = useState(false);\n  const [attachmentUploadProgress, setAttachmentUploadProgress] = useState<{ [fileName: string]: number }>({});\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  // Initialize SignalR connection\n  useEffect(() => {\n    const initSignalR = async () => {\n      try {\n        await signalRService.connect();\n        setSignalRConnected(true);\n\n        // Set up event listeners\n        const unsubscribeReceive = signalRService.on(\"ReceiveMessage\", async (message: any) => {\n          logger.debug('[Admin Messages] Received SignalR message', { messageId: message.id });\n          \n          // Show push notification for new messages\n          if (document.hidden || !selectedThread || message.threadId !== selectedThread.id) {\n            try {\n              await pushNotificationService.showMessageNotification(\n                message.senderName || 'Admin',\n                message.content || 'New message',\n                message.threadId\n              );\n            } catch (error) {\n              logger.error(error, '[Messages] Failed to show notification', {\n                tags: { error_type: 'notification_error' }\n              });\n            }\n          }\n          \n          // If message is for current thread, add it immediately\n          if (selectedThread && message.threadId === selectedThread.id) {\n            // Determine sender type more accurately\n            const senderNameLower = (message.senderName || '').toLowerCase();\n            const senderEmail = (message.senderEmail || message.senderId || '').toLowerCase();\n            \n            // Determine if message is from admin\n            const isFromAdmin = senderNameLower.includes('@mukuru.com') || \n                               senderEmail.includes('@mukuru.com') ||\n                               message.senderRole === 'Admin' || \n                               message.senderRole === 'ComplianceManager';\n            \n            const displayMessage: DisplayMessage = {\n              id: message.id,\n              sender: message.senderName,\n              senderType: isFromAdmin ? 'ADMIN' : 'PARTNER',\n              subject: getSubjectFromThread(selectedThread),\n              content: message.content,\n              timestamp: message.sentAt,\n              applicationId: message.applicationId || selectedThread.applicationId,\n              attachments: message.attachments || [],\n              isRead: false,\n              isStarred: false,\n              priority: determinePriority({ content: message.content } as MessageDto),\n              threadId: message.threadId\n            };\n            \n            setMessages(prev => {\n              // Check if message already exists (avoid duplicates)\n              if (prev.some(m => m.id === message.id)) {\n                return prev;\n              }\n              return [...prev, displayMessage].sort((a, b) => \n                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n              );\n            });\n            \n            // Scroll to bottom\n            setTimeout(() => {\n              if (messagesEndRef.current) {\n                messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n              }\n            }, 100);\n            \n            // Also reload messages from backend to ensure consistency and proper sender type\n            setTimeout(async () => {\n              try {\n                await loadThreadMessages(selectedThread.id);\n              } catch (error) {\n                logger.error(error, '[Admin Messages] Failed to reload messages after SignalR update', {\n                  tags: { error_type: 'messages_reload_error' }\n                });\n              }\n            }, 500);\n          }\n          \n          // Refresh threads to update last message and unread counts\n          loadThreads();\n          loadUnreadCount();\n        });\n\n        const unsubscribeSent = signalRService.on(\"MessageSent\", (message: any) => {\n          // Message was sent successfully via SignalR\n          if (selectedThread && message.threadId === selectedThread.id) {\n            loadThreadMessages(selectedThread.id);\n          }\n          loadThreads();\n          loadUnreadCount();\n        });\n\n        const unsubscribeTyping = signalRService.on(\"UserTyping\", (data: { userId: string; userName: string; threadId: string }) => {\n          if (selectedThread && data.threadId === selectedThread.id) {\n            setIsTyping(prev => ({ ...prev, [data.threadId]: { userName: data.userName } }));\n            \n            // Clear typing indicator after 3 seconds\n            if (typingTimeoutRef.current) {\n              clearTimeout(typingTimeoutRef.current);\n            }\n            typingTimeoutRef.current = setTimeout(() => {\n              setIsTyping(prev => {\n                const updated = { ...prev };\n                delete updated[data.threadId];\n                return updated;\n              });\n            }, 3000);\n          }\n        });\n\n        const unsubscribeRead = signalRService.on(\"MessageRead\", (messageId: string) => {\n          setMessages(prev => prev.map(msg => \n            msg.id === messageId ? { ...msg, isRead: true } : msg\n          ));\n        });\n\n        return () => {\n          unsubscribeReceive();\n          unsubscribeSent();\n          unsubscribeTyping();\n          unsubscribeRead();\n          signalRService.disconnect();\n        };\n      } catch (error) {\n        logger.error(error, '[Messages] Failed to connect SignalR', {\n          tags: { error_type: 'signalr_connection_error' }\n        });\n        setSignalRConnected(false);\n      }\n    };\n\n    initSignalR();\n  }, []);\n\n  // Join/leave thread when selection changes\n  useEffect(() => {\n    if (selectedThread && signalRConnected && selectedThread.id) {\n      // Validate threadId is a valid GUID before joining\n      const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n      if (guidRegex.test(selectedThread.id) && selectedThread.id !== '00000000-0000-0000-0000-000000000000') {\n        signalRService.joinThread(selectedThread.id).catch(error => {\n          logger.error(error, '[Messages] Failed to join thread', {\n            tags: { error_type: 'thread_join_error' }\n          });\n        });\n        return () => {\n          signalRService.leaveThread(selectedThread.id).catch(error => {\n            logger.error(error, '[Messages] Failed to leave thread', {\n              tags: { error_type: 'thread_leave_error' }\n            });\n          });\n        };\n      } else {\n        logger.warn('[Messages] Invalid thread ID, skipping join', {\n          tags: { warning_type: 'invalid_thread_id' },\n          extra: { threadId: selectedThread.id }\n        });\n      }\n    }\n  }, [selectedThread, signalRConnected]);\n\n  useEffect(() => {\n    // Diagnostic: Check identity (non-critical, failures are OK)\n    const checkIdentity = async () => {\n      try {\n        const response = await fetch('/api/proxy/messaging/api/v1/messages/diagnostic/identity');\n        if (response.ok) {\n          const identity = await response.json();\n          logger.debug('[Messages] Identity Diagnostic', { identity });\n        } else {\n          // Non-critical - endpoint might not be available in all environments\n          logger.warn('[Messages] Identity diagnostic endpoint returned non-OK status', {\n            tags: { warning_type: 'diagnostic_endpoint_error' },\n            extra: { status: response.status }\n          });\n        }\n      } catch (err) {\n        // Non-critical - just log and continue\n        logger.warn('[Messages] Failed to get identity (non-critical)', {\n          tags: { warning_type: 'identity_check_failed' },\n          extra: { error: err }\n        });\n      }\n    };\n    checkIdentity();\n    \n    loadThreads();\n    loadUnreadCount();\n  }, []);\n\n  // Fallback polling (only if SignalR is not connected)\n  useEffect(() => {\n    if (signalRConnected) return; // Don't poll if SignalR is connected\n    \n    const interval = setInterval(() => {\n      loadThreads();\n      loadUnreadCount();\n      // Refresh current thread messages if one is selected\n      if (selectedThread) {\n        loadThreadMessages(selectedThread.id);\n      }\n    }, 30000); // 30 seconds\n    \n    return () => clearInterval(interval);\n  }, [selectedThread, signalRConnected]);\n\n  useEffect(() => {\n    if (selectedThread && selectedThread.id) {\n      // Only load if we're not already loading to prevent loops\n      if (!loadingMessages) {\n        loadThreadMessages(selectedThread.id);\n      }\n      // Update newMessage with the current thread's applicationId\n      setNewMessage(prev => ({\n        ...prev,\n        applicationId: selectedThread.applicationId\n      }));\n    }\n  }, [selectedThread?.id]); // Only depend on thread ID to prevent unnecessary reloads\n\n  useEffect(() => {\n    // Auto-scroll to bottom when new messages arrive\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n    }\n  }, [messages]);\n\n  const loadThreads = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      logger.debug(\"[Messages] Loading threads...\");\n      // Use getAllThreads for admin to see all messages\n      let result;\n      try {\n        result = await messagingApi.getAllThreads(1, 100);\n        logger.debug(\"[Messages] Using getAllThreads - loaded all threads\");\n      } catch (allThreadsError) {\n        // Fallback to getMyThreads if getAllThreads fails (e.g., not admin)\n        logger.warn(\"[Messages] getAllThreads failed, falling back to getMyThreads\", {\n          tags: { warning_type: 'getallthreads_fallback' },\n          extra: { error: allThreadsError }\n        });\n        result = await messagingApi.getMyThreads(1, 100);\n      }\n      logger.debug(\"[Messages] Threads loaded\", {\n        totalCount: result.totalCount,\n        itemsCount: result.items?.length || 0\n      });\n      setThreads(result.items || []);\n      // Clear error if successful\n      if (result.items && result.items.length >= 0) {\n        setError(null);\n      }\n      // Log if no threads found\n      if (!result.items || result.items.length === 0) {\n        logger.warn(\"[Messages] No threads found\", {\n          tags: { warning_type: 'no_threads' },\n          extra: { totalCount: result.totalCount }\n        });\n      }\n    } catch (err) {\n      if (typeof window !== 'undefined') {\n        const { clientSentry } = await import('../../lib/sentry-client');\n        clientSentry.reportError(err, {\n          tags: { error_type: 'messages', operation: 'load_threads' },\n          level: 'error',\n        });\n      }\n      const errorMessage = err instanceof Error ? err.message : \"Failed to load messages\";\n      // Check if it's a connection error\n      if (errorMessage.includes('connect') || errorMessage.includes('unavailable') || errorMessage.includes('ECONNREFUSED')) {\n        setError(\"Cannot connect to messaging service. Please ensure the backend messaging service is running on port 8087.\");\n      } else {\n        setError(errorMessage);\n      }\n      setThreads([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const loadUnreadCount = async () => {\n    try {\n      const result = await messagingApi.getUnreadCount();\n      setUnreadCount(result.count || 0);\n    } catch (err) {\n      if (typeof window !== 'undefined') {\n        const { clientSentry } = await import('../../lib/sentry-client');\n        clientSentry.reportError(err, {\n          tags: { error_type: 'messages', operation: 'load_unread_count' },\n          level: 'warning',\n        });\n      }\n    }\n  };\n\n  const loadThreadMessages = async (threadId: string) => {\n    try {\n      setLoadingMessages(true);\n      const result = await messagingApi.getThreadMessages(threadId, 1, 100);\n      const displayMessages: DisplayMessage[] = (result.items || []).map((msg: MessageDto) => {\n        // Determine sender type based on email domain, name, and role\n        const senderNameLower = (msg.senderName || '').toLowerCase();\n        const senderIdLower = (msg.senderId || '').toLowerCase();\n        const senderRole = (msg.senderRole || '').trim();\n        const roleUpper = senderRole.toUpperCase();\n        \n        // Check email domain first (most reliable)\n        const hasMukuruEmail = senderNameLower.includes('@mukuru.com') || \n                              senderIdLower.includes('@mukuru.com');\n        const hasKurasikaEmail = senderNameLower.includes('@kurasika.com') || \n                                senderIdLower.includes('@kurasika.com');\n        \n        // Admin detection: check role first, then email domain, then name patterns\n        const adminNames = ['tendai gatahwa', 'tendai', 'admin', 'compliance', 'mukuru'];\n        const customerNames = ['alpha tembo', 'alpha', 'customer', 'applicant'];\n        \n        // Check if admin by name\n        const isAdminByName = adminNames.some(name => senderNameLower.includes(name));\n        \n        // Check if customer by name\n        const isCustomerByName = customerNames.some(name => senderNameLower.includes(name));\n        \n        // Determine if admin: check role first, then email domain, then name\n        const isAdmin = (senderRole === 'Admin' || \n                        senderRole === 'ComplianceManager' ||\n                        roleUpper === 'ADMIN' ||\n                        roleUpper === 'COMPLIANCEMANAGER' ||\n                        roleUpper.includes('ADMIN') || \n                        roleUpper.includes('COMPLIANCE')) ||\n                       hasMukuruEmail ||\n                       (isAdminByName && !isCustomerByName && !hasKurasikaEmail);\n        \n        // Determine sender type\n        let senderType: 'ADMIN' | 'PARTNER' | 'CUSTOMER';\n        if (isAdmin) {\n          senderType = 'ADMIN';\n        } else if (roleUpper.includes('PARTNER') || hasKurasikaEmail) {\n          senderType = 'PARTNER';\n        } else {\n          senderType = 'CUSTOMER';\n        }\n        \n        return {\n          id: msg.id,\n          sender: msg.senderName,\n          senderType: senderType,\n          recipient: msg.receiverName || undefined,\n          subject: getSubjectFromThread(selectedThread),\n          content: msg.content,\n          timestamp: msg.sentAt,\n          applicationId: selectedThread?.applicationId || \"\",\n          attachments: msg.attachments?.map(a => ({\n            id: a.id,\n            fileName: a.fileName,\n            contentType: a.contentType,\n            fileSizeBytes: a.fileSizeBytes,\n            storageKey: a.storageKey,\n            storageUrl: a.storageUrl,\n            documentId: a.documentId || undefined,\n            description: a.description || undefined,\n          })),\n          isRead: msg.isRead,\n          isStarred: msg.isStarred || false,\n          priority: determinePriority(msg),\n          threadId: msg.threadId,\n          replyToMessageId: msg.replyToMessageId || undefined,\n        };\n      });\n      // Sort messages by timestamp: oldest first (ascending order)\n      const sortedMessages = displayMessages.sort((a, b) => \n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n      );\n      setMessages(sortedMessages);\n      \n      // Mark unread messages as read (don't await to avoid blocking)\n      const unreadMessages = displayMessages.filter(m => !m.isRead);\n      if (unreadMessages.length > 0) {\n        // Mark as read in background without blocking\n        Promise.all(unreadMessages.map(msg => \n          messagingApi.markMessageRead(msg.id).catch(err => {\n            logger.warn(\"Failed to mark message as read\", {\n              tags: { warning_type: 'mark_read_failed' },\n              extra: { error: err }\n            });\n          })\n        )).then(() => {\n          // Only reload threads/unread count after a delay to avoid refresh loops\n          // Use a longer delay and check if component is still mounted\n          setTimeout(() => {\n            // Only reload if we're not currently loading messages (avoid loops)\n            if (!loadingMessages) {\n              loadThreads().catch((err) => {\n                if (typeof window !== 'undefined') {\n                  import('../../lib/sentry-client').then(({ clientSentry }) => {\n                    clientSentry.reportError(err, {\n                      tags: { error_type: 'messages', operation: 'load_threads' },\n                      level: 'error',\n                    });\n                  });\n                }\n              });\n              loadUnreadCount().catch((err) => {\n                if (typeof window !== 'undefined') {\n                  import('../../lib/sentry-client').then(({ clientSentry }) => {\n                    clientSentry.reportError(err, {\n                      tags: { error_type: 'messages', operation: 'load_unread_count' },\n                      level: 'warning',\n                    });\n                  });\n                }\n              });\n            }\n          }, 2000);\n        });\n      }\n    } catch (err) {\n      logger.error(err, \"Failed to load messages\", {\n        tags: { error_type: 'messages_load_error' }\n      });\n    } finally {\n      setLoadingMessages(false);\n    }\n  };\n\n  const mapSenderRole = (role: string, senderName?: string): 'ADMIN' | 'PARTNER' | 'CUSTOMER' => {\n    const upperRole = role.toUpperCase();\n    if (upperRole.includes('ADMIN')) return 'ADMIN';\n    if (upperRole.includes('PARTNER')) return 'PARTNER';\n    \n    // Check email domain to determine if admin or customer\n    if (senderName) {\n      const nameLower = senderName.toLowerCase();\n      if (nameLower.includes('@mukuru.com')) return 'ADMIN';\n      if (nameLower.includes('@kurasika.com')) return 'CUSTOMER';\n    }\n    \n    return 'CUSTOMER';\n  };\n\n  // Determine if message is from admin (for alignment)\n  // In admin view: admin messages go on the right, customer messages on the left\n  // NOTE: Backend is storing all messages with sender_role='Applicant', so we detect by name\n  const isFromAdmin = (message: DisplayMessage): boolean => {\n    if (!message.sender) return false;\n    \n    const senderLower = message.sender.toLowerCase();\n    \n    // Check senderType first (if backend ever fixes it)\n    if (message.senderType === 'ADMIN') {\n      return true;\n    }\n    \n    // Check for @mukuru.com email domain\n    if (senderLower.includes('@mukuru.com')) {\n      return true;\n    }\n    \n    // Check for known admin names (since backend role is broken)\n    // Admin names: Tendai Gatahwa, or any name that doesn't match customer patterns\n    const adminNames = ['tendai gatahwa', 'tendai', 'admin', 'compliance', 'mukuru'];\n    const customerNames = ['alpha tembo', 'alpha', 'customer', 'applicant'];\n    \n    // If it matches admin name patterns, it's admin\n    if (adminNames.some(name => senderLower.includes(name))) {\n      return true;\n    }\n    \n    // If it matches customer name patterns, it's NOT admin\n    if (customerNames.some(name => senderLower.includes(name))) {\n      return false;\n    }\n    \n    // Default: if senderType is CUSTOMER or senderRole was Applicant, assume customer\n    // Otherwise, if unclear, check if it's NOT a known customer name\n    if (message.senderType === 'CUSTOMER') {\n      return false;\n    }\n    \n    // Last resort: if name contains common admin indicators\n    return senderLower.includes('mukuru') || senderLower.includes('admin');\n  };\n\n  const getSubjectFromThread = (thread: MessageThreadDto | null): string => {\n    if (!thread) return \"No Subject\";\n    return `Application ${thread.applicationReference || thread.applicationId}`;\n  };\n\n  const determinePriority = (msg: MessageDto): 'LOW' | 'MEDIUM' | 'HIGH' => {\n    // Determine priority based on content or other factors\n    const content = msg.content.toLowerCase();\n    if (content.includes('urgent') || content.includes('asap') || content.includes('immediate')) {\n      return 'HIGH';\n    }\n    return 'MEDIUM';\n  };\n\n  const handleSendMessage = async () => {\n    if ((!newMessage.content.trim() && selectedAttachments.length === 0) || !selectedThread) {\n      await SweetAlert.warning(\"Message Required\", \"Please enter a message or attach a file\");\n      return;\n    }\n\n    try {\n      setSending(true);\n      setError(null);\n      \n      // Upload attachments first if any\n      let attachmentInfos: Array<{ fileName: string; contentType: string; fileSizeBytes: number; storageKey: string; storageUrl: string; documentId?: string; description?: string }> = [];\n      \n      if (selectedAttachments.length > 0) {\n        // Upload files to document service and get storage keys/URLs\n        setUploadingAttachments(true);\n        setAttachmentUploadProgress({});\n        \n        try {\n          attachmentInfos = await Promise.all(selectedAttachments.map(async (file, index) => {\n            try {\n              // Update progress\n              setAttachmentUploadProgress(prev => ({ ...prev, [file.name]: 50 }));\n              \n              const uploadResult = await uploadFileToDocumentService(\n                selectedThread.applicationId,\n                file,\n                `Message attachment: ${file.name}`,\n                undefined // Will be extracted from session\n              );\n              \n              // Mark as complete\n              setAttachmentUploadProgress(prev => ({ ...prev, [file.name]: 100 }));\n              \n              return {\n                fileName: file.name,\n                contentType: file.type || 'application/octet-stream',\n                fileSizeBytes: file.size,\n                storageKey: uploadResult.storageKey,\n                storageUrl: uploadResult.storageUrl || '',\n                documentId: uploadResult.documentId,\n                description: `Message attachment: ${file.name}`\n              };\n            } catch (error) {\n              logger.error(error, `Failed to upload attachment ${file.name}`, {\n                tags: { error_type: 'attachment_upload_error' },\n                extra: { fileName: file.name }\n              });\n              setAttachmentUploadProgress(prev => ({ ...prev, [file.name]: -1 })); // -1 indicates error\n              \n              // Ask user if they want to continue without this attachment\n              const shouldContinue = await SweetAlert.confirm(\n                \"Upload Failed\",\n                `Failed to upload \"${file.name}\". Do you want to continue sending the message without this attachment?`,\n                \"Continue Without It\",\n                \"Cancel\",\n                \"warning\"\n              );\n              \n              if (!shouldContinue.isConfirmed) {\n                throw new Error(\"User cancelled message send due to attachment upload failure\");\n              }\n              \n              // Continue with placeholder if user chooses to proceed\n              return {\n                fileName: file.name,\n                contentType: file.type || 'application/octet-stream',\n                fileSizeBytes: file.size,\n                storageKey: `messages/${selectedThread.applicationId}/${Date.now()}-${file.name}`,\n                storageUrl: '',\n                description: undefined\n              };\n            }\n          }));\n        } catch (error) {\n          logger.error(error, 'Error uploading attachments', {\n            tags: { error_type: 'attachments_upload_error' }\n          });\n          if (error instanceof Error && error.message.includes(\"User cancelled\")) {\n            setUploadingAttachments(false);\n            setAttachmentUploadProgress({});\n            return; // User cancelled, don't send message\n          }\n          await SweetAlert.warning(\"Upload Warning\", \"Some attachments failed to upload. The message will be sent without attachments.\");\n        } finally {\n          setUploadingAttachments(false);\n          setAttachmentUploadProgress({});\n        }\n      }\n      \n      logger.debug('Sending message', {\n        applicationId: selectedThread.applicationId,\n        content: newMessage.content.substring(0, 50) + '...',\n        receiverId: newMessage.receiverId || 'none',\n        replyToMessageId: replyingTo?.id,\n        attachmentsCount: attachmentInfos.length\n      });\n\n      const result = await messagingApi.sendMessage(\n        selectedThread.applicationId,\n        newMessage.content.trim(),\n        newMessage.receiverId || undefined,\n        replyingTo?.id,\n        attachmentInfos.length > 0 ? attachmentInfos : undefined\n      );\n\n      if (result.success) {\n        // Show success indicator\n        setSendSuccess(true);\n        setTimeout(() => setSendSuccess(false), 3000);\n        \n        // Clear the message input and attachments\n        setNewMessage({ applicationId: \"\", content: \"\", receiverId: \"\" });\n        setSelectedAttachments([]);\n        setReplyingTo(null);\n        if (fileInputRef.current) {\n          fileInputRef.current.value = '';\n        }\n        \n        // Wait a bit for SignalR to process, then reload messages to ensure proper sender type\n        setTimeout(async () => {\n          // Reload messages to show the new message with proper sender type\n          await loadThreadMessages(selectedThread.id);\n          \n          // Refresh threads list to update last message and unread counts\n          await loadThreads();\n          await loadUnreadCount();\n          \n          // Scroll to bottom to show new message\n          setTimeout(() => {\n            if (messagesEndRef.current) {\n              messagesEndRef.current.scrollIntoView({ behavior: \"smooth\" });\n            }\n          }, 100);\n        }, 500);\n      } else {\n        throw new Error(result.errorMessage || \"Failed to send message\");\n      }\n    } catch (err) {\n      logger.error(err, \"Failed to send message\", {\n        tags: { error_type: 'message_send_error' }\n      });\n      const errorMessage = err instanceof Error ? err.message : \"Failed to send message\";\n      setError(errorMessage);\n      await SweetAlert.error(\"Failed to Send\", errorMessage);\n    } finally {\n      setSending(false);\n    }\n  };\n\n  const handleComposeNew = () => {\n    setShowCompose(true);\n    setSelectedThread(null);\n    setMessages([]);\n  };\n\n  const filteredThreads = threads.filter(thread => {\n    const matchesSearch = \n      thread.applicantName.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      thread.applicationReference?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      thread.lastMessage?.content.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      thread.applicationId.toLowerCase().includes(searchTerm.toLowerCase());\n    \n    const matchesFilter = filterType === \"ALL\" || \n      (filterType === \"UNREAD\" && thread.unreadCount > 0) ||\n      (filterType === \"ACTIVE\" && thread.isActive);\n    \n    const matchesArchived = filterArchived ? thread.isArchived : !thread.isArchived;\n    const matchesStarred = filterStarred ? thread.isStarred : true;\n    \n    return matchesSearch && matchesFilter && matchesArchived && matchesStarred;\n  });\n\n  // Filter and sort messages: oldest at top, newest at bottom\n  const filteredMessages = messages\n    .filter(message => {\n      if (!messageSearchTerm) return true;\n      const search = messageSearchTerm.toLowerCase();\n      return (\n        message.content.toLowerCase().includes(search) ||\n        message.sender.toLowerCase().includes(search) ||\n        message.subject.toLowerCase().includes(search)\n      );\n    })\n    .sort((a, b) => {\n      // Sort by timestamp: oldest first (ascending order)\n      return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();\n    });\n\n  const getPriorityColor = (priority: string) => {\n    switch (priority) {\n      case 'HIGH': return 'red';\n      case 'MEDIUM': return 'orange';\n      case 'LOW': return 'green';\n      default: return 'gray';\n    }\n  };\n\n  const getSenderTypeColor = (type: string) => {\n    switch (type) {\n      case 'ADMIN': return 'blue';\n      case 'PARTNER': return 'green';\n      case 'CUSTOMER': return 'purple';\n      default: return 'gray';\n    }\n  };\n\n  if (loading) {\n    return (\n      <Box height=\"100vh\" overflow=\"hidden\" display=\"flex\">\n        <AdminSidebar />\n        <Box ml=\"240px\" p=\"8\" bg=\"gray.50\" h=\"100vh\" flex=\"1\" display=\"flex\" alignItems=\"center\" justifyContent=\"center\">\n          <Spinner size=\"xl\" color=\"orange.500\" />\n        </Box>\n      </Box>\n    );\n  }\n\n  return (\n    <Box height=\"100vh\" overflow=\"hidden\" display=\"flex\">\n      <AdminSidebar />\n      <Box ml=\"240px\" bg=\"gray.50\" h=\"100vh\" display=\"flex\" flexDirection=\"column\" overflow=\"hidden\" flex=\"1\">\n        <Container maxW=\"full\" flex=\"1\" display=\"flex\" flexDirection=\"column\" p=\"6\" overflow=\"hidden\" minH=\"0\">\n          <VStack gap=\"4\" align=\"stretch\" flex=\"1\" minH=\"0\" overflow=\"hidden\">\n            {/* Header */}\n            <Flex justify=\"space-between\" align=\"center\" flexShrink={0}>\n              <VStack align=\"start\" gap=\"1\">\n                <Typography fontSize=\"2xl\" fontWeight=\"bold\" color=\"gray.900\">\n                  Messages\n                </Typography>\n                <Typography fontSize=\"sm\" color=\"gray.600\">\n                  Communicate with partners and customers\n                </Typography>\n              </VStack>\n              \n              <HStack gap=\"3\">\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  disabled\n                >\n                  {unreadCount} Unread\n                </Button>\n                {signalRConnected ? (\n                  <Tag variant=\"success\">\n                     Live\n                  </Tag>\n                ) : (\n                  <Tag variant=\"inactive\">\n                    Offline\n                  </Tag>\n                )}\n                <Button\n                  variant=\"primary\"\n                  size=\"sm\"\n                  onClick={handleComposeNew}\n                >\n                  <IconWrapper><FiPlus size={16} /></IconWrapper>\n                  New Message\n                </Button>\n                <Button\n                  variant=\"secondary\"\n                  size=\"sm\"\n                  onClick={() => {\n                    loadThreads();\n                    loadUnreadCount();\n                    if (selectedThread) {\n                      loadThreadMessages(selectedThread.id);\n                    }\n                  }}\n                >\n                  <IconWrapper><FiRefreshCw size={16} /></IconWrapper>\n                  Refresh\n                </Button>\n              </HStack>\n            </Flex>\n\n            {/* Success Alert */}\n            {sendSuccess && (\n              <Box p=\"3\" bg=\"green.50\" borderRadius=\"md\" border=\"1px\" borderColor=\"green.200\" flexShrink={0}>\n                <HStack gap=\"2\">\n                  <IconWrapper><FiCheckCircle size={16} color=\"#38A169\" /></IconWrapper>\n                  <Typography fontSize=\"sm\" fontWeight=\"medium\" color=\"green.800\">Message sent successfully!</Typography>\n                </HStack>\n              </Box>\n            )}\n\n            {/* Error Alert */}\n            {error && (\n              <Box p=\"3\" bg=\"red.50\" borderRadius=\"md\" border=\"1px\" borderColor=\"red.200\" flexShrink={0}>\n                <HStack gap=\"2\" justify=\"space-between\" align=\"start\">\n                  <HStack gap=\"2\" flex=\"1\">\n                    <IconWrapper><FiAlertCircle size={16} color=\"#E53E3E\" /></IconWrapper>\n                    <VStack align=\"start\" gap=\"1\" flex=\"1\">\n                      <Typography fontSize=\"sm\" fontWeight=\"medium\" color=\"red.800\">Error loading messages</Typography>\n                      <Typography fontSize=\"xs\" color=\"red.700\">{error}</Typography>\n                    </VStack>\n                  </HStack>\n                  <Button\n                    size=\"sm\"\n                    variant=\"secondary\"\n                    onClick={() => {\n                      setError(null);\n                      loadThreads();\n                      loadUnreadCount();\n                    }}\n                  >\n                    Retry\n                  </Button>\n                </HStack>\n              </Box>\n            )}\n\n            {/* Main Content Area - Two Column Layout */}\n            <Flex gap=\"4\" flex=\"1\" minH=\"0\" align=\"stretch\" overflow=\"hidden\">\n              {/* Threads List - Left Panel */}\n              <Box width=\"380px\" bg=\"white\" borderRadius=\"lg\" boxShadow=\"sm\" border=\"1px\" borderColor=\"gray.200\" display=\"flex\" flexDirection=\"column\" overflow=\"hidden\" flexShrink={0}>\n                {/* Search and Filter */}\n                <Box p=\"3\" borderBottom=\"1px\" borderColor=\"gray.200\" bg=\"gray.50\" flexShrink={0}>\n                  <VStack gap=\"2\" align=\"stretch\">\n                    <Box flex=\"1\" maxW=\"300px\">\n                      <Search\n                        placeholder=\"Search messages...\"\n                        onSearchChange={(query) => setSearchTerm(query)}\n                      />\n                    </Box>\n                    <HStack gap=\"2\">\n                      <IconWrapper><FiFilter size={16} color=\"#A0AEC0\" /></IconWrapper>\n                       <select\n                         value={filterType}\n                         onChange={(e) => setFilterType(e.target.value)}\n                         style={{\n                           padding: \"6px 12px\",\n                           borderRadius: \"6px\",\n                           border: \"1px solid #E2E8F0\",\n                           backgroundColor: \"white\",\n                           fontSize: \"13px\",\n                           width: \"100%\",\n                           cursor: \"pointer\",\n                           color: \"#000000\"\n                         }}\n                       >\n                        <option value=\"ALL\">All Messages</option>\n                        <option value=\"UNREAD\">Unread</option>\n                        <option value=\"ACTIVE\">Active</option>\n                      </select>\n                    </HStack>\n                    <HStack gap=\"2\">\n                      <Button\n                        size=\"sm\"\n                        variant={filterArchived ? \"primary\" : \"secondary\"}\n                        onClick={() => setFilterArchived(!filterArchived)}\n                      >\n                        <IconWrapper><FiArchive size={14} /></IconWrapper>\n                        {filterArchived ? \"Show Archived\" : \"Hide Archived\"}\n                      </Button>\n                      <Button\n                        size=\"sm\"\n                        variant={filterStarred ? \"primary\" : \"secondary\"}\n                        onClick={() => setFilterStarred(!filterStarred)}\n                      >\n                        <IconWrapper><FiStar size={14} /></IconWrapper>\n                        Starred\n                      </Button>\n                    </HStack>\n                  </VStack>\n                </Box>\n                \n                {/* Threads List */}\n                <Box flex=\"1\" overflowY=\"auto\" minH=\"0\" p=\"2\">\n                  {filteredThreads.length === 0 && !loading ? (\n                    <Flex justify=\"center\" align=\"center\" height=\"100%\" minH=\"300px\">\n                      <VStack gap=\"3\">\n                        <IconWrapper><FiMessageSquare size={40} color=\"#CBD5E0\" /></IconWrapper>\n                        <Typography color=\"gray.500\" fontSize=\"sm\" fontWeight=\"medium\">No messages found</Typography>\n                        {searchTerm || filterType !== \"ALL\" ? (\n                          <Typography color=\"gray.400\" fontSize=\"xs\">Try adjusting your search or filter</Typography>\n                        ) : (\n                          <Typography color=\"gray.400\" fontSize=\"xs\">Messages will appear here when available</Typography>\n                        )}\n                      </VStack>\n                    </Flex>\n                  ) : filteredThreads.length === 0 && loading ? (\n                    <Flex justify=\"center\" align=\"center\" height=\"100%\" minH=\"300px\">\n                      <Spinner size=\"lg\" color=\"orange.500\" />\n                    </Flex>\n                  ) : (\n                    <VStack gap=\"2\" align=\"stretch\">\n                      {filteredThreads.map((thread) => (\n                        <Box\n                          key={thread.id}\n                          p=\"3\"\n                          borderRadius=\"md\"\n                          cursor=\"pointer\"\n                          bg={thread.id === selectedThread?.id ? \"orange.50\" : \"white\"}\n                          border=\"1px\"\n                          borderColor={thread.id === selectedThread?.id ? \"orange.200\" : \"gray.200\"}\n                          _hover={{ \n                            bg: thread.id === selectedThread?.id ? \"orange.50\" : \"gray.50\",\n                            borderColor: thread.id === selectedThread?.id ? \"orange.300\" : \"gray.300\"\n                          }}\n                          onClick={() => setSelectedThread(thread)}\n                          transition=\"all 0.2s\"\n                          position=\"relative\"\n                        >\n                          {thread.id === selectedThread?.id && (\n                            <Box\n                              position=\"absolute\"\n                              left=\"0\"\n                              top=\"0\"\n                              bottom=\"0\"\n                              width=\"3px\"\n                              bg=\"orange.500\"\n                              borderRadius=\"md\"\n                            />\n                          )}\n                          <VStack gap=\"2\" align=\"stretch\">\n                            <Flex justify=\"space-between\" align=\"start\">\n                              <HStack gap=\"2\" flex=\"1\" minW=\"0\">\n                                {thread.unreadCount > 0 && (\n                                  <Box\n                                    px=\"2\"\n                                    py=\"0.5\"\n                                    borderRadius=\"full\"\n                                    bg=\"orange.500\"\n                                    color=\"white\"\n                                    fontSize=\"2xs\"\n                                    fontWeight=\"bold\"\n                                    minW=\"20px\"\n                                    textAlign=\"center\"\n                                  >\n                                    {thread.unreadCount}\n                                  </Box>\n                                )}\n                                <Typography fontSize=\"xs\" fontWeight=\"semibold\" color=\"gray.700\" overflow=\"hidden\" textOverflow=\"ellipsis\" whiteSpace=\"nowrap\">\n                                  {thread.applicantName}\n                                </Typography>\n                              </HStack>\n                              <Typography fontSize=\"2xs\" color=\"gray.500\" flexShrink={0} ml=\"2\">\n                                {new Date(thread.lastMessageAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}\n                              </Typography>\n                            </Flex>\n                            \n                            {thread.lastMessage && (\n                              <Typography fontSize=\"xs\" color=\"gray.600\" lineHeight=\"1.4\" style={{\n                                display: \"-webkit-box\",\n                                WebkitLineClamp: 2,\n                                WebkitBoxOrient: \"vertical\",\n                                overflow: \"hidden\"\n                              }}>\n                                {thread.lastMessage.content}\n                              </Typography>\n                            )}\n                            \n                            <HStack gap=\"2\" fontSize=\"2xs\" color=\"gray.500\">\n                              <Tag variant=\"info\">\n                                {thread.applicationReference || thread.applicationId.substring(0, 8)}\n                              </Tag>\n                              <Typography></Typography>\n                              <Typography>{thread.messageCount} msgs</Typography>\n                            </HStack>\n                          </VStack>\n                        </Box>\n                      ))}\n                    </VStack>\n                  )}\n                </Box>\n              </Box>\n\n              {/* Message Details - Right Panel */}\n              <Box flex=\"1\" bg=\"white\" borderRadius=\"lg\" boxShadow=\"sm\" border=\"1px\" borderColor=\"gray.200\" display=\"flex\" flexDirection=\"column\" overflow=\"hidden\" minW=\"0\">\n                {selectedThread ? (\n                  <>\n                    {/* Thread Header */}\n                    <Box p=\"4\" borderBottom=\"1px\" borderColor=\"gray.200\" bg=\"gray.50\" flexShrink={0}>\n                      <VStack gap=\"2\" align=\"stretch\">\n                        <Flex justify=\"space-between\" align=\"start\">\n                          <VStack align=\"start\" gap=\"1\">\n                            <Typography fontSize=\"md\" fontWeight=\"semibold\" color=\"gray.900\">\n                              {getSubjectFromThread(selectedThread)}\n                            </Typography>\n                            <Typography fontSize=\"sm\" color=\"gray.600\">\n                              {selectedThread.applicantName}\n                            </Typography>\n                          </VStack>\n                          <Link href={`/applications/${selectedThread.applicationId}`}>\n                            <Button size=\"sm\" variant=\"secondary\">\n                              View Application\n                            </Button>\n                          </Link>\n                        </Flex>\n                        \n                        <HStack gap=\"4\" fontSize=\"xs\" color=\"gray.600\">\n                          <HStack gap=\"1\">\n                            <IconWrapper><FiUser size={12} /></IconWrapper>\n                            <Typography>Assigned: {selectedThread.assignedAdminName || \"Unassigned\"}</Typography>\n                          </HStack>\n                          <HStack gap=\"1\">\n                            <IconWrapper><FiMessageSquare size={12} /></IconWrapper>\n                            <Typography>{selectedThread.messageCount} messages</Typography>\n                          </HStack>\n                        </HStack>\n                      </VStack>\n                    </Box>\n\n                    {/* Messages List */}\n                    <Box flex=\"1\" overflowY=\"auto\" p=\"4\" bg=\"gray.50\" minH=\"0\" display=\"flex\" flexDirection=\"column\">\n                      {/* Message Search */}\n                      {messages.length > 0 && (\n                        <Box mb=\"3\" flexShrink={0}>\n                          <Box flex=\"1\" maxW=\"300px\">\n                            <Search\n                              placeholder=\"Search messages in thread...\"\n                              onSearchChange={(query) => setMessageSearchTerm(query)}\n                            />\n                          </Box>\n                        </Box>\n                      )}\n                      {loadingMessages ? (\n                        <Flex justify=\"center\" align=\"center\" h=\"200px\">\n                          <Spinner size=\"md\" color=\"orange.500\" />\n                        </Flex>\n                      ) : filteredMessages.length === 0 ? (\n                        <Flex justify=\"center\" align=\"center\" height=\"100%\" minH=\"300px\">\n                          <VStack gap=\"3\">\n                            <IconWrapper><FiMessageSquare size={40} color=\"#CBD5E0\" /></IconWrapper>\n                            <Typography color=\"gray.500\" fontSize=\"sm\" fontWeight=\"medium\">\n                              {messageSearchTerm ? \"No messages match your search\" : \"No messages in this thread\"}\n                            </Typography>\n                            {messageSearchTerm && (\n                              <Button\n                                size=\"sm\"\n                                variant=\"ghost\"\n                                onClick={() => setMessageSearchTerm(\"\")}\n                              >\n                                Clear Search\n                              </Button>\n                            )}\n                          </VStack>\n                        </Flex>\n                      ) : (\n                      <VStack gap=\"3\" align=\"stretch\">\n                        {filteredMessages.map((message) => {\n                          const isAdmin = isFromAdmin(message);\n                          // Debug logging\n                          if (filteredMessages.indexOf(message) < 2) {\n                            logger.debug('[Messages] Rendering message', {\n                              sender: message.sender,\n                              senderType: message.senderType,\n                              isAdmin,\n                              willAlignRight: isAdmin\n                            });\n                          }\n                          return (\n                            <Flex\n                              key={message.id}\n                              justify={isAdmin ? \"flex-end\" : \"flex-start\"}\n                              align=\"flex-start\"\n                              gap=\"2\"\n                              px=\"2\"\n                            >\n                              {!isAdmin && (\n                                <Avatar.Root size=\"sm\">\n                                  <Avatar.Fallback bg=\"blue.500\">\n                                    {message.sender.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase()}\n                                  </Avatar.Fallback>\n                                </Avatar.Root>\n                              )}\n                              <Box\n                                maxW=\"70%\"\n                                p=\"3\"\n                                bg={isAdmin ? \"orange.500\" : \"white\"}\n                                color={isAdmin ? \"white\" : \"gray.800\"}\n                                borderRadius=\"lg\"\n                                boxShadow=\"sm\"\n                                border={isAdmin ? \"none\" : \"1px\"}\n                                borderColor={isAdmin ? \"transparent\" : \"gray.200\"}\n                                position=\"relative\"\n                              >\n                                <VStack gap=\"1.5\" align=\"stretch\">\n                                  <Flex justify=\"space-between\" align=\"center\" gap=\"2\">\n                                    <Typography fontSize=\"xs\" fontWeight=\"semibold\" color={isAdmin ? \"white\" : \"gray.800\"}>\n                                      {message.sender.split(',')[0].trim()}\n                                    </Typography>\n                                    <Typography fontSize=\"2xs\" color={isAdmin ? \"orange.100\" : \"gray.500\"}>\n                                      {new Date(message.timestamp).toLocaleString('en-US', {\n                                        month: 'short',\n                                        day: 'numeric',\n                                        hour: 'numeric',\n                                        minute: '2-digit'\n                                      })}\n                                    </Typography>\n                                  </Flex>\n                                  \n                                  <Typography fontSize=\"sm\" whiteSpace=\"pre-wrap\" lineHeight=\"1.5\" color={isAdmin ? \"white\" : \"gray.700\"}>\n                                    {message.content}\n                                  </Typography>\n                              \n                                  {message.attachments && message.attachments.length > 0 && (\n                                    <Box mt=\"2\" p=\"2\" bg={isAdmin ? \"orange.600\" : \"blue.50\"} borderRadius=\"md\" border={isAdmin ? \"none\" : \"1px\"} borderColor={isAdmin ? \"transparent\" : \"blue.100\"}>\n                                      <VStack gap=\"2\" align=\"stretch\">\n                                        {message.attachments.map((attachment, idx) => (\n                                          <HStack key={idx} gap=\"2\" justify=\"space-between\">\n                                            <HStack gap=\"2\" flex=\"1\" minW=\"0\">\n                                              <IconWrapper><FiPaperclip size={12} color={isAdmin ? \"white\" : \"#3182CE\"} /></IconWrapper>\n                                              <VStack align=\"start\" gap=\"0\" flex=\"1\" minW=\"0\">\n                                                <Typography fontSize=\"2xs\" color={isAdmin ? \"white\" : \"blue.700\"} fontWeight=\"medium\" overflow=\"hidden\" textOverflow=\"ellipsis\" whiteSpace=\"nowrap\">\n                                                  {attachment.fileName || `Attachment ${idx + 1}`}\n                                                </Typography>\n                                                <Typography fontSize=\"2xs\" color={isAdmin ? \"orange.100\" : \"blue.600\"}>\n                                                  {(attachment.fileSizeBytes / 1024).toFixed(1)} KB\n                                                </Typography>\n                                              </VStack>\n                                            </HStack>\n                                            {(attachment.storageUrl || attachment.storageKey) && (\n                                              <Button\n                                                size=\"sm\"\n                                                variant={isAdmin ? \"primary\" : \"secondary\"}\n                                                onClick={async () => {\n                                                  try {\n                                                    let downloadUrl = attachment.storageUrl;\n                                                    \n                                                    // If no storageUrl, generate one from storageKey\n                                                    if (!downloadUrl && attachment.storageKey) {\n                                                      try {\n                                                        const response = await fetch(`/api/proxy/api/v1/documents/download/${encodeURIComponent(attachment.storageKey)}`);\n                                                        if (response.ok) {\n                                                          const result = await response.json();\n                                                          downloadUrl = result.url || result.downloadUrl || '';\n                                                        }\n                                                      } catch (error) {\n                                                        logger.error(error, 'Failed to get download URL', {\n                                                          tags: { error_type: 'download_url_error' }\n                                                        });\n                                                      }\n                                                    }\n                                                    \n                                                    // If we have documentId, try to get download URL from document service\n                                                    if (!downloadUrl && attachment.documentId) {\n                                                      try {\n                                                        const response = await fetch(`/api/proxy/api/v1/documents/${attachment.documentId}/download`);\n                                                        if (response.ok) {\n                                                          const result = await response.json();\n                                                          downloadUrl = result.url || result.downloadUrl || '';\n                                                        }\n                                                      } catch (error) {\n                                                        logger.error(error, 'Failed to get document download URL', {\n                                                          tags: { error_type: 'document_download_url_error' }\n                                                        });\n                                                      }\n                                                    }\n                                                    \n                                                    if (downloadUrl) {\n                                                      window.open(downloadUrl, '_blank');\n                                                    } else {\n                                                      await SweetAlert.warning(\"Download Unavailable\", \"Download URL is not available for this attachment.\");\n                                                    }\n                                                  } catch (error) {\n                                                    logger.error(error, 'Error downloading attachment', {\n                                                      tags: { error_type: 'attachment_download_error' }\n                                                    });\n                                                    await SweetAlert.error(\"Download Failed\", \"Failed to download attachment. Please try again.\");\n                                                  }\n                                                }}\n                                                flexShrink={0}\n                                              >\n                                                <IconWrapper><FiDownload size={12} /></IconWrapper>\n                                                <Typography ml=\"1\">Download</Typography>\n                                              </Button>\n                                            )}\n                                          </HStack>\n                                        ))}\n                                      </VStack>\n                                    </Box>\n                                  )}\n                                  \n                                  {/* Reply context */}\n                                  {message.replyToMessageId && (\n                                    <Box mt=\"2\" p=\"2\" bg={isAdmin ? \"orange.600\" : \"gray.100\"} borderRadius=\"md\" borderLeft={isAdmin ? \"none\" : \"3px\"} borderColor={isAdmin ? \"transparent\" : \"blue.400\"}>\n                                      <Typography fontSize=\"2xs\" color={isAdmin ? \"orange.100\" : \"gray.600\"} fontStyle=\"italic\" style={{\n                                        display: \"-webkit-box\",\n                                        WebkitLineClamp: 2,\n                                        WebkitBoxOrient: \"vertical\",\n                                        overflow: \"hidden\"\n                                      }}>\n                                        Replying to: {messages.find(m => m.id === message.replyToMessageId)?.content.substring(0, 100) || 'Previous message'}\n                                      </Typography>\n                                    </Box>\n                                  )}\n                                  \n                                  {/* Message actions */}\n                                  <HStack gap=\"1\" mt=\"2\" justify=\"flex-end\">\n                                              <Button\n                                                size=\"icon\"\n                                                variant=\"ghost\"\n                                                onClick={() => setReplyingTo(message)}\n                                                title=\"Reply\"\n                                              >\n                                                <IconWrapper><FiCornerUpRight size={14} /></IconWrapper>\n                                              </Button>\n                                              <Button\n                                                size=\"icon\"\n                                                variant=\"ghost\"\n                                                onClick={() => setForwardingMessage(message)}\n                                                title=\"Forward\"\n                                              >\n                                                <IconWrapper><FiShare2 size={14} /></IconWrapper>\n                                              </Button>\n                                              <Button\n                                                size=\"icon\"\n                                                variant=\"ghost\"\n                                      onClick={async () => {\n                                        try {\n                                          const result = await messagingApi.starMessage(message.id);\n                                          if (result.success) {\n                                            // Refresh messages to show updated star status\n                                            if (selectedThread) {\n                                              await loadThreadMessages(selectedThread.id);\n                                            }\n                                          }\n                                        } catch (error) {\n                                          logger.error(error, 'Failed to star message', {\n                                            tags: { error_type: 'star_message_error' }\n                                          });\n                                        }\n                                      }}\n                                      title={message.isStarred ? \"Unstar\" : \"Star\"}\n                                    >\n                                      <IconWrapper><FiStar size={14} color={message.isStarred ? \"#ECC94B\" : (isAdmin ? \"white\" : \"#A0AEC0\")} /></IconWrapper>\n                                    </Button>\n                                    <Button\n                                      size=\"icon\"\n                                      variant=\"ghost\"\n                                      onClick={async () => {\n                                        const result = await SweetAlert.confirm(\n                                          'Delete Message',\n                                          'Are you sure you want to delete this message? This action cannot be undone.',\n                                          'Yes, delete it!',\n                                          'Cancel',\n                                          'warning'\n                                        );\n                                        \n                                        if (!result.isConfirmed) return;\n                                        \n                                        try {\n                                          SweetAlert.loading('Deleting...', 'Please wait while we delete the message.');\n                                          const deleteResult = await messagingApi.deleteMessage(message.id);\n                                          if (deleteResult.success) {\n                                            // Remove message from list\n                                            setMessages(prev => prev.filter(m => m.id !== message.id));\n                                            // Refresh threads\n                                            await loadThreads();\n                                            SweetAlert.close();\n                                            await SweetAlert.success('Deleted!', 'Message has been deleted successfully.');\n                                          } else {\n                                            SweetAlert.close();\n                                            await SweetAlert.error('Delete Failed', deleteResult.errorMessage || 'Failed to delete message');\n                                          }\n                                        } catch (error) {\n                                          logger.error(error, 'Failed to delete message', {\n                                            tags: { error_type: 'delete_message_error' }\n                                          });\n                                          SweetAlert.close();\n                                          await SweetAlert.error('Delete Failed', 'Failed to delete message. Please try again.');\n                                        }\n                                      }}\n                                      title=\"Delete\"\n                                    >\n                                      <IconWrapper><FiTrash2 size={16} /></IconWrapper>\n                                    </Button>\n                                  </HStack>\n                                </VStack>\n                              </Box>\n                              {isAdmin && (\n                                <Avatar.Root size=\"sm\">\n                                  <Avatar.Fallback bg=\"orange.500\">\n                                    {message.sender.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase()}\n                                  </Avatar.Fallback>\n                                </Avatar.Root>\n                              )}\n                            </Flex>\n                          );\n                        })}\n                        <div ref={messagesEndRef} />\n                      </VStack>\n                    )}\n                  </Box>\n\n                    {/* Reply Section */}\n                    <Box p=\"3\" borderTop=\"1px\" borderColor=\"gray.200\" bg=\"white\" flexShrink={0}>\n                      <VStack gap=\"2\" align=\"stretch\">\n                        {/* Reply context */}\n                        {replyingTo && (\n                          <Box p=\"2\" bg=\"blue.50\" borderRadius=\"md\" borderLeft=\"3px\" borderColor=\"blue.400\">\n                            <HStack justify=\"space-between\">\n                              <VStack align=\"start\" gap=\"0\" flex=\"1\" minW=\"0\">\n                                <Typography fontSize=\"2xs\" fontWeight=\"semibold\" color=\"blue.800\">\n                                  Replying to {replyingTo.sender}\n                                </Typography>\n                                <Typography fontSize=\"2xs\" color=\"blue.600\" overflow=\"hidden\" textOverflow=\"ellipsis\" whiteSpace=\"nowrap\">\n                                  {replyingTo.content.substring(0, 100)}\n                                </Typography>\n                              </VStack>\n                              <Button\n                                size=\"icon\"\n                                variant=\"ghost\"\n                                onClick={() => setReplyingTo(null)}\n                              >\n                                <IconWrapper><FiX size={12} /></IconWrapper>\n                              </Button>\n                            </HStack>\n                          </Box>\n                        )}\n                        \n                        <Textarea\n                          placeholder={replyingTo ? `Reply to ${replyingTo.sender}...` : \"Type your message...\"}\n                          value={newMessage.content}\n                          onChange={(e) => {\n                            setNewMessage(prev => ({ ...prev, content: e.target.value }));\n                            // Send typing indicator\n                            if (selectedThread && signalRConnected && e.target.value.length > 0) {\n                              signalRService.sendTypingIndicator(selectedThread.id);\n                            }\n                          }}\n                          onKeyDown={(e) => {\n                            if (e.key === 'Enter' && !e.shiftKey) {\n                              e.preventDefault();\n                              handleSendMessage();\n                            }\n                          }}\n                          size=\"sm\"\n                          rows={3}\n                          resize=\"none\"\n                          fontSize=\"sm\"\n                          color=\"black\"\n                          _focus={{ color: \"black\" }}\n                          _placeholder={{ color: \"gray.400\" }}\n                        />\n                      \n                        {/* Selected attachments */}\n                        {selectedAttachments.length > 0 && (\n                          <VStack gap=\"1.5\" align=\"stretch\">\n                            {selectedAttachments.map((file, idx) => {\n                              const progress = attachmentUploadProgress[file.name];\n                              const hasError = progress === -1;\n                              const isUploading = progress !== undefined && progress > 0 && progress < 100;\n                              \n                              return (\n                                <HStack key={idx} p=\"2\" bg={hasError ? \"red.50\" : \"gray.50\"} borderRadius=\"md\" justify=\"space-between\" border={hasError ? \"1px\" : \"none\"} borderColor={hasError ? \"red.200\" : \"transparent\"}>\n                                  <HStack gap=\"2\" flex=\"1\" minW=\"0\">\n                                    <IconWrapper><FiPaperclip size={12} color={hasError ? \"#E53E3E\" : \"#718096\"} /></IconWrapper>\n                                    <VStack align=\"start\" gap=\"0\" flex=\"1\" minW=\"0\">\n                                      <Typography fontSize=\"xs\" fontWeight=\"medium\" overflow=\"hidden\" textOverflow=\"ellipsis\" whiteSpace=\"nowrap\" color={hasError ? \"red.700\" : \"gray.800\"}>\n                                        {file.name}\n                                      </Typography>\n                                      <HStack gap=\"2\" align=\"center\">\n                                        <Typography fontSize=\"2xs\" color={hasError ? \"red.600\" : \"gray.500\"}>\n                                          {(file.size / 1024).toFixed(1)} KB\n                                        </Typography>\n                                        {isUploading && (\n                                          <Typography fontSize=\"2xs\" color=\"blue.600\">\n                                            {progress}%\n                                          </Typography>\n                                        )}\n                                        {hasError && (\n                                          <Typography fontSize=\"2xs\" color=\"red.600\" fontWeight=\"medium\">\n                                            Upload failed\n                                          </Typography>\n                                        )}\n                                      </HStack>\n                                    </VStack>\n                                  </HStack>\n                                  <Button\n                                    size=\"icon\"\n                                    variant=\"ghost\"\n                                    onClick={() => {\n                                      setSelectedAttachments(prev => prev.filter((_, i) => i !== idx));\n                                      setAttachmentUploadProgress(prev => {\n                                        const updated = { ...prev };\n                                        delete updated[file.name];\n                                        return updated;\n                                      });\n                                    }}\n                                  >\n                                    <IconWrapper><FiX size={12} /></IconWrapper>\n                                  </Button>\n                                </HStack>\n                              );\n                            })}\n                          </VStack>\n                        )}\n                        \n                        {/* Typing indicator */}\n                        {selectedThread && isTyping[selectedThread.id] && (\n                          <Typography fontSize=\"2xs\" color=\"gray.500\" fontStyle=\"italic\">\n                            {isTyping[selectedThread.id].userName} is typing...\n                                    </Typography>\n                        )}\n                        \n                        <HStack justify=\"space-between\" gap=\"2\">\n                          <HStack gap=\"2\" flex=\"1\">\n                            <input\n                              ref={fileInputRef}\n                              type=\"file\"\n                              multiple\n                              style={{ display: 'none' }}\n                              onChange={(e) => {\n                                const files = Array.from(e.target.files || []);\n                                setSelectedAttachments(prev => [...prev, ...files]);\n                              }}\n                            />\n                            <Button\n                              variant=\"secondary\"\n                              size=\"sm\"\n                              onClick={() => fileInputRef.current?.click()}\n                            >\n                              <IconWrapper><FiPaperclip size={12} /></IconWrapper>\n                              <Typography>Attach</Typography>\n                            </Button>\n                            {selectedThread && (\n                              <Button\n                                variant=\"secondary\"\n                                size=\"sm\"\n                                onClick={async () => {\n                                  try {\n                                    const result = await messagingApi.archiveThread(selectedThread.id, !selectedThread.isArchived);\n                                    if (result.success) {\n                                      await loadThreads();\n                                      if (result.isArchived) {\n                                        setSelectedThread(null);\n                                      }\n                                    }\n                                  } catch (error) {\n                                    logger.error(error, 'Failed to archive thread', {\n                                      tags: { error_type: 'archive_thread_error' }\n                                    });\n                                    await SweetAlert.error('Archive Failed', 'Failed to archive thread. Please try again.');\n                                  }\n                                }}\n                                fontSize=\"xs\"\n                              >\n                                <IconWrapper><FiArchive size={12} /></IconWrapper>\n                                <Typography ml=\"1.5\">{selectedThread.isArchived ? \"Unarchive\" : \"Archive\"}</Typography>\n                              </Button>\n                            )}\n                          </HStack>\n                          \n                          <Button\n                            variant=\"primary\"\n                            size=\"sm\"\n                            onClick={handleSendMessage}\n                            disabled={sending || uploadingAttachments}\n                          >\n                            <HStack gap=\"1.5\">\n                              {(sending || uploadingAttachments) ? <Spinner size=\"xs\" /> : <IconWrapper><FiSend size={12} /></IconWrapper>}\n                              <Typography>\n                                {uploadingAttachments ? \"Uploading...\" : sending ? \"Sending...\" : \"Send\"}\n                              </Typography>\n                            </HStack>\n                          </Button>\n                        </HStack>\n                      </VStack>\n                    </Box>\n                </>\n                  ) : showCompose ? (\n                    <Flex justify=\"center\" align=\"center\" height=\"100%\">\n                      <VStack gap=\"4\" p=\"8\">\n                        <Typography fontSize=\"md\" fontWeight=\"semibold\" color=\"gray.800\">\n                          Compose New Message\n                                    </Typography>\n                        <Typography fontSize=\"sm\" color=\"gray.600\" textAlign=\"center\">\n                          To send a message, please select a thread or navigate to an application to start a conversation.\n                                    </Typography>\n                        <Button\n                          variant=\"secondary\"\n                          size=\"sm\"\n                          onClick={() => setShowCompose(false)}\n                        >\n                          Cancel\n                        </Button>\n                      </VStack>\n                    </Flex>\n                  ) : (\n                    <Flex justify=\"center\" align=\"center\" height=\"100%\">\n                      <VStack gap=\"3\">\n                        <IconWrapper><FiMessageSquare size={40} color=\"#CBD5E0\" /></IconWrapper>\n                        <Typography fontSize=\"sm\" color=\"gray.500\" fontWeight=\"medium\">\n                          Select a message to view details\n                                    </Typography>\n                      </VStack>\n                    </Flex>\n                  )}\n                </Box>\n              </Flex>\n            </VStack>\n          </Container>\n        </Box>\n\n      {/* Forward Message Modal */}\n      <Modal\n        isOpen={!!forwardingMessage}\n        onClose={() => {\n          setForwardingMessage(null);\n          setNewMessage({ applicationId: \"\", content: \"\", receiverId: \"\" });\n        }}\n        title=\"Forward Message\"\n        size=\"large\"\n        closeOnBackdropClick={true}\n        closeOnEsc={true}\n      >\n        <ModalHeader>\n          <Typography fontSize=\"lg\" fontWeight=\"semibold\" color=\"gray.800\">\n            Forward Message\n          </Typography>\n        </ModalHeader>\n        <ModalBody>\n          <VStack gap=\"4\" align=\"stretch\">\n            <Box p=\"3\" bg=\"gray.50\" borderRadius=\"md\" borderLeft=\"3px\" borderColor=\"blue.400\">\n              <Typography fontSize=\"sm\" fontWeight=\"medium\" color=\"gray.700\" mb=\"2\">\n                Original Message:\n              </Typography>\n              <Typography fontSize=\"sm\" color=\"gray.600\" mb=\"1\">\n                From: {forwardingMessage?.sender}\n              </Typography>\n              <Typography fontSize=\"sm\" color=\"gray.600\" whiteSpace=\"pre-wrap\">\n                {forwardingMessage?.content}\n              </Typography>\n            </Box>\n\n            <VStack gap=\"3\" align=\"stretch\">\n              <Box>\n                <Typography fontSize=\"sm\" fontWeight=\"medium\" color=\"gray.700\" mb=\"2\">\n                  To Application ID:\n                </Typography>\n                <Input\n                  placeholder=\"Enter application ID (GUID)\"\n                  value={newMessage.receiverId || \"\"}\n                  onChange={(e) => setNewMessage(prev => ({ ...prev, receiverId: e.target.value }))}\n                />\n              </Box>\n\n              <Box>\n                <Typography fontSize=\"sm\" fontWeight=\"medium\" color=\"gray.700\" mb=\"2\">\n                  Additional Message (Optional):\n                </Typography>\n                <Textarea\n                  placeholder=\"Add any additional context...\"\n                  value={newMessage.content}\n                  onChange={(e) => setNewMessage(prev => ({ ...prev, content: e.target.value }))}\n                  rows={4}\n                />\n              </Box>\n            </VStack>\n          </VStack>\n        </ModalBody>\n        <ModalFooter>\n          <HStack justify=\"flex-end\" gap=\"3\" w=\"full\">\n            <Button\n              variant=\"secondary\"\n              onClick={() => {\n                setForwardingMessage(null);\n                setNewMessage({ applicationId: \"\", content: \"\", receiverId: \"\" });\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"primary\"\n              onClick={async () => {\n                if (!newMessage.receiverId?.trim()) {\n                  await SweetAlert.warning(\"Application ID Required\", \"Please enter an application ID to forward to\");\n                  return;\n                }\n\n                try {\n                  setSending(true);\n                  const result = await messagingApi.forwardMessage(\n                    forwardingMessage!.id,\n                    newMessage.receiverId.trim(),\n                    undefined,\n                    newMessage.content.trim() || undefined\n                  );\n\n                  if (result.success) {\n                    await SweetAlert.success(\"Message Forwarded\", \"The message has been forwarded successfully.\");\n                    setForwardingMessage(null);\n                    setNewMessage({ applicationId: \"\", content: \"\", receiverId: \"\" });\n                    await loadThreads();\n                  } else {\n                    throw new Error(result.errorMessage || \"Failed to forward message\");\n                  }\n                } catch (error) {\n                  logger.error(error, \"Failed to forward message\", {\n                    tags: { error_type: 'forward_message_error' }\n                  });\n                  await SweetAlert.error(\"Forward Failed\", error instanceof Error ? error.message : \"Failed to forward message\");\n                } finally {\n                  setSending(false);\n                }\n              }}\n              disabled={sending}\n            >\n              {sending ? <Spinner size=\"sm\" /> : <IconWrapper><FiShare2 size={16} /></IconWrapper>}\n              <Typography ml=\"2\">{sending ? \"Forwarding...\" : \"Forward\"}</Typography>\n            </Button>\n          </HStack>\n        </ModalFooter>\n      </Modal>\n    </Box>\n  );\n}\n","export const VERSION = '9.0.6';","import * as signalR from \"@microsoft/signalr\";\n\nclass SignalRService {\n  private connection: signalR.HubConnection | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private listeners: Map<string, Set<(data: any) => void>> = new Map();\n\n  async connect(): Promise<void> {\n    if (this.connection?.state === signalR.HubConnectionState.Connected) {\n      return;\n    }\n\n    try {\n      // Get user info from session\n      let userEmail = \"\";\n      let userName = \"\";\n      let userRole = \"Administrator\";\n      let userId = \"\";\n\n      if (typeof window !== 'undefined') {\n        try {\n          const response = await fetch('/api/auth/session');\n          const session = await response.json();\n          userEmail = session?.user?.email || \"\";\n          userName = session?.user?.name || userEmail;\n          userRole = session?.user?.role || session?.user?.roles?.[0] || 'Administrator';\n          \n          // Generate user ID from email (consistent with backend)\n          if (userEmail) {\n            userId = this.generateUserIdFromEmail(userEmail);\n          }\n        } catch (error) {\n          console.warn('[SignalR] Failed to get session:', error);\n        }\n      }\n\n      // Build connection URL through proxy\n      const hubUrl = `/api/proxy/messaging/messageHub`;\n      \n      this.connection = new signalR.HubConnectionBuilder()\n        .withUrl(hubUrl, {\n          // Tokens are handled server-side by proxy - no need for accessTokenFactory\n          // The proxy will inject the Authorization header from Redis\n          accessTokenFactory: async () => {\n            // Return empty - proxy handles authentication\n            return \"\";\n          },\n          headers: {\n            'X-User-Email': userEmail,\n            'X-User-Name': userName,\n            'X-User-Role': userRole,\n            'X-User-Id': userId\n          }\n        })\n        .withAutomaticReconnect({\n          nextRetryDelayInMilliseconds: (retryContext) => {\n            if (retryContext.previousRetryCount < this.maxReconnectAttempts) {\n              return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 30000);\n            }\n            return null; // Stop reconnecting\n          }\n        })\n        .configureLogging(signalR.LogLevel.Information)\n        .build();\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      // Start connection\n      await this.connection.start();\n      console.log('[SignalR] Connected to messaging hub');\n\n      // Note: JoinThread should only be called with a valid threadId when a thread is selected\n      // Don't call it here with userId - that was incorrect\n\n      this.reconnectAttempts = 0;\n    } catch (error) {\n      console.error('[SignalR] Connection error:', error);\n      this.reconnectAttempts++;\n      throw error;\n    }\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.connection) return;\n\n    // Handle new messages\n    this.connection.on(\"ReceiveMessage\", (message: any) => {\n      console.log('[SignalR] Received message:', message);\n      this.notifyListeners(\"ReceiveMessage\", message);\n    });\n\n    // Handle message sent confirmation\n    this.connection.on(\"MessageSent\", (message: any) => {\n      console.log('[SignalR] Message sent:', message);\n      this.notifyListeners(\"MessageSent\", message);\n    });\n\n    // Handle message errors\n    this.connection.on(\"MessageError\", (error: string) => {\n      console.error('[SignalR] Message error:', error);\n      this.notifyListeners(\"MessageError\", error);\n    });\n\n    // Handle typing indicators\n    this.connection.on(\"UserTyping\", (data: { userId: string; userName: string; threadId: string }) => {\n      this.notifyListeners(\"UserTyping\", data);\n    });\n\n    // Handle message read receipts\n    this.connection.on(\"MessageRead\", (messageId: string) => {\n      this.notifyListeners(\"MessageRead\", messageId);\n    });\n\n    // Handle connection state changes\n    this.connection.onreconnecting((error) => {\n      console.warn('[SignalR] Reconnecting...', error);\n      this.notifyListeners(\"Reconnecting\", error);\n    });\n\n    this.connection.onreconnected((connectionId) => {\n      console.log('[SignalR] Reconnected:', connectionId);\n      this.notifyListeners(\"Reconnected\", connectionId);\n    });\n\n    this.connection.onclose((error) => {\n      console.error('[SignalR] Connection closed:', error);\n      this.notifyListeners(\"ConnectionClosed\", error);\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.connection) {\n      await this.connection.stop();\n      this.connection = null;\n      this.listeners.clear();\n      console.log('[SignalR] Disconnected');\n    }\n  }\n\n  async joinThread(threadId: string): Promise<void> {\n    if (this.connection?.state === signalR.HubConnectionState.Connected) {\n      // Validate threadId is a valid GUID before calling\n      if (!threadId || threadId === '00000000-0000-0000-0000-000000000000') {\n        console.warn('[SignalR] Invalid threadId provided to JoinThread:', threadId);\n        return;\n      }\n      \n      try {\n        // Ensure threadId is a valid GUID string\n        const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n        if (!guidRegex.test(threadId)) {\n          console.warn('[SignalR] threadId is not a valid GUID:', threadId);\n          return;\n        }\n        \n        await this.connection.invoke(\"JoinThread\", threadId);\n        console.log('[SignalR] Joined thread:', threadId);\n      } catch (error) {\n        console.error('[SignalR] Failed to join thread:', threadId, error);\n        throw error;\n      }\n    }\n  }\n\n  async leaveThread(threadId: string): Promise<void> {\n    if (this.connection?.state === signalR.HubConnectionState.Connected) {\n      await this.connection.invoke(\"LeaveThread\", threadId);\n    }\n  }\n\n  async sendTypingIndicator(threadId: string): Promise<void> {\n    if (this.connection?.state === signalR.HubConnectionState.Connected) {\n      await this.connection.invoke(\"UserTyping\", threadId);\n    }\n  }\n\n  on(event: string, callback: (data: any) => void): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.get(event)?.delete(callback);\n    };\n  }\n\n  private notifyListeners(event: string, data: any): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`[SignalR] Error in listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connection?.state === signalR.HubConnectionState.Connected;\n  }\n\n  getConnectionState(): signalR.HubConnectionState {\n    return this.connection?.state || signalR.HubConnectionState.Disconnected;\n  }\n\n  private generateUserIdFromEmail(email: string): string {\n    // Simple hash function to generate consistent ID from email\n    // This should match the backend logic\n    let hash = 0;\n    for (let i = 0; i < email.length; i++) {\n      const char = email.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash).toString();\n  }\n}\n\n// Export singleton instance\nexport const signalRService = new SignalRService();\nexport default signalRService;\n\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nexport abstract class HeaderNames {\r\n    static readonly Authorization = \"Authorization\";\r\n    static readonly Cookie = \"Cookie\";\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\n\r\n/** Defines the type of a Hub Message. */\r\nexport enum MessageType {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    Invocation = 1,\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    StreamItem = 2,\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    Completion = 3,\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    StreamInvocation = 4,\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    CancelInvocation = 5,\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    Ping = 6,\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    Close = 7,\r\n    Ack = 8,\r\n    Sequence = 9\r\n}\r\n\r\n/** Defines a dictionary of string keys and string values representing headers attached to a Hub message. */\r\nexport interface MessageHeaders {\r\n    /** Gets or sets the header with the specified key. */\r\n    [key: string]: string;\r\n}\r\n\r\n/** Union type of all known Hub messages. */\r\nexport type HubMessage =\r\n    InvocationMessage |\r\n    StreamInvocationMessage |\r\n    StreamItemMessage |\r\n    CompletionMessage |\r\n    CancelInvocationMessage |\r\n    PingMessage |\r\n    CloseMessage |\r\n    AckMessage |\r\n    SequenceMessage;\r\n\r\n/** Defines properties common to all Hub messages. */\r\nexport interface HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageType} value indicating the type of this message. */\r\n    readonly type: MessageType;\r\n}\r\n\r\n/** Defines properties common to all Hub messages relating to a specific invocation. */\r\nexport interface HubInvocationMessage extends HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageHeaders} dictionary containing headers attached to the message. */\r\n    readonly headers?: MessageHeaders;\r\n    /** The ID of the invocation relating to this message.\r\n     *\r\n     * This is expected to be present for {@link @microsoft/signalr.StreamInvocationMessage} and {@link @microsoft/signalr.CompletionMessage}. It may\r\n     * be 'undefined' for an {@link @microsoft/signalr.InvocationMessage} if the sender does not expect a response.\r\n     */\r\n    readonly invocationId?: string;\r\n}\r\n\r\n/** A hub message representing a non-streaming invocation. */\r\nexport interface InvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Invocation;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a streaming invocation. */\r\nexport interface StreamInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamInvocation;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a single item produced as part of a result stream. */\r\nexport interface StreamItemMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamItem;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n\r\n    /** The item produced by the server. */\r\n    readonly item?: any;\r\n}\r\n\r\n/** A hub message representing the result of an invocation. */\r\nexport interface CompletionMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Completion;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The error produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly error?: string;\r\n    /** The result produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly result?: any;\r\n}\r\n\r\n/** A hub message indicating that the sender is still active. */\r\nexport interface PingMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Ping;\r\n}\r\n\r\n/** A hub message indicating that the sender is closing the connection.\r\n *\r\n * If {@link @microsoft/signalr.CloseMessage.error} is defined, the sender is closing the connection due to an error.\r\n */\r\nexport interface CloseMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Close;\r\n    /** The error that triggered the close, if any.\r\n     *\r\n     * If this property is undefined, the connection was closed normally and without error.\r\n     */\r\n    readonly error?: string;\r\n\r\n    /** If true, clients with automatic reconnects enabled should attempt to reconnect after receiving the CloseMessage. Otherwise, they should not. */\r\n    readonly allowReconnect?: boolean;\r\n}\r\n\r\n/** A hub message sent to request that a streaming invocation be canceled. */\r\nexport interface CancelInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.CancelInvocation;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n}\r\n\r\nexport interface AckMessage extends HubMessageBase\r\n{\r\n    readonly type: MessageType.Ack;\r\n\r\n    readonly sequenceId: number;\r\n}\r\n\r\nexport interface SequenceMessage extends HubMessageBase\r\n{\r\n    readonly type: MessageType.Sequence;\r\n\r\n    readonly sequenceId: number;\r\n}\r\n\r\n/** A protocol abstraction for communicating with SignalR Hubs.  */\r\nexport interface IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    readonly name: string;\r\n    /** The version of the protocol. */\r\n    readonly version: number;\r\n    /** The {@link @microsoft/signalr.TransferFormat} of the protocol. */\r\n    readonly transferFormat: TransferFormat;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the `input` parameter must be a string, otherwise it must be an ArrayBuffer.\r\n     *\r\n     * @param {string | ArrayBuffer} input A string or ArrayBuffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input: string | ArrayBuffer, logger: ILogger): HubMessage[];\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string or ArrayBuffer and returns it.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the result of this method will be a string, otherwise it will be an ArrayBuffer.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string | ArrayBuffer} A string or ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message: HubMessage): string | ArrayBuffer;\r\n}","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IRetryPolicy, RetryContext } from \"./IRetryPolicy\";\r\n\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n\r\n/** @private */\r\nexport class DefaultReconnectPolicy implements IRetryPolicy {\r\n    private readonly _retryDelays: (number | null)[];\r\n\r\n    constructor(retryDelays?: number[]) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n\r\n    public nextRetryDelayInMilliseconds(retryContext: RetryContext): number | null {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport enum HttpTransportType {\r\n    /** Specifies no transport preference. */\r\n    None = 0,\r\n    /** Specifies the WebSockets transport. */\r\n    WebSockets = 1,\r\n    /** Specifies the Server-Sent Events transport. */\r\n    ServerSentEvents = 2,\r\n    /** Specifies the Long Polling transport. */\r\n    LongPolling = 4,\r\n}\r\n\r\n/** Specifies the transfer format for a connection. */\r\nexport enum TransferFormat {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    Text = 1,\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    Binary = 2,\r\n}\r\n\r\n/** An abstraction over the behavior of transports. This is designed to support the framework and not intended for use by applications. */\r\nexport interface ITransport {\r\n    connect(url: string, transferFormat: TransferFormat): Promise<void>;\r\n    send(data: any): Promise<void>;\r\n    stop(): Promise<void>;\r\n    onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    onclose: ((error?: Error) => void) | null;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController implements AbortSignal {\r\n    private _isAborted: boolean = false;\r\n    public onabort: (() => void) | null = null;\r\n\r\n    public abort(): void {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n\r\n    get signal(): AbortSignal {\r\n        return this;\r\n    }\r\n\r\n    get aborted(): boolean {\r\n        return this._isAborted;\r\n    }\r\n}\r\n\r\n/** Represents a signal that can be monitored to determine if a request has been aborted. */\r\nexport interface AbortSignal {\r\n    /** Indicates if the request has been aborted. */\r\n    aborted: boolean;\r\n    /** Set this to a handler that will be invoked when the request is aborted. */\r\n    onabort: (() => void) | null;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortSignal } from \"./AbortController\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\n\r\n/** Represents an HTTP request. */\r\nexport interface HttpRequest {\r\n    /** The HTTP method to use for the request. */\r\n    method?: string;\r\n\r\n    /** The URL for the request. */\r\n    url?: string;\r\n\r\n    /** The body content for the request. May be a string or an ArrayBuffer (for binary data). */\r\n    content?: string | ArrayBuffer;\r\n\r\n    /** An object describing headers to apply to the request. */\r\n    headers?: MessageHeaders;\r\n\r\n    /** The XMLHttpRequestResponseType to apply to the request. */\r\n    responseType?: XMLHttpRequestResponseType;\r\n\r\n    /** An AbortSignal that can be monitored for cancellation. */\r\n    abortSignal?: AbortSignal;\r\n\r\n    /** The time to wait for the request to complete before throwing a TimeoutError. Measured in milliseconds. */\r\n    timeout?: number;\r\n\r\n    /** This controls whether credentials such as cookies are sent in cross-site requests. */\r\n    withCredentials?: boolean;\r\n}\r\n\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     */\r\n    constructor(statusCode: number);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code and message.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and string content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: ArrayBuffer);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string | ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string | ArrayBuffer);\r\n    constructor(\r\n        public readonly statusCode: number,\r\n        public readonly statusText?: string,\r\n        public readonly content?: string | ArrayBuffer) {\r\n    }\r\n}\r\n\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport abstract class HttpClient {\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public get(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public post(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public delete(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP request to the specified URL, returning a {@link Promise} that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {HttpRequest} request An {@link @microsoft/signalr.HttpRequest} describing the request to send.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an HttpResponse describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public abstract send(request: HttpRequest): Promise<HttpResponse>;\r\n\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    public getCookieString(url: string): string {\r\n        return \"\";\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { SubjectSubscription } from \"./Utils\";\r\n\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    /** @internal */\r\n    public observers: IStreamSubscriber<T>[];\r\n\r\n    /** @internal */\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n","// Browser Push Notifications Service\n// This service handles browser push notifications for new messages\n// Note: Service worker removed per requirements - using standard browser notifications only\n\nexport class PushNotificationService {\n  private static instance: PushNotificationService;\n  private permission: NotificationPermission = 'default';\n\n  private constructor() {\n    if (typeof window !== 'undefined') {\n      this.permission = Notification.permission;\n    }\n  }\n\n  public static getInstance(): PushNotificationService {\n    if (!PushNotificationService.instance) {\n      PushNotificationService.instance = new PushNotificationService();\n    }\n    return PushNotificationService.instance;\n  }\n\n  public async requestPermission(): Promise<boolean> {\n    if (!('Notification' in window)) {\n      console.warn('[PushNotifications] This browser does not support notifications');\n      return false;\n    }\n\n    if (this.permission === 'granted') {\n      return true;\n    }\n\n    if (this.permission === 'denied') {\n      console.warn('[PushNotifications] Notification permission denied');\n      return false;\n    }\n\n    const permission = await Notification.requestPermission();\n    this.permission = permission;\n    return permission === 'granted';\n  }\n\n  public async showNotification(\n    title: string,\n    options: NotificationOptions = {}\n  ): Promise<void> {\n    if (!('Notification' in window)) {\n      return;\n    }\n\n    if (this.permission !== 'granted') {\n      const granted = await this.requestPermission();\n      if (!granted) {\n        return;\n      }\n    }\n\n    const defaultOptions: NotificationOptions = {\n      icon: '/mukuru-logo.png',\n      badge: '/mukuru-logo.png',\n      tag: 'message',\n      requireInteraction: false,\n      ...options,\n    };\n\n    // Use standard browser notifications (service worker removed)\n    new Notification(title, defaultOptions);\n  }\n\n  public async showMessageNotification(\n    senderName: string,\n    content: string,\n    threadId?: string\n  ): Promise<void> {\n    await this.showNotification(\n      `New message from ${senderName}`,\n      {\n        body: content.length > 100 ? content.substring(0, 100) + '...' : content,\n        tag: `message-${threadId || 'new'}`,\n        data: { threadId },\n        requireInteraction: false,\n      }\n    );\n  }\n\n  public getPermission(): NotificationPermission {\n    return this.permission;\n  }\n\n  public isSupported(): boolean {\n    return 'Notification' in window;\n  }\n}\n\nexport const pushNotificationService = PushNotificationService.getInstance();\n\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport { CookieJar } from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly _abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly _fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly _jar?: CookieJar;\r\n\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n\r\n        // Node added a fetch implementation to the global scope starting in v18.\r\n        // We need to add a cookie jar in node to be able to share cookies with WebSocket\r\n        if (typeof fetch === \"undefined\" || Platform.isNode) {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n\r\n            if (typeof fetch === \"undefined\") {\r\n                this._fetchType = requireFunc(\"node-fetch\");\r\n            } else {\r\n                // Use fetch from Node if available\r\n                this._fetchType = fetch;\r\n            }\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        } else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this._abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            } else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this._fetchType(request.url!, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\") as string;\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private readonly _pollAbort: AbortController;\r\n\r\n    private _url?: string;\r\n    private _running: boolean;\r\n    private _receiving?: Promise<void>;\r\n    private _closeError?: Error | unknown;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error | unknown) => void) | null;\r\n\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    public get pollAborted(): boolean {\r\n        return this._pollAbort.aborted;\r\n    }\r\n\r\n    constructor(httpClient: HttpClient, logger: ILogger, options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n\r\n        this._running = false;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._url = url;\r\n\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n\r\n        const pollOptions: HttpRequest = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        } else {\r\n            this._running = true;\r\n        }\r\n\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n\r\n    private async _poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n        try {\r\n            while (this._running) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n                        this._running = false;\r\n                    } else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    } else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent!)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        } else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${(e as any).message}`);\r\n                    } else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        } else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n\r\n        try {\r\n            await this._receiving;\r\n\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n\r\n            const headers: {[k: string]: string} = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n\r\n            const deleteOptions: HttpRequest = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n\r\n            let error;\r\n            try {\r\n                await this._httpClient.delete(this._url!, deleteOptions);\r\n            } catch (err) {\r\n                error = err;\r\n            }\r\n\r\n            if (error) {\r\n                if (error instanceof HttpError) {\r\n                    if (error.statusCode === 404) {\r\n                        this._logger.log(LogLevel.Trace, \"(LongPolling transport) A 404 response was returned from sending a DELETE request.\");\r\n                    } else {\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);\r\n                    }\r\n                }\r\n            } else {\r\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request accepted.\");\r\n            }\r\n\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n\r\n    private _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\nexport class XhrHttpClient extends HttpClient {\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n\r\n            xhr.open(request.method!, request.url!, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.content === \"\") {\r\n                request.content = undefined;\r\n            }\r\n            if (request.content) {\r\n                // Explicitly setting the Content-Type header for React Native on Android platform.\r\n                if (isArrayBuffer(request.content)) {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\r\n                } else {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n            }\r\n\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                        xhr.setRequestHeader(header, headers[header]);\r\n                    });\r\n            }\r\n\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                } else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n\r\n            xhr.send(request.content);\r\n        });\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly _httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this._httpClient.send(request);\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessToken: string | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error | unknown) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessToken: string | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error | unknown) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { VERSION } from \"./pkg-version\";\r\n\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\n\r\nexport { VERSION };\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    public static isNotEmpty(val: string, name: string): void {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    public static get isBrowser(): boolean {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    public static get isWebWorker(): boolean {\r\n        return !Platform.isNode && typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n\r\n    // react-native has a window but no document\r\n    static get isReactNative(): boolean {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    public static get isNode(): boolean {\r\n        return typeof process !== \"undefined\" && process.release && process.release.name === \"node\";\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string,\r\n                                  content: string | ArrayBuffer, options: IHttpConnectionOptions): Promise<void> {\r\n    const headers: {[k: string]: string} = {};\r\n\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent!)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers},\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel): ILogger {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log !== undefined) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private _subject: Subject<T>;\r\n    private _observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly _minLevel: LogLevel;\r\n\r\n    // Public for testing purposes.\r\n    public out: {\r\n        error(message: any): void,\r\n        warn(message: any): void,\r\n        info(message: any): void,\r\n        log(message: any): void,\r\n    };\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getUserAgentHeader(): [string, string] {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [ userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion()) ];\r\n}\r\n\r\n/** @private */\r\nexport function constructUserAgent(version: string, os: string, runtime: string, runtimeVersion: string | undefined): string {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent: string = \"Microsoft SignalR/\";\r\n\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    } else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n\r\n    userAgent += `${runtime}`;\r\n\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    } else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName(): string {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion(): string | undefined {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getRuntime(): string {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    } else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getErrorString(e: any): string {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    } else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n\r\n/** @private */\r\nexport function getGlobalThis(): unknown {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { IHubProtocol } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStatefulReconnectOptions } from \"./IStatefulReconnectOptions\";\r\nimport { HttpTransportType } from \"./ITransport\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n\r\nconst LogLevelNameMapping: {[k: string]: LogLevel} = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\n\r\nfunction parseLogLevel(name: string): LogLevel {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    } else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    private _serverTimeoutInMilliseconds?: number;\r\n    private _keepAliveIntervalInMilliseconds ?: number;\r\n\r\n    /** @internal */\r\n    public protocol?: IHubProtocol;\r\n    /** @internal */\r\n    public httpConnectionOptions?: IHttpConnectionOptions;\r\n    /** @internal */\r\n    public url?: string;\r\n    /** @internal */\r\n    public logger?: ILogger;\r\n\r\n    /** If defined, this indicates the client should automatically attempt to reconnect if the connection is lost. */\r\n    /** @internal */\r\n    public reconnectPolicy?: IRetryPolicy;\r\n\r\n    private _statefulReconnectBufferSize?: number;\r\n\r\n    /** Configures console logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel} logLevel The minimum level of messages to log. Anything at this level, or a more severe level, will be logged.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logLevel: LogLevel): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {ILogger} logger An object implementing the {@link @microsoft/signalr.ILogger} interface, which will be used to write all log messages.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logger: ILogger): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {string} logLevel A string representing a LogLevel setting a minimum level of messages to log.\r\n     *    See {@link https://learn.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     */\r\n    public configureLogging(logLevel: string): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel | string | ILogger} logging A {@link @microsoft/signalr.LogLevel}, a string representing a LogLevel, or an object implementing the {@link @microsoft/signalr.ILogger} interface.\r\n     *    See {@link https://learn.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder;\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder {\r\n        Arg.isRequired(logging, \"logging\");\r\n\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        } else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        } else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * The transport will be selected automatically based on what the server and client support.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified HTTP-based transport to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {HttpTransportType} transportType The specific transport to use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, transportType: HttpTransportType): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {IHttpConnectionOptions} options An options object used to configure the connection.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, options: IHttpConnectionOptions): HubConnectionBuilder;\r\n    public withUrl(url: string, transportTypeOrOptions?: IHttpConnectionOptions | HttpTransportType): HubConnectionBuilder {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n\r\n        this.url = url;\r\n\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        } else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    public withHubProtocol(protocol: IHubProtocol): HubConnectionBuilder {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     * By default, the client will wait 0, 2, 10 and 30 seconds respectively before trying up to 4 reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {number[]} retryDelays An array containing the delays in milliseconds before trying each reconnect attempt.\r\n     * The length of the array represents how many failed reconnect attempts it takes before the client will stop attempting to reconnect.\r\n     */\r\n    public withAutomaticReconnect(retryDelays: number[]): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {IRetryPolicy} reconnectPolicy An {@link @microsoft/signalR.IRetryPolicy} that controls the timing and number of reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(reconnectPolicy: IRetryPolicy): HubConnectionBuilder;\r\n    public withAutomaticReconnect(retryDelaysOrReconnectPolicy?: number[] | IRetryPolicy): HubConnectionBuilder {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        } else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withServerTimeout(milliseconds: number): HubConnectionBuilder {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n\r\n        this._serverTimeoutInMilliseconds = milliseconds;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withKeepAliveInterval(milliseconds: number): HubConnectionBuilder {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n\r\n        this._keepAliveIntervalInMilliseconds = milliseconds;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Enables and configures options for the Stateful Reconnect feature.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withStatefulReconnect(options?: IStatefulReconnectOptions): HubConnectionBuilder {\r\n        if (this.httpConnectionOptions === undefined) {\r\n            this.httpConnectionOptions = {};\r\n        }\r\n        this.httpConnectionOptions._useStatefulReconnect = true;\r\n\r\n        this._statefulReconnectBufferSize = options?.bufferSize;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    public build(): HubConnection {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n\r\n        return HubConnection.create(\r\n            connection,\r\n            this.logger || NullLogger.instance,\r\n            this.protocol || new JsonHubProtocol(),\r\n            this.reconnectPolicy,\r\n            this._serverTimeoutInMilliseconds,\r\n            this._keepAliveIntervalInMilliseconds,\r\n            this._statefulReconnectBufferSize);\r\n    }\r\n}\r\n\r\nfunction isLogger(logger: any): logger is ILogger {\r\n    return logger.log !== undefined;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { CancelInvocationMessage, CloseMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\nimport { MessageBuffer } from \"./MessageBuffer\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\nconst DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 100_000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly _cachedPingMessage: string | ArrayBuffer;\r\n    // Needs to not start with _ for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private readonly connection: IConnection;\r\n    private readonly _logger: ILogger;\r\n    private readonly _reconnectPolicy?: IRetryPolicy;\r\n    private readonly _statefulReconnectBufferSize: number;\r\n    private _protocol: IHubProtocol;\r\n    private _handshakeProtocol: HandshakeProtocol;\r\n    private _callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private _methods: { [name: string]: (((...args: any[]) => void) | ((...args: any[]) => any))[] };\r\n    private _invocationId: number;\r\n    private _messageBuffer?: MessageBuffer;\r\n\r\n    private _closedCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectingCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectedCallbacks: ((connectionId?: string) => void)[];\r\n\r\n    private _receivedHandshakeResponse: boolean;\r\n    private _handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private _handshakeRejecter!: (reason?: any) => void;\r\n    private _stopDuringStartError?: Error;\r\n\r\n    private _connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private _startPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _nextKeepAlive: number = 0;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private _reconnectDelayHandle?: any;\r\n    private _timeoutHandle?: any;\r\n    private _pingServerHandle?: any;\r\n\r\n    private _freezeEventListener = () =>\r\n    {\r\n        this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n    };\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     * The ping will happen at most as often as the server pings.\r\n     * If the server pings every 5 seconds, a value lower than 5 will ping every 5 seconds.\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(\r\n        connection: IConnection,\r\n        logger: ILogger,\r\n        protocol: IHubProtocol,\r\n        reconnectPolicy?: IRetryPolicy,\r\n        serverTimeoutInMilliseconds?: number,\r\n        keepAliveIntervalInMilliseconds?: number,\r\n        statefulReconnectBufferSize?: number): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy,\r\n            serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);\r\n    }\r\n\r\n    private constructor(\r\n        connection: IConnection,\r\n        logger: ILogger,\r\n        protocol: IHubProtocol,\r\n        reconnectPolicy?: IRetryPolicy,\r\n        serverTimeoutInMilliseconds?: number,\r\n        keepAliveIntervalInMilliseconds?: number,\r\n        statefulReconnectBufferSize?: number) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds ?? DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds ?? DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this._statefulReconnectBufferSize = statefulReconnectBufferSize ?? DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;\r\n\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this._processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this._connectionClosed(error);\r\n\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n\r\n    private async _startWithStateTransitions(): Promise<void> {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this._startInternal();\r\n\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this._protocol.transferFormat);\r\n\r\n        try {\r\n            let version = this._protocol.version;\r\n            if (!this.connection.features.reconnect) {\r\n                // Stateful Reconnect starts with HubProtocol version 2, newer clients connecting to older servers will fail to connect due to\r\n                // the handshake only supporting version 1, so we will try to send version 1 during the handshake to keep old servers working.\r\n                version = 1;\r\n            }\r\n\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this._protocol.name,\r\n                version,\r\n            };\r\n\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n\r\n            const useStatefulReconnect = this.connection.features.reconnect || false;\r\n            if (useStatefulReconnect) {\r\n                this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);\r\n                this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);\r\n                this.connection.features.resend = () => {\r\n                    if (this._messageBuffer) {\r\n                        return this._messageBuffer._resend();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n        this.connection.features.reconnect = false;\r\n\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private _stopInternal(error?: Error): Promise<void> {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise!;\r\n        }\r\n\r\n        const state = this._connectionState;\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (state === HubConnectionState.Connected) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._sendCloseMessage();\r\n        }\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    private async _sendCloseMessage() {\r\n        try {\r\n            await this._sendWithProtocol(this._createCloseMessage());\r\n        } catch {\r\n            // Ignore, this is a best effort attempt to let the server know the client closed gracefully.\r\n        }\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue: Promise<void>;\r\n\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this._launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private _sendMessage(message: any) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private _sendWithProtocol(message: any) {\r\n        if (this._messageBuffer) {\r\n            return this._messageBuffer._send(message);\r\n        } else {\r\n            return this._sendMessage(this._protocol.writeMessage(message));\r\n        }\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n\r\n        this._launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this._callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => any): void\r\n    public on(methodName: string, newMethod: (...args: any[]) => void): void {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this._methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void): void {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private _processIncomingData(data: any) {\r\n        this._cleanupTimeout();\r\n\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n\r\n            for (const message of messages) {\r\n                if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {\r\n                    // Don't process the message, we are either waiting for a SequenceMessage or received a duplicate message\r\n                    continue;\r\n                }\r\n\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this._invokeClientMethod(message)\r\n                            .catch((e) => {\r\n                                this._logger.log(LogLevel.Error, `Invoke client method threw error: ${getErrorString(e)}`)\r\n                            });\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            } catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                    case MessageType.Ack:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._ack(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Sequence:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._resetSequence(message);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._resetTimeoutPeriod();\r\n    }\r\n\r\n    private _processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n\r\n        this._cleanupPingTimer();\r\n    }\r\n\r\n    private _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined)\r\n            {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        } catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private async _invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            } catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `${exception}`, null);\r\n            } else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, null, res);\r\n            } else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _connectionClosed(error?: Error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private _completeClose(error?: Error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n            if (this._messageBuffer) {\r\n                this._messageBuffer._dispose(error ?? new Error(\"Connection closed.\"));\r\n                this._messageBuffer = undefined;\r\n            }\r\n\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this._startInternal();\r\n\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState as any === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error((e as any).toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this._completeClose();\r\n    }\r\n\r\n    private _getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this._reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private _cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                try {\r\n                    callback(null, error);\r\n                } catch (e) {\r\n                    this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n                }\r\n            });\r\n    }\r\n\r\n    private _cleanupPingTimer(): void {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n\r\n    private _cleanupTimeout(): void {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private _createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    target: methodName,\r\n                    arguments: args,\r\n                    streamIds,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    target: methodName,\r\n                    arguments: args,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    target: methodName,\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    target: methodName,\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _launchStreams(streams: IStreamResult<any>[], promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private _replaceStreamingParams(args: any[]): [IStreamResult<any>[], string[]] {\r\n        const streams: IStreamResult<any>[] = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private _isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private _createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                target: methodName,\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                target: methodName,\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private _createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private _createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private _createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n\r\n    private _createCloseMessage(): CloseMessage {\r\n        return { type: MessageType.Close };\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AckMessage, CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, SequenceMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 2;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                case MessageType.Ack:\r\n                    this._isAckMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Sequence:\r\n                    this._isSequenceMessage(parsedMessage);\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private _isInvocationMessage(message: InvocationMessage): void {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private _isStreamItemMessage(message: StreamItemMessage): void {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private _isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private _isAckMessage(message: AckMessage): void {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Ack message.\");\r\n        }\r\n    }\r\n\r\n    private _isSequenceMessage(message: SequenceMessage): void {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Sequence message.\");\r\n        }\r\n    }\r\n\r\n    private _assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        let token: string;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else\r\n            {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event: CloseEvent | Error | unknown): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n    useStatefulReconnect?: boolean;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: (keyof typeof TransferFormat)[];\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private _connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private readonly _httpClient: AccessTokenHttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    // Needs to not start with _ to be available for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private transport?: ITransport;\r\n    private _startInternalPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private _stopError?: Error;\r\n    private _accessTokenFactory?: () => string | Promise<string>;\r\n    private _sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly _negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = ConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this._connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Connecting;\r\n\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n\r\n            return Promise.reject(new AbortError(message));\r\n        } else if (this._connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n\r\n        this._connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this._connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Disconnecting;\r\n\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n\r\n    private async _stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n\r\n        try {\r\n            await this._startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async _startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === ConnectionState.Disconnecting || this._connectionState === ConnectionState.Disconnected) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this._connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers: {[k: string]: string} = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n\r\n            if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {\r\n                return Promise.reject(new FailedToNegotiateWithServerError(\"Client didn't negotiate Stateful Reconnect but the server did.\"));\r\n            }\r\n\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n\r\n    private _createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async _createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat,\r\n                negotiate?.useStatefulReconnect === true);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            } else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n\r\n                    if (this._connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private _constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent!,\r\n                    this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private _startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        if (this.features.reconnect) {\r\n            this.transport!.onclose = async (e) => {\r\n                let callStop = false;\r\n                if (this.features.reconnect) {\r\n                    try {\r\n                        this.features.disconnected();\r\n                        await this.transport!.connect(url, transferFormat);\r\n                        await this.features.resend();\r\n                    } catch {\r\n                        callStop = true;\r\n                    }\r\n                } else {\r\n                    this._stopConnection(e);\r\n                    return;\r\n                }\r\n\r\n                if (callStop) {\r\n                    this._stopConnection(e);\r\n                }\r\n            };\r\n        } else {\r\n            this.transport!.onclose = (e) => this._stopConnection(e);\r\n        }\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private _resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined,\r\n        requestedTransferFormat: TransferFormat, useStatefulReconnect: boolean): ITransport | Error | unknown {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    } else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : undefined;\r\n                            return this._constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private _stopConnection(error?: Error): void {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Connecting) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this._connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private _resolveNegotiateUrl(url: string): string {\r\n        const negotiateUrl = new URL(url);\r\n\r\n        if (negotiateUrl.pathname.endsWith('/')) {\r\n            negotiateUrl.pathname += \"negotiate\";\r\n        } else {\r\n            negotiateUrl.pathname += \"/negotiate\";\r\n        }\r\n        const searchParams = new URLSearchParams(negotiateUrl.searchParams);\r\n\r\n        if (!searchParams.has(\"negotiateVersion\")) {\r\n            searchParams.append(\"negotiateVersion\", this._negotiateVersion.toString());\r\n        }\r\n\r\n        if (searchParams.has(\"useStatefulReconnect\")) {\r\n            if (searchParams.get(\"useStatefulReconnect\") === \"true\") {\r\n                this._options._useStatefulReconnect = true;\r\n            }\r\n        } else if (this._options._useStatefulReconnect === true) {\r\n            searchParams.append(\"useStatefulReconnect\", \"true\");\r\n        }\r\n\r\n        negotiateUrl.search = searchParams.toString();\r\n\r\n        return negotiateUrl.toString();\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private _buffer: any[] = [];\r\n    private _sendBufferedData: PromiseSource;\r\n    private _executing: boolean = true;\r\n    private _transportResult?: PromiseSource;\r\n    private _sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly _transport: ITransport) {\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n\r\n    private _bufferData(data: string | ArrayBuffer): void {\r\n        if (this._buffer.length && typeof(this._buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this._buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n\r\n    private async _sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this._sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this._transportResult!;\r\n            this._transportResult = undefined;\r\n\r\n            const data = typeof(this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n\r\n            this._buffer.length = 0;\r\n\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private _resolver?: () => void;\r\n    private _rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this._resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this._rejecter!(reason);\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger implements ILogger {\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    public static instance: ILogger = new NullLogger();\r\n\r\n    private constructor() {}\r\n\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    public log(_logLevel: LogLevel, _message: string): void {\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport interface HandshakeRequestMessage {\r\n    readonly protocol: string;\r\n    readonly version: number;\r\n}\r\n\r\n/** @private */\r\nexport interface HandshakeResponseMessage {\r\n    readonly error: string;\r\n    readonly minorVersion: number;\r\n}\r\n\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    public writeHandshakeRequest(handshakeRequest: HandshakeRequestMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n\r\n    public parseHandshakeResponse(data: any): [any, HandshakeResponseMessage] {\r\n        let messageData: string;\r\n        let remainingData: any;\r\n\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        } else {\r\n            const textData: string = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage: HandshakeResponseMessage = response;\r\n\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\n\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    private _innerClient: HttpClient;\r\n    _accessToken: string | undefined;\r\n    _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n\r\n    constructor(innerClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined) {\r\n        super();\r\n\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private _setAuthorizationHeader(request: HttpRequest) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IConnection } from \"./IConnection\";\r\nimport { AckMessage, HubMessage, IHubProtocol, MessageType, SequenceMessage } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class MessageBuffer {\r\n    private readonly _protocol: IHubProtocol;\r\n    private readonly _connection: IConnection;\r\n\r\n    private readonly _bufferSize: number = 100_000;\r\n\r\n    private _messages: BufferedItem[] = [];\r\n    private _totalMessageCount: number = 0;\r\n    private _waitForSequenceMessage: boolean = false;\r\n\r\n    // Message IDs start at 1 and always increment by 1\r\n    private _nextReceivingSequenceId = 1;\r\n    private _latestReceivedSequenceId = 0;\r\n    private _bufferedByteCount: number = 0;\r\n    private _reconnectInProgress: boolean = false;\r\n\r\n    private _ackTimerHandle?: any;\r\n\r\n    constructor(protocol: IHubProtocol, connection: IConnection, bufferSize: number) {\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n\r\n    public async _send(message: HubMessage): Promise<void> {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n\r\n        let backpressurePromise: Promise<void> = Promise.resolve();\r\n\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver: (value: void) => void = () => {};\r\n            let backpressurePromiseRejector: (value?: void) => void = () => {};\r\n\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            } else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount,\r\n                backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        } catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n\r\n    public _ack(ackMessage: AckMessage): void {\r\n        let newestAckedMessage = -1;\r\n\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                } else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            } else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n\r\n    public _shouldProcessMessage(message: HubMessage): boolean {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            } else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n\r\n        this._latestReceivedSequenceId = currentId;\r\n\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n\r\n    public _resetSequence(message: SequenceMessage): void {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n\r\n    public _disconnected(): void {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n\r\n    public async _resend(): Promise<void> {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            :  this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n\r\n        this._reconnectInProgress = false;\r\n    }\r\n\r\n    public _dispose(error?: Error): void {\r\n        error ??= new Error(\"Unable to reconnect to server.\")\r\n\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n\r\n    private _isInvocationMessage(message: HubMessage): boolean {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    private _ackTimer(): void {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }))\r\n                    }\r\n                // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                } catch { }\r\n\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n            // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\n\r\nclass BufferedItem {\r\n    constructor(message: string | ArrayBuffer, id: number, resolver: (value: void) => void, rejector: (value?: any) => void) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n\r\n    _message: string | ArrayBuffer;\r\n    _id: number;\r\n    _resolver: (value: void) => void;\r\n    _rejector: (value?: any) => void;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    Trace = 0,\r\n    /** Log level for low severity diagnostic messages. */\r\n    Debug = 1,\r\n    /** Log level for informational diagnostic messages. */\r\n    Information = 2,\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    Warning = 3,\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    Error = 4,\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    Critical = 5,\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger {\r\n    /** Called by the framework to emit a diagnostic message.\r\n     *\r\n     * @param {LogLevel} logLevel The severity level of the message.\r\n     * @param {string} message The message.\r\n     */\r\n    log(logLevel: LogLevel, message: string): void;\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpTransportType } from \"./ITransport\";\r\n\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The HTTP status code represented by this error. */\r\n    public statusCode: number;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage: string, statusCode: number) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message: string) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when multiple errors have occurred. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The collection of errors this error is aggregating. */\r\n    public innerErrors: Error[];\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message: string, innerErrors: Error[]) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n\r\n        this.innerErrors = innerErrors;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n","/**\n * Document Upload Service for Admin Portal\n * Uploads files to Document Service for message attachments\n */\n\nexport interface UploadDocumentResult {\n  documentId: string;\n  documentNumber: string;\n  wasDuplicate: boolean;\n  existingDocumentId?: string;\n  storageKey: string;\n  storageUrl?: string;\n}\n\n/**\n * Uploads a file to the Document Service API for message attachments\n * \n * @param caseId - The case GUID (application ID)\n * @param file - The File object to upload\n * @param description - Optional description\n * @param uploadedBy - Email of the user uploading\n * @returns Upload result with document ID and storage key\n */\nexport async function uploadFileToDocumentService(\n  caseId: string,\n  file: File,\n  description?: string,\n  uploadedBy?: string\n): Promise<UploadDocumentResult> {\n  // Get user email from session if not provided\n  if (!uploadedBy && typeof window !== 'undefined') {\n    try {\n      const response = await fetch('/api/auth/session');\n      const session = await response.json();\n      uploadedBy = session?.user?.email || 'admin@mukuru.com';\n    } catch {\n      uploadedBy = 'admin@mukuru.com';\n    }\n  }\n\n  // Generate partnerId from email (for admin, use a default or extract from session)\n  // For message attachments, we can use the case's partnerId or generate from user email\n  let partnerId = '';\n  if (uploadedBy) {\n    // Simple hash-based partnerId generation (matches backend approach)\n    const emailLower = uploadedBy.toLowerCase();\n    let hash = 0;\n    for (let i = 0; i < emailLower.length; i++) {\n      const char = emailLower.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    const hex = Math.abs(hash).toString(16).padStart(32, '0');\n    partnerId = `${hex.substring(0, 8)}-${hex.substring(8, 12)}-${hex.substring(12, 16)}-${hex.substring(16, 20)}-${hex.substring(20, 32)}`;\n  }\n\n  const formData = new FormData();\n  \n  // Append file\n  formData.append('file', file);\n  \n  // Append required fields\n  formData.append('caseId', caseId);\n  formData.append('partnerId', partnerId);\n  formData.append('type', '99'); // DocumentType.Other\n  \n  // Append optional fields\n  if (description) formData.append('description', description);\n  if (uploadedBy) formData.append('uploadedBy', uploadedBy);\n  \n  // Upload via proxy to document service\n  const response = await fetch('/api/proxy/api/v1/documents/upload', {\n    method: 'POST',\n    body: formData,\n    // Don't set Content-Type header - browser will set it with boundary for multipart/form-data\n  });\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Document upload failed: ${response.status} - ${errorText}`);\n  }\n  \n  const result = await response.json();\n  \n  // Get storage URL if available\n  let storageUrl = '';\n  if (result.storageKey) {\n    try {\n      // Try to get presigned URL for download\n      const downloadResponse = await fetch(`/api/proxy/api/v1/documents/download/${encodeURIComponent(result.storageKey)}`, {\n        method: 'GET',\n      });\n      if (downloadResponse.ok) {\n        const downloadResult = await downloadResponse.json();\n        storageUrl = downloadResult.url || downloadResult.downloadUrl || '';\n      }\n    } catch (error) {\n      console.warn('Failed to get download URL:', error);\n    }\n  }\n  \n  return {\n    documentId: result.documentId || result.id || '',\n    documentNumber: result.documentNumber || '',\n    wasDuplicate: result.wasDuplicate || false,\n    existingDocumentId: result.existingDocumentId,\n    storageKey: result.storageKey || '',\n    storageUrl\n  };\n}\n\n"],"names":[],"mappings":"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","ignoreList":[2,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}}]
}